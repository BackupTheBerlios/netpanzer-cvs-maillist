<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1093 - in trunk/netpanzer: nbproject	src/Lib/ArrayUtil src/NetPanzer/Bot src/NetPanzer/Classes	src/NetPanzer/Classes/AI src/NetPanzer/Classes/Network	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Units src/NetPanzer/Views/Components
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1093%20-%20in%20trunk/netpanzer%3A%20nbproject%0A%09src/Lib/ArrayUtil%20src/NetPanzer/Bot%20src/NetPanzer/Classes%0A%09src/NetPanzer/Classes/AI%20src/NetPanzer/Classes/Network%0A%09src/NetPanzer/Interfaces%20src/NetPanzer/Network%0A%09src/NetPanzer/Objectives%20src/NetPanzer/PowerUps%0A%09src/NetPanzer/Units%20src/NetPanzer/Views/Components&In-Reply-To=%3C200902210235.n1L2ZKnx024187%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000124.html">
   <LINK REL="Next"  HREF="000126.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1093 - in trunk/netpanzer: nbproject	src/Lib/ArrayUtil src/NetPanzer/Bot src/NetPanzer/Classes	src/NetPanzer/Classes/AI src/NetPanzer/Classes/Network	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Units src/NetPanzer/Views/Components</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1093%20-%20in%20trunk/netpanzer%3A%20nbproject%0A%09src/Lib/ArrayUtil%20src/NetPanzer/Bot%20src/NetPanzer/Classes%0A%09src/NetPanzer/Classes/AI%20src/NetPanzer/Classes/Network%0A%09src/NetPanzer/Interfaces%20src/NetPanzer/Network%0A%09src/NetPanzer/Objectives%20src/NetPanzer/PowerUps%0A%09src/NetPanzer/Units%20src/NetPanzer/Views/Components&In-Reply-To=%3C200902210235.n1L2ZKnx024187%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1093 - in trunk/netpanzer: nbproject	src/Lib/ArrayUtil src/NetPanzer/Bot src/NetPanzer/Classes	src/NetPanzer/Classes/AI src/NetPanzer/Classes/Network	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Units src/NetPanzer/Views/Components">kromxp at mail.berlios.de
       </A><BR>
    <I>Sat Feb 21 03:35:20 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000124.html">[Netpanzer-cvs] r1092 - in trunk/netpanzer: nbproject	src/NetPanzer/Classes src/NetPanzer/Interfaces	src/NetPanzer/Particles src/NetPanzer/Views/Components	src/NetPanzer/Views/Game src/NetPanzer/Views/MainMenu	src/NetPanzer/Views/MainMenu/Options
</A></li>
        <LI>Next message: <A HREF="000126.html">[Netpanzer-cvs] r1094 - trunk/netpanzer/src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#125">[ date ]</a>
              <a href="thread.html#125">[ thread ]</a>
              <a href="subject.html#125">[ subject ]</a>
              <a href="author.html#125">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2009-02-21 03:34:05 +0100 (Sat, 21 Feb 2009)
New Revision: 1093

Added:
   trunk/netpanzer/src/NetPanzer/Units/Unit.cpp
   trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
Removed:
   trunk/netpanzer/src/Lib/ArrayUtil/ArrayTemplate.hpp
   trunk/netpanzer/src/Lib/ArrayUtil/BucketArrayTemplate.hpp
   trunk/netpanzer/src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp
   trunk/netpanzer/src/Lib/ArrayUtil/QueueTemplate.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBase.hpp
   trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp
   trunk/netpanzer/src/NetPanzer/Units/Vehicle.hpp
Modified:
   trunk/netpanzer/nbproject/Makefile-mac-debug.mk
   trunk/netpanzer/nbproject/Makefile-mac-release.mk
   trunk/netpanzer/nbproject/configurations.xml
   trunk/netpanzer/src/NetPanzer/Bot/Bot.cpp
   trunk/netpanzer/src/NetPanzer/Bot/Bot.hpp
   trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
   trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.hpp
   trunk/netpanzer/src/NetPanzer/Bot/BotTask.hpp
   trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.cpp
   trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.hpp
   trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/PowerUpNetMessage.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/ServerConnectDaemon.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/UnitNetMessage.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.hpp
   trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
   trunk/netpanzer/src/NetPanzer/Classes/UnitMessage.hpp
   trunk/netpanzer/src/NetPanzer/Classes/UnitMessageTypes.hpp
   trunk/netpanzer/src/NetPanzer/Classes/WadMapTable.hpp
   trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameConfig.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
   trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.hpp
   trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
   trunk/netpanzer/src/NetPanzer/Objectives/Outpost.hpp
   trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitOpcodes.hpp
   trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
Log:
- Removed ArrayTemplate and some friends and replaced with STL containers
- Merged UnitBase with Vehicle, UnitBase deleted, Vehicle renamed &quot;Unit&quot;
- Fixed random crash when switching map or exiting netpanzer.
Notes:
These are a lot of changes, some bugs/memory leaks has been fixed, but the number of changes is big and some new bugs could appear.


Modified: trunk/netpanzer/nbproject/Makefile-mac-debug.mk
===================================================================
--- trunk/netpanzer/nbproject/Makefile-mac-debug.mk	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/nbproject/Makefile-mac-debug.mk	2009-02-21 02:34:05 UTC (rev 1093)
@@ -123,6 +123,7 @@
 	${OBJECTDIR}/src/Lib/lua/lstrlib.o \
 	${OBJECTDIR}/src/Lib/2D/ColorTable.o \
 	${OBJECTDIR}/src/Lib/physfs/zlib123/inftrees.o \
+	${OBJECTDIR}/src/NetPanzer/Units/Unit.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Game/DisconectedView.o \
 	${OBJECTDIR}/src/Lib/Types/Angle.o \
 	${OBJECTDIR}/src/Lib/physfs/platform/posix.o \
@@ -251,7 +252,6 @@
 	${OBJECTDIR}/src/Lib/Util/Log.o \
 	${OBJECTDIR}/src/Lib/optionmm/command_line.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Components/MiniMap.o \
-	${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o \
 	${OBJECTDIR}/src/NetPanzer/Views/MainMenu/MenuTemplateView.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Game/VehicleSelectionView.o \
 	${OBJECTDIR}/src/NetPanzer/PowerUps/PowerUp.o \
@@ -265,7 +265,6 @@
 	${OBJECTDIR}/src/NetPanzer/Particles/FireParticle2D.o \
 	${OBJECTDIR}/src/Lib/physfs/platform/os2.o \
 	${OBJECTDIR}/src/Lib/Network/SocketBase.o \
-	${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o \
 	${OBJECTDIR}/src/Lib/Network/UDPSocket.o \
 	${OBJECTDIR}/src/NetPanzer/Interfaces/PathScheduler.o \
 	${OBJECTDIR}/src/NetPanzer/Classes/TipOfDay.o \
@@ -786,6 +785,11 @@
 	${RM} $@.d
 	$(COMPILE.c) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/Lib/physfs/zlib123/inftrees.o src/Lib/physfs/zlib123/inftrees.c
 
+${OBJECTDIR}/src/NetPanzer/Units/Unit.o: src/NetPanzer/Units/Unit.cpp 
+	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Units
+	${RM} $@.d
+	$(COMPILE.cc) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Units/Unit.o src/NetPanzer/Units/Unit.cpp
+
 ${OBJECTDIR}/src/NetPanzer/Views/Game/DisconectedView.o: src/NetPanzer/Views/Game/DisconectedView.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Views/Game
 	${RM} $@.d
@@ -1426,11 +1430,6 @@
 	${RM} $@.d
 	$(COMPILE.cc) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Views/Components/MiniMap.o src/NetPanzer/Views/Components/MiniMap.cpp
 
-${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o: src/NetPanzer/Units/Vehicle.cpp 
-	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Units
-	${RM} $@.d
-	$(COMPILE.cc) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o src/NetPanzer/Units/Vehicle.cpp
-
 ${OBJECTDIR}/src/NetPanzer/Views/MainMenu/MenuTemplateView.o: src/NetPanzer/Views/MainMenu/MenuTemplateView.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Views/MainMenu
 	${RM} $@.d
@@ -1496,11 +1495,6 @@
 	${RM} $@.d
 	$(COMPILE.cc) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/Lib/Network/SocketBase.o src/Lib/Network/SocketBase.cpp
 
-${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o: src/NetPanzer/Classes/Network/NetPacketQueues.cpp 
-	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Classes/Network
-	${RM} $@.d
-	$(COMPILE.cc) -g -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o src/NetPanzer/Classes/Network/NetPacketQueues.cpp
-
 ${OBJECTDIR}/src/Lib/Network/UDPSocket.o: src/Lib/Network/UDPSocket.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/Lib/Network
 	${RM} $@.d

Modified: trunk/netpanzer/nbproject/Makefile-mac-release.mk
===================================================================
--- trunk/netpanzer/nbproject/Makefile-mac-release.mk	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/nbproject/Makefile-mac-release.mk	2009-02-21 02:34:05 UTC (rev 1093)
@@ -123,6 +123,7 @@
 	${OBJECTDIR}/src/Lib/lua/lstrlib.o \
 	${OBJECTDIR}/src/Lib/2D/ColorTable.o \
 	${OBJECTDIR}/src/Lib/physfs/zlib123/inftrees.o \
+	${OBJECTDIR}/src/NetPanzer/Units/Unit.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Game/DisconectedView.o \
 	${OBJECTDIR}/src/Lib/Types/Angle.o \
 	${OBJECTDIR}/src/Lib/physfs/platform/posix.o \
@@ -251,7 +252,6 @@
 	${OBJECTDIR}/src/Lib/Util/Log.o \
 	${OBJECTDIR}/src/Lib/optionmm/command_line.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Components/MiniMap.o \
-	${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o \
 	${OBJECTDIR}/src/NetPanzer/Views/MainMenu/MenuTemplateView.o \
 	${OBJECTDIR}/src/NetPanzer/Views/Game/VehicleSelectionView.o \
 	${OBJECTDIR}/src/NetPanzer/PowerUps/PowerUp.o \
@@ -265,7 +265,6 @@
 	${OBJECTDIR}/src/NetPanzer/Particles/FireParticle2D.o \
 	${OBJECTDIR}/src/Lib/physfs/platform/os2.o \
 	${OBJECTDIR}/src/Lib/Network/SocketBase.o \
-	${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o \
 	${OBJECTDIR}/src/Lib/Network/UDPSocket.o \
 	${OBJECTDIR}/src/NetPanzer/Interfaces/PathScheduler.o \
 	${OBJECTDIR}/src/NetPanzer/Classes/TipOfDay.o \
@@ -786,6 +785,11 @@
 	${RM} $@.d
 	$(COMPILE.c) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/Lib/physfs/zlib123/inftrees.o src/Lib/physfs/zlib123/inftrees.c
 
+${OBJECTDIR}/src/NetPanzer/Units/Unit.o: src/NetPanzer/Units/Unit.cpp 
+	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Units
+	${RM} $@.d
+	$(COMPILE.cc) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Units/Unit.o src/NetPanzer/Units/Unit.cpp
+
 ${OBJECTDIR}/src/NetPanzer/Views/Game/DisconectedView.o: src/NetPanzer/Views/Game/DisconectedView.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Views/Game
 	${RM} $@.d
@@ -1426,11 +1430,6 @@
 	${RM} $@.d
 	$(COMPILE.cc) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Views/Components/MiniMap.o src/NetPanzer/Views/Components/MiniMap.cpp
 
-${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o: src/NetPanzer/Units/Vehicle.cpp 
-	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Units
-	${RM} $@.d
-	$(COMPILE.cc) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Units/Vehicle.o src/NetPanzer/Units/Vehicle.cpp
-
 ${OBJECTDIR}/src/NetPanzer/Views/MainMenu/MenuTemplateView.o: src/NetPanzer/Views/MainMenu/MenuTemplateView.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Views/MainMenu
 	${RM} $@.d
@@ -1496,11 +1495,6 @@
 	${RM} $@.d
 	$(COMPILE.cc) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/Lib/Network/SocketBase.o src/Lib/Network/SocketBase.cpp
 
-${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o: src/NetPanzer/Classes/Network/NetPacketQueues.cpp 
-	${MKDIR} -p ${OBJECTDIR}/src/NetPanzer/Classes/Network
-	${RM} $@.d
-	$(COMPILE.cc) -O2 -Wall -DPHYSFS_SUPPORTS_ZIP=1 -DZ_PREFIX=1 -I. -Isrc/Lib -Isrc/NetPanzer -Isrc/Lib/physfs -Isrc/Lib/physfs/zlib123 -I/Library/Frameworks/SDL.framework/Versions/A/Headers -I/Library/Frameworks/SDL_mixer.framework/Versions/A/Headers -MMD -MP -MF $@.d -o ${OBJECTDIR}/src/NetPanzer/Classes/Network/NetPacketQueues.o src/NetPanzer/Classes/Network/NetPacketQueues.cpp
-
 ${OBJECTDIR}/src/Lib/Network/UDPSocket.o: src/Lib/Network/UDPSocket.cpp 
 	${MKDIR} -p ${OBJECTDIR}/src/Lib/Network
 	${RM} $@.d

Modified: trunk/netpanzer/nbproject/configurations.xml
===================================================================
--- trunk/netpanzer/nbproject/configurations.xml	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/nbproject/configurations.xml	2009-02-21 02:34:05 UTC (rev 1093)
@@ -28,14 +28,10 @@
           &lt;itemPath&gt;src/Lib/2D/Surface.hpp&lt;/itemPath&gt;
         &lt;/logicalFolder&gt;
         &lt;logicalFolder name=&quot;ArrayUtil&quot; displayName=&quot;ArrayUtil&quot; projectFiles=&quot;true&quot;&gt;
-          &lt;itemPath&gt;src/Lib/ArrayUtil/ArrayTemplate.hpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/Lib/ArrayUtil/BitArray.cpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/Lib/ArrayUtil/BitArray.hpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/Lib/ArrayUtil/BoundBox.cpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/Lib/ArrayUtil/BoundBox.hpp&lt;/itemPath&gt;
-          &lt;itemPath&gt;src/Lib/ArrayUtil/BucketArrayTemplate.hpp&lt;/itemPath&gt;
-          &lt;itemPath&gt;src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp&lt;/itemPath&gt;
-          &lt;itemPath&gt;src/Lib/ArrayUtil/QueueTemplate.hpp&lt;/itemPath&gt;
         &lt;/logicalFolder&gt;
         &lt;logicalFolder name=&quot;INIParser&quot; displayName=&quot;INIParser&quot; projectFiles=&quot;true&quot;&gt;
           &lt;itemPath&gt;src/Lib/INIParser/Section.cpp&lt;/itemPath&gt;
@@ -248,8 +244,6 @@
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetPacket.hpp&lt;/itemPath&gt;
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetPacketDebugger.cpp&lt;/itemPath&gt;
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetPacketDebugger.hpp&lt;/itemPath&gt;
-            &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetPacketQueues.cpp&lt;/itemPath&gt;
-            &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetPacketQueues.hpp&lt;/itemPath&gt;
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetTypes.hpp&lt;/itemPath&gt;
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetworkClient.cpp&lt;/itemPath&gt;
             &lt;itemPath&gt;src/NetPanzer/Classes/Network/NetworkClient.hpp&lt;/itemPath&gt;
@@ -477,7 +471,8 @@
           &lt;itemPath&gt;src/NetPanzer/System/Sound.hpp&lt;/itemPath&gt;
         &lt;/logicalFolder&gt;
         &lt;logicalFolder name=&quot;Units&quot; displayName=&quot;Units&quot; projectFiles=&quot;true&quot;&gt;
-          &lt;itemPath&gt;src/NetPanzer/Units/UnitBase.hpp&lt;/itemPath&gt;
+          &lt;itemPath&gt;src/NetPanzer/Units/Unit.cpp&lt;/itemPath&gt;
+          &lt;itemPath&gt;src/NetPanzer/Units/Unit.hpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/NetPanzer/Units/UnitBlackBoard.cpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/NetPanzer/Units/UnitBlackBoard.hpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/NetPanzer/Units/UnitBucketArray.cpp&lt;/itemPath&gt;
@@ -497,8 +492,6 @@
           &lt;itemPath&gt;src/NetPanzer/Units/UnitState.cpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/NetPanzer/Units/UnitState.hpp&lt;/itemPath&gt;
           &lt;itemPath&gt;src/NetPanzer/Units/UnitTypes.hpp&lt;/itemPath&gt;
-          &lt;itemPath&gt;src/NetPanzer/Units/Vehicle.cpp&lt;/itemPath&gt;
-          &lt;itemPath&gt;src/NetPanzer/Units/Vehicle.hpp&lt;/itemPath&gt;
         &lt;/logicalFolder&gt;
         &lt;logicalFolder name=&quot;Views&quot; displayName=&quot;Views&quot; projectFiles=&quot;true&quot;&gt;
           &lt;logicalFolder name=&quot;Components&quot; displayName=&quot;Components&quot; projectFiles=&quot;true&quot;&gt;
@@ -743,9 +736,6 @@
       &lt;item path=&quot;src/Lib/2D/Surface.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/ArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/ArrayUtil/BitArray.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -758,15 +748,6 @@
       &lt;item path=&quot;src/Lib/ArrayUtil/BoundBox.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/BucketArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/QueueTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/INIParser/Section.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -1322,12 +1303,6 @@
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketDebugger.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -1928,7 +1903,10 @@
       &lt;item path=&quot;src/NetPanzer/System/Sound.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/UnitBase.hpp&quot;&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.cpp&quot;&gt;
+        &lt;itemTool&gt;1&lt;/itemTool&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Units/UnitBlackBoard.cpp&quot;&gt;
@@ -1988,12 +1966,6 @@
       &lt;item path=&quot;src/NetPanzer/Units/UnitTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Views/Components/Button.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -2443,9 +2415,6 @@
       &lt;item path=&quot;src/Lib/2D/Surface.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/ArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/ArrayUtil/BitArray.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -2458,15 +2427,6 @@
       &lt;item path=&quot;src/Lib/ArrayUtil/BoundBox.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/BucketArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/QueueTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/INIParser/Section.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -3022,12 +2982,6 @@
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketDebugger.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -3628,7 +3582,10 @@
       &lt;item path=&quot;src/NetPanzer/System/Sound.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/UnitBase.hpp&quot;&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.cpp&quot;&gt;
+        &lt;itemTool&gt;1&lt;/itemTool&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Units/UnitBlackBoard.cpp&quot;&gt;
@@ -3688,12 +3645,6 @@
       &lt;item path=&quot;src/NetPanzer/Units/UnitTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Views/Components/Button.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -4143,9 +4094,6 @@
       &lt;item path=&quot;src/Lib/2D/Surface.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/ArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/ArrayUtil/BitArray.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -4158,15 +4106,6 @@
       &lt;item path=&quot;src/Lib/ArrayUtil/BoundBox.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/BucketArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/QueueTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/INIParser/Section.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -4722,12 +4661,6 @@
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketDebugger.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -5328,7 +5261,10 @@
       &lt;item path=&quot;src/NetPanzer/System/Sound.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/UnitBase.hpp&quot;&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.cpp&quot;&gt;
+        &lt;itemTool&gt;1&lt;/itemTool&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Units/UnitBlackBoard.cpp&quot;&gt;
@@ -5388,12 +5324,6 @@
       &lt;item path=&quot;src/NetPanzer/Units/UnitTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Views/Components/Button.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -5843,9 +5773,6 @@
       &lt;item path=&quot;src/Lib/2D/Surface.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/ArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/ArrayUtil/BitArray.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -5858,15 +5785,6 @@
       &lt;item path=&quot;src/Lib/ArrayUtil/BoundBox.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/BucketArrayTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/Lib/ArrayUtil/QueueTemplate.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/Lib/INIParser/Section.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -6422,12 +6340,6 @@
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketDebugger.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Classes/Network/NetPacketQueues.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Classes/Network/NetTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
@@ -7028,7 +6940,10 @@
       &lt;item path=&quot;src/NetPanzer/System/Sound.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/UnitBase.hpp&quot;&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.cpp&quot;&gt;
+        &lt;itemTool&gt;1&lt;/itemTool&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;src/NetPanzer/Units/Unit.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Units/UnitBlackBoard.cpp&quot;&gt;
@@ -7088,12 +7003,6 @@
       &lt;item path=&quot;src/NetPanzer/Units/UnitTypes.hpp&quot;&gt;
         &lt;itemTool&gt;3&lt;/itemTool&gt;
       &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.cpp&quot;&gt;
-        &lt;itemTool&gt;1&lt;/itemTool&gt;
-      &lt;/item&gt;
-      &lt;item path=&quot;src/NetPanzer/Units/Vehicle.hpp&quot;&gt;
-        &lt;itemTool&gt;3&lt;/itemTool&gt;
-      &lt;/item&gt;
       &lt;item path=&quot;src/NetPanzer/Views/Components/Button.cpp&quot;&gt;
         &lt;itemTool&gt;1&lt;/itemTool&gt;
       &lt;/item&gt;

Deleted: trunk/netpanzer/src/Lib/ArrayUtil/ArrayTemplate.hpp
===================================================================
--- trunk/netpanzer/src/Lib/ArrayUtil/ArrayTemplate.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/Lib/ArrayUtil/ArrayTemplate.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,81 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _ARRAYTEMPLATE_HPP
-#define _ARRAYTEMPLATE_HPP
-
-#include &lt;assert.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;Util/NoCopy.hpp&quot;
-
-template&lt; class TYPE &gt;
-class ArrayTemplate : public NoCopy
-{
-protected:
-    size_t size;
-    TYPE *array;
-
-public:
-    ArrayTemplate()
-    {
-        size = 0;
-        array = 0;
-    }
-    ArrayTemplate(size_t newsize)
-        : size(newsize)
-    {
-        array = new TYPE[size];
-    }
-    ~ArrayTemplate()
-    {
-        delete[] array;
-    }
-
-    void initialize(size_t newsize)
-    {
-        deallocate();
-        array = new TYPE[newsize];
-        size = newsize;
-    }
-
-    TYPE &amp;operator[](size_t index)
-    {
-        assert( index &lt; size );
-        return array[index];
-    }
-
-    void add(const TYPE&amp; object, size_t index)
-    {
-        assert( index &lt; size );
-        array[index] = object;
-    }
-
-    size_t getSize() const
-    {
-        return size;
-    }
-
-    void deallocate()
-    {
-        delete[] array;
-        array = 0;
-        size = 0;
-    }
-};
-
-#endif // ** _ARRAYTEMPLATE_HPP

Deleted: trunk/netpanzer/src/Lib/ArrayUtil/BucketArrayTemplate.hpp
===================================================================
--- trunk/netpanzer/src/Lib/ArrayUtil/BucketArrayTemplate.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/Lib/ArrayUtil/BucketArrayTemplate.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,109 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _BUCKETARRAYTEMPLATE_HPP
-#define _BUCKETARRAYTEMPLATE_HPP
-
-#include &lt;assert.h&gt;
-#include &quot;ArrayUtil/LinkListDoubleTemplate.hpp&quot;
-#include &quot;Util/NoCopy.hpp&quot;
-
-template&lt; class TYPE &gt;
-class BucketArrayTemplate : public NoCopy
-{
-protected:
-    size_t size;
-    size_t row_size;
-    size_t column_size;
-    LinkListDoubleTemplate&lt; TYPE &gt; *array;
-
-public:
-    BucketArrayTemplate()
-        : size(0), row_size(0), column_size(0), array(0)
-    {
-    }
-
-    BucketArrayTemplate(size_t rows, size_t columns)
-        : size(0), row_size(0), column_size(0), array(0)
-    {
-        initialize(rows, columns);
-    }
-
-    ~BucketArrayTemplate()
-    {
-        deallocate();
-    }
-
-    void initialize(size_t rows, size_t columns)
-    {
-        deallocate();
-
-        row_size = rows;
-        column_size = columns;
-
-        size = row_size * column_size;
-
-        array = new LinkListDoubleTemplate&lt; TYPE &gt; [ size ];
-    }
-
-    void deallocate()
-    {
-        delete[] array;
-
-        array = 0;
-        size = 0;
-        row_size = 0;
-        column_size = 0;
-    }
-
-    size_t getSize() const
-    {
-        return size;
-    }
-
-    void addObject(size_t bucket_index, TYPE *object)
-    {
-        assert( bucket_index &lt; size );
-
-        array[ bucket_index ].addFront( object );
-    }
-
-    void addObject(size_t row, size_t column, TYPE *object)
-    {
-        size_t bucket_index = (row * column_size) + column;
-        assert( bucket_index &lt; size );
-
-        array[ bucket_index ].addFront( object );
-    }
-
-    LinkListDoubleTemplate&lt; TYPE &gt; * getBucket(size_t bucket_index)
-    {
-        assert( bucket_index &lt; size );
-        return( &amp;(array[ bucket_index ]) );
-    }
-
-    LinkListDoubleTemplate&lt; TYPE &gt; * getBucket(size_t row,
-            size_t column )
-    {
-        size_t bucket_index = (row * column_size) + column;
-
-        assert( bucket_index &lt; size );
-        return( &amp;(array[ bucket_index ]) );
-    }
-};
-
-#endif // ** _BUCKETARRAYTEMPLATE_HPP

Deleted: trunk/netpanzer/src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp
===================================================================
--- trunk/netpanzer/src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/Lib/ArrayUtil/LinkListDoubleTemplate.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,332 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _LINKLISTDOUBLETEMPLATE_HPP
-#define _LINKLISTDOUBLETEMPLATE_HPP
-
-#include &quot;Util/NoCopy.hpp&quot;
-
-template&lt; class TYPE &gt;
-class LinkListDoubleTemplate : public NoCopy
-{
-protected:
-    TYPE *front;
-    TYPE *rear;
-
-public:
-    LinkListDoubleTemplate()
-            : front(0), rear(0)
-    { }
-
-    ~LinkListDoubleTemplate()
-    {
-        deallocate();
-    }
-
-    TYPE* getFront()
-    {
-        return front;
-    }
-
-    TYPE* getRear()
-    {
-        return rear;
-    }
-
-    void addRear(TYPE *object)
-    {
-        object-&gt;next = 0;
-        object-&gt;prev = rear;
-
-        if (rear == 0) {
-            front = object;
-            rear = object;
-        } else {
-            rear-&gt;next = object;
-            rear = object;
-        }
-    }
-
-    void addFront(TYPE *object)
-    {
-        object-&gt;next = front;
-        object-&gt;prev = 0;
-
-        if (front == 0) {
-            front = object;
-            rear = object;
-        } else {
-            front-&gt;prev = object;
-            front = object;
-        }
-    }
-
-    void insertAfter(TYPE *after, TYPE *object)
-    {
-        assert(after != 0);
-
-        if(after-&gt;next != 0) {
-            after-&gt;next-&gt;prev = object;
-        }
-
-        object-&gt;next = after-&gt;next;
-        after-&gt;next = object;
-        object-&gt;prev = after;
-
-        if(after == rear) {
-            rear = object;
-        }
-    }
-
-    void insertBefore(TYPE *before, TYPE *object)
-    {
-        assert(before != 0);
-
-        if(before-&gt;prev != 0) {
-            before-&gt;prev-&gt;next = object;
-        }
-
-        object-&gt;prev = before-&gt;prev;
-        before-&gt;prev = object;
-        object-&gt;next = before;
-
-        if(before == front) {
-            front = object;
-        }
-    }
-
-    void deleteObject(TYPE *object)
-    {
-        if( object-&gt;prev != 0 ) {
-            object-&gt;prev-&gt;next = object-&gt;next;
-        }
-
-        if( object-&gt;next != 0 ) {
-            object-&gt;next-&gt;prev = object-&gt;prev;
-        }
-
-        if(object == front) {
-            front = object-&gt;next;
-        }
-
-        if(object == rear) {
-            rear = object-&gt;prev;
-        }
-
-        delete object;
-    }
-
-    void deleteFront()
-    {
-        if(front == 0)
-            return;
-
-        TYPE* oldfront = front;
-
-        if (front == rear) {
-            front = 0;
-            rear = 0;
-        } else {
-            front = front-&gt;next;
-            front-&gt;prev = 0;
-        }
-
-        delete oldfront;
-    }
-
-    void deleteRear()
-    {
-        if(rear == 0)
-            return;
-
-        TYPE *oldrear = rear;
-
-        if (front == rear) {
-            front = 0;
-            rear = 0;
-        } else {
-            rear = rear-&gt;prev;
-            rear-&gt;next = 0;
-        }
-
-        delete oldrear;
-    }
-
-    void deleteAfter(TYPE *after)
-    {
-        assert( after != 0 );
-
-        TYPE* object = after-&gt;next;
-
-        if(object == 0)
-            return;
-
-        after-&gt;next = object-&gt;next;
-
-        if(object-&gt;next != 0) {
-            object-&gt;next-&gt;prev = after;
-        }
-
-        if(object == rear) {
-            rear = after;
-        }
-
-        delete object;
-    }
-
-    void removeObject(TYPE *object)
-    {
-        if( object-&gt;prev != 0 ) {
-            object-&gt;prev-&gt;next = object-&gt;next;
-        }
-
-        if( object-&gt;next != 0 ) {
-            object-&gt;next-&gt;prev = object-&gt;prev;
-        }
-
-        if( object == front ) {
-            front = object-&gt;next;
-        }
-
-        if( object == rear ) {
-            rear = object-&gt;prev;
-        }
-    }
-
-
-    TYPE* removeFront()
-    {
-        TYPE *delete_ptr;
-
-        delete_ptr = front;
-
-        if ( front != 0 ) {
-            if (front == rear) {
-                front = 0;
-                rear = 0;
-            } else {
-                front = front-&gt;next;
-                front-&gt;prev = 0;
-            }
-
-            return( delete_ptr );
-        }
-
-        return( 0 );
-    }
-
-    TYPE* removeRear()
-    {
-        TYPE *delete_ptr;
-
-        delete_ptr = rear;
-
-        if ( rear != 0 ) {
-            if (front == rear) {
-                front = 0;
-                rear = 0;
-            } else {
-                rear = rear-&gt;prev;
-                rear-&gt;next = 0;
-            }
-
-            return delete_ptr;
-        }
-        return 0;
-    }
-
-    TYPE* removeAfter( TYPE *after )
-    {
-        TYPE *delete_ptr;
-        assert( after != 0 );
-
-        delete_ptr = after-&gt;next;
-
-        if( after-&gt;next != 0 ) {
-            if( after-&gt;next-&gt;next != 0 ) {
-                after-&gt;next-&gt;next-&gt;prev = after;
-                after-&gt;next = after-&gt;next-&gt;next ;
-            } else {
-                after-&gt;next = 0;
-            }
-
-            if( delete_ptr == rear ) {
-                rear = after;
-            }
-
-            return delete_ptr;
-        }
-
-        return 0;
-    }
-
-    TYPE* removeBefore( TYPE *before )
-    {
-        TYPE *delete_ptr;
-        assert( before != 0 );
-
-        delete_ptr = before-&gt;prev;
-
-        if( before-&gt;prev != 0 ) {
-            if( before-&gt;prev-&gt;prev != 0 ) {
-                before-&gt;prev-&gt;prev-&gt;next = before;
-                before-&gt;prev = before-&gt;prev-&gt;prev;
-            } else {
-                before-&gt;prev = 0;
-            }
-
-            if( delete_ptr == front ) {
-                front = before;
-            }
-
-            return delete_ptr;
-        }
-        return 0;
-    }
-
-
-    size_t getSize() const
-    {
-        TYPE *traversal_ptr;
-        size_t count = 0;
-
-        for(TYPE* p = front; p != 0; p = p-&gt;next)
-            count++;
-
-        return count;
-    }
-
-    void deallocate()
-    {
-        TYPE *traversal_ptr;
-        TYPE *delete_ptr;
-
-        traversal_ptr = front;
-
-        while( traversal_ptr != 0 ) {
-            delete_ptr = traversal_ptr;
-            traversal_ptr = traversal_ptr-&gt;next;
-            delete delete_ptr;
-        }
-
-        front = 0;
-        rear = 0;
-    }
-};
-
-#endif // ** _LINKLISTDOUBLETEMPLATE_HPP
-

Deleted: trunk/netpanzer/src/Lib/ArrayUtil/QueueTemplate.hpp
===================================================================
--- trunk/netpanzer/src/Lib/ArrayUtil/QueueTemplate.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/Lib/ArrayUtil/QueueTemplate.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,126 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _QUEUETEMPLATE_HPP
-#define _QUEUETEMPLATE_HPP
-
-#include &quot;ArrayTemplate.hpp&quot;
-
-template&lt; class TYPE &gt;
-class QueueTemplate : public ArrayTemplate&lt; TYPE &gt;
-{
-public:
-    unsigned long front;
-    unsigned long rear;
-
-    QueueTemplate( )
-    { }
-
-    QueueTemplate( unsigned long size );
-
-    void initialize( unsigned long size );
-
-    void reset()
-    {
-        front = 0;
-        rear = 0;
-    }
-
-    bool enqueue(const TYPE&amp; object )
-    {
-        add( object, (rear + 1) % this-&gt;size );
-        rear = (rear + 1) % this-&gt;size;
-
-        if ( front == rear )
-            return( false );
-
-        return( true );
-    }
-
-    TYPE dequeue()
-    {
-        assert( front != rear );
-
-        front = ( front + 1 ) % this-&gt;size;
-        return( this-&gt;array[ front ] );
-    }
-
-    void pop()
-    {
-        assert( front != rear );
-
-        front = ( front + 1 ) % this-&gt;size;
-    }
-
-    TYPE getFirst()
-    {
-        assert( front != rear );
-
-        return( this-&gt;array[ (( front + 1 ) % this-&gt;size) ] );
-    }
-
-    TYPE * getFirstPtr()
-    {
-        assert( front != rear );
-
-        return( &amp;(this-&gt;array[ (( front + 1 ) % this-&gt;size) ]) );
-    }
-
-
-    bool isEmpty() const
-    {
-        return front == rear;
-    }
-
-    bool isFull () const
-    {
-        return front == (rear + 1) % this-&gt;size;
-    }
-
-    bool isReady() const
-    {
-        return front != rear;
-    }
-
-    unsigned long itemCount() const
-    {
-        if ( front &gt; rear )
-            return ( (rear+1) + ( (this-&gt;size-1) - front ) );
-        else
-            return ( rear - front );
-    }
-};
-
-
-template&lt; class TYPE &gt;
-QueueTemplate&lt; TYPE &gt;::QueueTemplate( unsigned long size )
-        : ArrayTemplate&lt;TYPE&gt;( size )
-{
-    front = 0;
-    rear = 0;
-}
-
-template&lt; class TYPE &gt;
-void QueueTemplate&lt; TYPE &gt;::initialize( unsigned long size )
-{
-    ArrayTemplate&lt; TYPE &gt;::initialize( size );
-    front = 0;
-    rear = 0;
-}
-
-
-#endif // ** _QUEUETEMPLATE_HPP

Modified: trunk/netpanzer/src/NetPanzer/Bot/Bot.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/Bot.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/Bot.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -22,7 +22,7 @@
 #include &quot;Bot.hpp&quot;
 
 #include &quot;Classes/PlacementMatrix.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Objectives/Objective.hpp&quot;
 #include &quot;Classes/Network/TerminalNetMesg.hpp&quot;
 #include &quot;Classes/Network/NetworkClient.hpp&quot;
@@ -37,7 +37,7 @@
 }
 
 void
-Bot::moveUnit(UnitBase *unit, iXY map_pos)
+Bot::moveUnit(Unit *unit, iXY map_pos)
 {
     assert(unit != 0);
 
@@ -56,7 +56,7 @@
 }
 //-----------------------------------------------------------------
 void
-Bot::attackUnit(UnitBase *unit, UnitBase *enemyUnit)
+Bot::attackUnit(Unit *unit, Unit *enemyUnit)
 {
     assert(unit != 0);
     assert(enemyUnit != 0);
@@ -72,7 +72,7 @@
 }
 //-----------------------------------------------------------------
 void
-Bot::manualFire(UnitBase *unit, iXY world_pos)
+Bot::manualFire(Unit *unit, iXY world_pos)
 {
     assert(unit != 0);
 

Modified: trunk/netpanzer/src/NetPanzer/Bot/Bot.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/Bot.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/Bot.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,7 +18,7 @@
 #ifndef BOT_H
 #define BOT_H
 
-class UnitBase;
+class Unit;
 class ObjectiveState;
 class iXY;
 
@@ -32,9 +32,9 @@
     virtual ~Bot() {}
     virtual void processEvents() = 0;
 
-    void moveUnit(UnitBase *unit, iXY map_pos);
-    void attackUnit(UnitBase *unit, UnitBase *enemyUnit);
-    void manualFire(UnitBase *unit, iXY world_pos);
+    void moveUnit(Unit *unit, iXY map_pos);
+    void attackUnit(Unit *unit, Unit *enemyUnit);
+    void manualFire(Unit *unit, iXY world_pos);
     void produceUnit(ObjectiveID outpostID, int selectedProduce);
 protected:
     BotTaskList m_tasks;

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -29,10 +29,9 @@
 #include &quot;Units/UnitProfileInterface.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
 #include &quot;Objectives/ObjectiveInterface.hpp&quot;
 #include &quot;Objectives/Objective.hpp&quot;
-#include &quot;Units/Vehicle.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
 
 //-----------------------------------------------------------------
@@ -48,7 +47,7 @@
     int playerIndex = isReady();
     if (playerIndex != NONE_PLAYER)
     {
-        UnitBase *unit = getRandomUnit(playerIndex);
+        Unit *unit = getRandomUnit(playerIndex);
         if (unit)
         {
             int unitTask = m_tasks.queryUnitTask(unit);
@@ -57,7 +56,7 @@
             }
 
             // manual fire on closest enemy
-            UnitBase *enemyUnit;
+            Unit *enemyUnit;
             if (UnitInterface::queryClosestEnemyUnit(&amp;enemyUnit,
                         unit-&gt;unit_state.location, playerIndex))
             {
@@ -95,10 +94,10 @@
 /**
  * @return unit which belong to playerIndex
  */
-UnitBase *
+Unit *
 BotPlayer::getRandomUnit(int playerIndex)
 {
-    const std::vector&lt;UnitBase*&gt;&amp; units 
+    const std::vector&lt;Unit*&gt;&amp; units
         = UnitInterface::getPlayerUnits(playerIndex);
 
     if(units.size() == 0)
@@ -148,10 +147,10 @@
 /**
  * @return enemy unit
  */
-UnitBase *
+Unit *
 BotPlayer::getRandomEnemy()
 {
-    UnitBase *enemyUnit = 0;
+    Unit *enemyUnit = 0;
     int enemyPlayer = getRandomEnemyPlayer();
     if (enemyPlayer != NONE_PLAYER) {
         enemyUnit = getRandomUnit(enemyPlayer);
@@ -206,7 +205,7 @@
  * Occupy free or enemy oupost.
  */
 void
-BotPlayer::unitOccupyOupost(UnitBase *unit)
+BotPlayer::unitOccupyOupost(Unit *unit)
 {
     ObjectiveState *outpost =
         getRandomOutpost(_objective_disposition_unoccupied);

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -39,15 +39,15 @@
         virtual void processEvents();
 
         int isReady();
-        UnitBase *getRandomUnit(int playerIndex);
+        Unit *getRandomUnit(int playerIndex);
 
         playerList_t getEnemyPlayers();
         int getRandomEnemyPlayer();
-        UnitBase *getRandomEnemy();
+        Unit *getRandomEnemy();
 
         outpostList_t getOutposts(int disposition);
         ObjectiveState *getRandomOutpost(int disposition);
-        void unitOccupyOupost(UnitBase *unit);
+        void unitOccupyOupost(Unit *unit);
         void outpostProduce();
 };
 

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotTask.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotTask.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotTask.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,7 +18,7 @@
 #ifndef BOTTASKS_H
 #define BOTTASKS_H
 
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Types/iXY.hpp&quot;
 #include &quot;BotTaskList.hpp&quot;
 
 class BotTask {

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,6 +20,7 @@
 #include &quot;BotTaskList.hpp&quot;
 #include &quot;BotTask.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 
 //-----------------------------------------------------------------
 BotTaskList::~BotTaskList()
@@ -32,7 +33,7 @@
 /**
  * If unit didn't move then task=IDLE
  */
-void BotTaskList::adjustLastUnitLoc(UnitBase *unit)
+void BotTaskList::adjustLastUnitLoc(Unit *unit)
 {
     iXY curLoc = unit-&gt;unit_state.location;
     if (curLoc == m_tasks[unit-&gt;id]-&gt;getLastLoc()) {
@@ -41,7 +42,7 @@
     m_tasks[unit-&gt;id]-&gt;setLastLoc(curLoc);
 }
 //-----------------------------------------------------------------
-void BotTaskList::setUnitTask(UnitBase *unit, int task)
+void BotTaskList::setUnitTask(Unit *unit, int task)
 {
     bottasks_t::iterator it = m_tasks.find(unit-&gt;id);
     if (it == m_tasks.end()) {
@@ -56,7 +57,7 @@
 /**
  * Query for unit task and adjust unit last location.
  */
-int BotTaskList::queryUnitTask(UnitBase *unit)
+int BotTaskList::queryUnitTask(Unit *unit)
 {
     bottasks_t::iterator it = m_tasks.find(unit-&gt;id);
     if (it == m_tasks.end()) {

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotTaskList.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,10 +18,11 @@
 #ifndef BOTTASKSLIST_H
 #define BOTTASKSLIST_H
 
+#include &quot;Core/CoreTypes.hpp&quot;
+
 class BotTask;
+class Unit;
 
-#include &quot;Units/UnitBase.hpp&quot;
-
 #include &lt;map&gt;
 typedef std::map&lt;UnitID, BotTask*&gt; bottasks_t;
 
@@ -35,12 +36,12 @@
     private:
         bottasks_t m_tasks;
 
-        void adjustLastUnitLoc(UnitBase *unit);
+        void adjustLastUnitLoc(Unit *unit);
     public:
         ~BotTaskList();
 
-        void setUnitTask(UnitBase *unit, int task);
-        int queryUnitTask(UnitBase *unit);
+        void setUnitTask(Unit *unit, int task);
+        int queryUnitTask(Unit *unit);
 };
 
 #endif

Modified: trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,11 +20,12 @@
 
 #include &lt;queue&gt;
 
+#include &quot;Core/CoreTypes.hpp&quot;
+
 #include &quot;ArrayUtil/BitArray.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Classes/AI/PathList.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
 
 enum { _path_request_full, _path_request_update };
 enum { _slot_status_free, _slot_status_busy, _slot_status_wait, _slot_status_flush };

Deleted: trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,23 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#include &lt;config.h&gt;
-
-#include &quot;Util/Log.hpp&quot;
-#include &quot;NetPacketQueues.hpp&quot;
-#include &quot;Interfaces/ConsoleInterface.hpp&quot;
-

Deleted: trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketQueues.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,49 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _NETPACKETQUEUES_HPP
-#define _NETPACKETQUEUES_HPP
-
-#include &lt;string.h&gt;
-#include &quot;Classes/Network/NetPacket.hpp&quot;
-#include &quot;ArrayUtil/QueueTemplate.hpp&quot;
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
-#include &quot;Util/Timer.hpp&quot;
-
-class NetPacketQueue : public QueueTemplate&lt; NetPacket &gt;
-{
-public:
-    void add(NetPacket *object, unsigned long index)
-    {
-        memcpy(&amp;array[index], object, sizeof(NetPacket));
-    }
-
-    void dequeue(NetPacket *object)
-    {
-        assert( front != rear );
-        front = ( front + 1 ) % size;
-        memcpy(object, &amp;array[ front ], sizeof(NetPacket));
-    }
-
-    void enqueue(NetPacket &amp;object)
-    {
-        add(&amp;object, (rear + 1) % size);
-        rear = (rear + 1) % size;
-    }
-};
-
-#endif // ** _NETPACKETQUEUES_HPP

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -24,7 +24,6 @@
 #include &quot;Network/ClientSocket.hpp&quot;
 
 #include &quot;Util/Timer.hpp&quot;
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
 
 enum { _connection_status_no_connection,
        _connection_status_connected

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/PowerUpNetMessage.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/PowerUpNetMessage.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/PowerUpNetMessage.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -21,8 +21,6 @@
 #include &quot;Core/CoreTypes.hpp&quot;
 #include &quot;NetMessage.hpp&quot;
 
-#include &quot;Units/UnitBase.hpp&quot;
-
 enum { _net_message_id_powerup_create,
        _net_message_id_powerup_hit
      };

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/ServerConnectDaemon.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/ServerConnectDaemon.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/ServerConnectDaemon.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -21,7 +21,6 @@
 #include &lt;list&gt;
 
 #include &quot;Classes/PlayerState.hpp&quot;
-#include &quot;ArrayUtil/QueueTemplate.hpp&quot;
 #include &quot;Classes/Network/NetPacket.hpp&quot;
 #include &quot;Network/ClientSocket.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/UnitNetMessage.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitNetMessage.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/UnitNetMessage.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,7 +20,6 @@
 
 #include &quot;NetMessage.hpp&quot;
 #include &quot;Units/UnitState.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
 #include &quot;Units/UnitOpcodes.hpp&quot;
 
 #define _OPCODE_MESSAGE_LIMIT 488

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,7 +20,7 @@
 #include &quot;UnitSync.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Classes/Network/UnitNetMessage.hpp&quot;
 
@@ -55,7 +55,7 @@
         return false;
     }
     
-    UnitBase* unit = i-&gt;second;
+    Unit* unit = i-&gt;second;
     unitid = unit-&gt;id;
 
     iXY unit_map_loc;

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,8 +18,7 @@
 #ifndef __UNITSYNC_HPP__
 #define __UNITSYNC_HPP__
 
-#include &quot;Units/UnitBase.hpp&quot;
-
+#include &quot;Core/CoreTypes.hpp&quot;
 class ClientSocket;
 
 class UnitSync

Modified: trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,7 +20,7 @@
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
 #include &lt;algorithm&gt;
 
@@ -149,7 +149,7 @@
 {
     unsigned long id_list_index;
     unsigned long id_list_size;
-    UnitBase *unit;
+    Unit *unit;
 
     std::sort(unit_list.begin(), unit_list.end());
     unit_list.erase(std::unique(unit_list.begin(), unit_list.end()), unit_list.end());
@@ -169,7 +169,7 @@
 {
     unsigned long id_list_index;
     unsigned long id_list_size;
-    UnitBase *unit;
+    Unit *unit;
 
     id_list_size = unit_list.size();
 
@@ -183,7 +183,7 @@
 
 void SelectionList::cycleNextUnit( void )
 {
-    UnitBase *unit;
+    Unit *unit;
     unsigned long start_index;
 
     start_index = unit_cycle_index;
@@ -229,7 +229,7 @@
 
 unsigned short SelectionList::getHeadUnitType()
 {
-    UnitBase *unit;
+    Unit *unit;
 
     if ( unit_list.size() &gt; 0 ) {
         unit = UnitInterface::getUnit( unit_list[ 0 ] );
@@ -247,7 +247,7 @@
 {
     unsigned long id_list_index;
     unsigned long id_list_size;
-    UnitBase *unit;
+    Unit *unit;
 
     id_list_size = unit_list.size();
 

Modified: trunk/netpanzer/src/NetPanzer/Classes/UnitMessage.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/UnitMessage.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/UnitMessage.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,7 +18,7 @@
 #ifndef _UNITMESSAGE_HPP
 #define _UNITMESSAGE_HPP
 
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Core/CoreTypes.hpp&quot;
 
 enum { _umesg_flag_unique          = 0x01,
        _umesg_flag_broadcast       = 0x02,

Modified: trunk/netpanzer/src/NetPanzer/Classes/UnitMessageTypes.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/UnitMessageTypes.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/UnitMessageTypes.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -19,6 +19,7 @@
 #define _UNITMESSAGETYPES_HPP
 
 #include &quot;Classes/UnitMessage.hpp&quot;
+#include &quot;Types/iXY.hpp&quot;
 
 enum { _umesg_ai_command,
        _umesg_weapon_hit,

Modified: trunk/netpanzer/src/NetPanzer/Classes/WadMapTable.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WadMapTable.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/WadMapTable.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,8 +18,8 @@
 #ifndef _WADMAPTABLE_HPP
 #define _WADMAPTABLE_HPP
 
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
-#include &quot;string.h&quot;
+#include &lt;vector&gt;
+#include &lt;algorithm&gt;
 
 class WadTileMapInfo
 {
@@ -28,14 +28,17 @@
     unsigned short remap_index;
 };
 
-class WadMapTable : public ArrayTemplate&lt; WadTileMapInfo &gt;
+class WadMapTable : public std::vector&lt;WadTileMapInfo&gt;
 {
 public:
     unsigned long used_tile_count;
 
     void resetMappingTable( void )
     {
-        memset( array, 0, (sizeof( WadTileMapInfo ) * size) );
+        WadTileMapInfo t;
+        t.is_used = false;
+        t.remap_index = 0;
+        std::fill(begin(),end(),t);
     }
 
 

Modified: trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -49,7 +49,7 @@
 
 #include &quot;Interfaces/ConsoleInterface.hpp&quot;
 
-#include &quot;Units/Vehicle.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 
 WorldInputCmdProcessor COMMAND_PROCESSOR;
 
@@ -300,7 +300,7 @@
     for(UnitInterface::Units::const_iterator i = units.begin();
             i != units.end(); ++i)
     {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         if(unit-&gt;player != PlayerInterface::getLocalPlayer())
             continue;
 
@@ -697,7 +697,7 @@
                 current_selection_list_index = 0xFFFF;
                 if (working_list.unit_list.size() &gt; 0)
                 {
-                    UnitBase *unit = UnitInterface::getUnit(
+                    Unit *unit = UnitInterface::getUnit(
                             working_list.unit_list[0]);
                     if(unit)
                         unit-&gt;soundSelected();
@@ -761,7 +761,7 @@
 
     unsigned long id_list_index;
     size_t id_list_size;
-    UnitBase *unit_ptr;
+    Unit *unit_ptr;
 
     TerminalUnitCmdRequest comm_mesg;
 
@@ -802,15 +802,15 @@
 {
     TerminalUnitCmdRequest comm_mesg;
 
-    UnitBase *target_ptr;
+    Unit *target_ptr;
 
     size_t id_list_index;
     size_t id_list_size;
-    UnitBase *unit_ptr;
+    Unit *unit_ptr;
 
     if ( working_list.isSelected() == true ) {
         target_list.selectTarget( world_pos );
-        LOGGER.warning(&quot;num units in list=%d&quot;, target_list.unit_list.size());
+        LOGGER.warning(&quot;num units in list=%d&quot;, (int)target_list.unit_list.size());
 
         target_ptr = UnitInterface::getUnit( target_list.unit_list[0] );
 
@@ -849,7 +849,7 @@
     TerminalUnitCmdRequest comm_mesg;
     size_t id_list_index;
     size_t id_list_size;
-    UnitBase *unit_ptr;
+    Unit *unit_ptr;
 
     if ( working_list.unit_list.size() &gt; 0 ) {
         id_list_size = working_list.unit_list.size();
@@ -884,7 +884,7 @@
 
     size_t id_list_index;
     size_t id_list_size;
-    UnitBase *unit_ptr;
+    Unit *unit_ptr;
 
     if ( working_list.unit_list.size() &gt; 0 ) {
         id_list_size = working_list.unit_list.size();
@@ -916,7 +916,7 @@
 void
 WorldInputCmdProcessor::sendAllianceRequest(const iXY&amp; world_pos, bool make_break)
 {
-    UnitBase *target_ptr;
+    Unit *target_ptr;
 
     target_list.selectTarget(world_pos);
 
@@ -1075,10 +1075,10 @@
      * group (if that group is in a very long queue passing the map).
      */
     
-    UnitBase *maxyunit = 0;
-    UnitBase *maxxunit = 0;
-    UnitBase *minyunit = 0;
-    UnitBase *minxunit = 0;
+    Unit *maxyunit = 0;
+    Unit *maxxunit = 0;
+    Unit *minyunit = 0;
+    Unit *minxunit = 0;
 
     // Direction initialize
     int direction[8];
@@ -1088,7 +1088,7 @@
     // Vote direction
     bool firstunit = true;
     for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
-        UnitBase* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
+        Unit* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
 
         if(unit_ptr == 0)
             continue;
@@ -1126,7 +1126,7 @@
     }
         
     // Chose Best unit correspondig to chosen direction
-    UnitBase* unit = 0;
+    Unit* unit = 0;
     switch(preferred_direction) {
       case 0:
           unit = maxxunit;

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -28,7 +28,7 @@
 bool ConsoleInterface::stdout_pipe;
 
 long ConsoleInterface::console_size;
-ConsoleLineArray ConsoleInterface::line_list;
+std::vector&lt;ConsoleLine&gt; ConsoleInterface::line_list;
 
 iXY ConsoleInterface::surface_size;
 iRect    ConsoleInterface::bounds;
@@ -51,7 +51,7 @@
     assert( size &gt; 0 );
 
     console_size = size;
-    line_list.initialize( size );
+    line_list.resize( size );
 
     line_index = console_size - 1;
 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,10 +18,10 @@
 #ifndef _CONSOLEINTERFACE_HPP
 #define _CONSOLEINTERFACE_HPP
 
+#include &lt;vector&gt;
 #include &lt;stdarg.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;Core/CoreTypes.hpp&quot;
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
 #include &quot;2D/Surface.hpp&quot;
 
@@ -35,10 +35,9 @@
     FlagID  flag;
     char    string[256];
     Timer   life_timer;
+    ConsoleLine() : visible(false) {}
 };
 
-typedef ArrayTemplate&lt; ConsoleLine &gt; ConsoleLineArray;
-
 enum { _console_overlap, _console_full };
 
 class ConsoleInterface
@@ -47,7 +46,7 @@
     static bool stdout_pipe;
 
     static long console_size;
-    static ConsoleLineArray line_list;
+    static std::vector&lt;ConsoleLine&gt; line_list;
 
     static iXY surface_size;
     static iRect    bounds;

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameConfig.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameConfig.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameConfig.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -53,8 +53,6 @@
       objectiveoccupationpercentage(&quot;objectivepercentage&quot;, 75, 1, 100),
       allowallies(&quot;allowallies&quot;, true),
       cloudcoverage(&quot;cloudcoverage&quot;, 0),
-      respawntype(&quot;respawntype&quot;, _game_config_respawn_type_round_robin, 0,
-                _game_config_respawn_type_last-1),
       windspeed(&quot;windspeed&quot;, 30),
       map(&quot;map&quot;, &quot;Bad Neuburg&quot;),
       mapcycle(&quot;mapcycle&quot;, &quot;Cramped, Tight Quarters, Two Villages&quot;),
@@ -62,8 +60,10 @@
       logging(&quot;logging&quot;, false),
       publicServer(&quot;public&quot;, true),
       capturebases(&quot;capturebases&quot;, true),
+      respawntype(&quot;respawntype&quot;, _game_config_respawn_type_round_robin, 0,
+                _game_config_respawn_type_last-1),
+      respawnmode(&quot;respawnmode&quot;, 0),
       respawntime(&quot;respawntime&quot;, 0),
-      respawnmode(&quot;respawnmode&quot;, 0),
       
       screenresolution(&quot;resolution&quot;, 2, 0, 3),
       fullscreen(&quot;fullscreen&quot;, true),

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -57,7 +57,7 @@
 #include &quot;Classes/Network/NetworkClient.hpp&quot;
 #include &quot;Classes/Network/SystemNetMessage.hpp&quot;
 #include &quot;Classes/Network/ConnectNetMessage.hpp&quot;
-#include &quot;Units/Vehicle.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Units/UnitGlobals.hpp&quot;
 
 #include &quot;2D/Palette.hpp&quot;

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -79,7 +79,7 @@
 {
     char path[256];
 
-    wad_mapping_table.deallocate();
+    wad_mapping_table.clear();
 
     MapListenerList::iterator i = listenerList.begin();
     while ( i != listenerList.end() )
@@ -132,7 +132,7 @@
     tile_count = tile_set.getTileCount();
     map_size = main_map.getSize();
 
-    wad_mapping_table.initialize( tile_count );
+    wad_mapping_table.resize( tile_count );
     wad_mapping_table.resetMappingTable();
 
     // ** Find all of the used tiles **

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -17,6 +17,7 @@
 */
 #include &lt;config.h&gt;
 
+#include &lt;algorithm&gt;
 #include &lt;math.h&gt;
 
 #include &quot;Util/Log.hpp&quot;
@@ -34,7 +35,7 @@
 
     entry_replace_index = PathCache::cache_size;
 
-    cache_list.initialize( PathCache::cache_size );
+    cache_list.resize( PathCache::cache_size );
 
     for( unsigned long i = 0; i &lt; PathCache::cache_size; i++ ) {
         //cache_list[ i ].path.initialize();
@@ -345,16 +346,15 @@
 
 void PathRequestQueue::killRequest( UnitID &amp;unit_id )
 {
-    unsigned long index;
-
-    index = front;
-
-    while( index != rear ) {
-        index = (index + 1) % size;
-
-        if ( (array[ index ].unit_id == unit_id ) ) {
-            array[ index ].status = _slot_status_flush;
+    PathRequestQueue::iterator i = begin();
+    while ( i != end() )
+    {
+        if ( i-&gt;unit_id == unit_id )
+        {
+            i-&gt;status = _slot_status_flush;
+            // no break?
         }
+        ++i;
     }
 }
 
@@ -411,8 +411,8 @@
     short_pather_count = 1;
     long_pather_count  = 1;
 
-    short_request_queue.initialize( short_queue_size );
-    long_request_queue.initialize( long_queue_size );
+    //short_request_queue.resize( short_queue_size );
+    //long_request_queue.resize( long_queue_size );
 
     unsigned long i;
 
@@ -429,8 +429,8 @@
 
 void PathScheduler::cleanUp( void )
 {
-    short_request_queue.deallocate();
-    long_request_queue.deallocate();
+    short_request_queue.clear();
+    long_request_queue.clear();
 }
 
 void PathScheduler::requestPath( PathRequest &amp;path_request )
@@ -441,9 +441,9 @@
         = long ((path_request.start - path_request.goal).mag2());
 
     if ( path_distance_estimate &lt;= short_queue_distance_threshold ) {
-        short_request_queue.enqueue( path_request );
+        short_request_queue.push_back( path_request );
     } else {
-        long_request_queue.enqueue( path_request );
+        long_request_queue.push_back( path_request );
     }
 }
 
@@ -490,8 +490,9 @@
 
     for ( i = 0; i &lt; short_pather_count; i++	) {
         if( short_pather[ i ].generationStatus() == _path_generator_status_free) {
-            if ( short_request_queue.isReady() ) {
-                request = short_request_queue.dequeue();
+            if ( ! short_request_queue.empty() ) {
+                request = short_request_queue.front();
+                short_request_queue.pop_front();
 
                 if ( request.status != _slot_status_flush ) {
                     short_pather[ i ].initializePathGeneration( request );
@@ -504,8 +505,9 @@
 
     for ( i = 0; i &lt; long_pather_count; i++  ) {
         if( long_pather[ i ].generationStatus() == _path_generator_status_free) {
-            if ( long_request_queue.isReady() ) {
-                request = long_request_queue.dequeue();
+            if ( ! long_request_queue.empty() ) {
+                request = long_request_queue.front();
+                long_request_queue.pop_front();
 
                 if ( request.status != _slot_status_flush ) {
                     long_pather[ i ].initializePathGeneration( request );

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,11 +18,10 @@
 #ifndef _PATHSCHEDULER_HPP
 #define _PATHSCHEDULER_HPP
 
+#include &lt;vector&gt;
+#include &lt;deque&gt;
 #include &quot;Classes/AI/Astar.hpp&quot;
 #include &quot;Classes/AI/PathList.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
-#include &quot;ArrayUtil/QueueTemplate.hpp&quot;
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
 
 
 class PathCacheEntry
@@ -49,7 +48,7 @@
 
     unsigned long add_path_length_threshold;
 
-    ArrayTemplate&lt;PathCacheEntry&gt; cache_list;
+    std::vector&lt;PathCacheEntry&gt; cache_list;
 
     unsigned long cache_size;
     unsigned long entry_replace_index;
@@ -133,7 +132,7 @@
     void run();
 };
 
-class PathRequestQueue : public QueueTemplate&lt; PathRequest &gt;
+class PathRequestQueue : public std::deque&lt;PathRequest&gt; //QueueTemplate&lt; PathRequest &gt;
 {
 public:
     void killRequest( UnitID &amp;unit_id );

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -52,7 +52,7 @@
 #include &quot;Classes/Network/NetworkState.hpp&quot;
 #include &quot;Classes/Network/SystemNetMessage.hpp&quot;
 #include &quot;Classes/Network/ConnectNetMessage.hpp&quot;
-#include &quot;Units/Vehicle.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 #include &quot;Units/UnitGlobals.hpp&quot;
 
 #include &quot;2D/Palette.hpp&quot;

Modified: trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,6 +18,8 @@
  * Created on December 13, 2008, 6:58 PM
  */
 
+#include &lt;queue&gt;
+
 #include &quot;Resources/ResourceManager.hpp&quot;
 
 
@@ -36,7 +38,6 @@
 #include &quot;Interfaces/GameManager.hpp&quot;
 #include &quot;Objectives/ObjectiveInterface.hpp&quot;
 #include &quot;PowerUps/PowerUpInterface.hpp&quot;
-#include &quot;Classes/Network/NetPacketQueues.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 #include &quot;Classes/Network/NetworkClient.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
@@ -44,7 +45,7 @@
 class MultiMessage;
 
 static MessageClassHandler * handlers[256];
-static NetPacketQueue receive_queue;
+static std::queue&lt;NetPacket&gt; receive_queue;
 
 class NoHandler : public MessageClassHandler
 {
@@ -170,7 +171,7 @@
         handlers[_net_message_class_client_server] = NetworkClient::getPacketHandler();
     }
     // XXX has to free the queue some time;
-    receive_queue.initialize(200);
+    //receive_queue.initialize(200);
 }
 
 void
@@ -197,7 +198,7 @@
     assert(size &lt;= _MAX_NET_PACKET_SIZE);
 
     memcpy(TEMP_PACKET.data, data, size);
-    receive_queue.enqueue( TEMP_PACKET );
+    receive_queue.push( TEMP_PACKET );
 }
 
 
@@ -205,9 +206,10 @@
 MessageRouter::routePackets()
 {
     static NetPacket np;
-    while ( receive_queue.isReady() )
+    while ( ! receive_queue.empty() )
     {
-        receive_queue.dequeue(&amp;np);
+        np = receive_queue.front();
+        receive_queue.pop();
         NetworkState::incPacketsReceived(np.getSize());
 #ifdef NETWORKDEBUG
         NetPacketDebugger::logPacket(&quot;R&quot;, packet);

Modified: trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -21,7 +21,6 @@
 #include &quot;SDL.h&quot;
 
 #include &quot;Objectives/Objective.hpp&quot;
-#include &quot;ArrayUtil/ArrayTemplate.hpp&quot;
 
 #include &quot;Classes/Network/NetPacket.hpp&quot;
 #include &quot;Classes/Network/NetMessageEncoder.hpp&quot;

Modified: trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -57,7 +57,7 @@
     ObjectiveOccupationUpdate update_mesg;
     int player_status;
 
-    UnitBase* unit = UnitInterface::getUnit(unit_id);
+    Unit* unit = UnitInterface::getUnit(unit_id);
     PlayerState* player = unit-&gt;player;
     player_status = player-&gt;getStatus();
 
@@ -111,7 +111,7 @@
 {
     if( occupation_status_timer.count()  )	//
     {
-        UnitBase *unit_ptr;
+        Unit *unit_ptr;
         iRect bounding_area;
         iXY occupation_pad_loc;
 
@@ -148,7 +148,7 @@
         {
             if( (unit_generation_timer.count() == true) )
             {
-                UnitBase *unit;
+                Unit *unit;
                 iXY gen_loc;
                 gen_loc = outpost_map_loc + unit_generation_loc;
 

Modified: trunk/netpanzer/src/NetPanzer/Objectives/Outpost.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/Outpost.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Objectives/Outpost.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -20,7 +20,6 @@
 
 #include &quot;Objectives/Objective.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
-#include &quot;Units/UnitBase.hpp&quot;
 
 class Outpost : public Objective
 {

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -47,7 +47,7 @@
 
     sound-&gt;playPowerUpSound();
 
-    UnitBase* unit = UnitInterface::getUnit(unit_id);
+    Unit* unit = UnitInterface::getUnit(unit_id);
 
     MapInterface::pointXYtoMapXY( unit-&gt;unit_state.location, &amp;map_pos );
 
@@ -56,7 +56,7 @@
 
     for( int i = 0; i &lt; 9; i++ )
     {
-        UnitBase *new_unit;
+        Unit *new_unit;
         iXY spawn_loc;
 
         placement_matrix.getNextEmptyLoc( &amp;spawn_loc );

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -64,7 +64,7 @@
 {
     sound-&gt;playPowerUpSound();
 
-    UnitBase* unit = UnitInterface::getUnit(unit_id);
+    Unit* unit = UnitInterface::getUnit(unit_id);
 
     if(unit-&gt;player == PlayerInterface::getLocalPlayer())
     {

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -123,7 +123,7 @@
 {
     sound-&gt;playPowerUpSound();
 
-    UnitBase* unit = UnitInterface::getUnit( unit_id );
+    Unit* unit = UnitInterface::getUnit( unit_id );
 
     switch( unit_powerup_type )
     {

Copied: trunk/netpanzer/src/NetPanzer/Units/Unit.cpp (from rev 1092, trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp)
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -0,0 +1,2233 @@
+/*
+Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
+ 
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+ 
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+ 
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include &lt;config.h&gt;
+
+#include &lt;stdexcept&gt;
+
+#include &lt;string.h&gt;
+#include &quot;Util/Log.hpp&quot;
+#include &quot;Units/UnitBlackBoard.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
+#include &quot;Units/UnitGlobals.hpp&quot;
+#include &quot;Classes/Network/NetworkState.hpp&quot;
+#include &quot;Interfaces/PathScheduler.hpp&quot;
+#include &quot;Interfaces/MapInterface.hpp&quot;
+#include &quot;Weapons/ProjectileInterface.hpp&quot;
+#include &quot;Units/UnitInterface.hpp&quot;
+#include &quot;Units/UnitProfileInterface.hpp&quot;
+#include &quot;System/Sound.hpp&quot;
+
+
+// NOTE: Temp unit new sprites put in
+#include &quot;Interfaces/GameConfig.hpp&quot;
+
+#include &quot;Interfaces/ConsoleInterface.hpp&quot;
+#include &quot;Particles/ParticleInterface.hpp&quot;
+#include &quot;Interfaces/WorldViewInterface.hpp&quot;
+
+#define MOVEWAIT_TIME 0.8f
+
+enum{ _rotate_and_move, _rotate_stop_move };
+
+Unit::Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc)
+    : player(ownplayer), id(uid)
+{
+    smolderWait    = 0.0f;
+    smolderWaitMin = 0.0f;
+
+    if(!MapInterface::inside(initial_loc))
+        throw std::runtime_error(&quot;Invalid position&quot;);
+
+    iXY loc = MapInterface::mapXYtoPointXY(initial_loc);
+    unit_state.location = loc;
+    UnitBlackBoard::markUnitLoc( initial_loc );
+    fsm_timer.changeRate( 10 );
+    unit_state_timer.changeRate( 10 );
+    setAiFsmDefendHold();
+    pending_AI_comm = false;
+    unit_state.lifecycle_state = _UNIT_LIFECYCLE_ACTIVE;
+    memset( fsm_active_list, 0, sizeof( bool ) * 7 );
+
+    in_sync_flag = true;
+
+    body_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
+    turret_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
+
+    path_generated = false;
+    critical_ai_section = false;
+    ai_fsm_transition_complete = false;
+    
+    reload_counter = 0;
+    death_counter = 0;
+
+    ai_command_state = 0;
+    external_ai_event = _external_event_null;
+
+    fsmBodyRotate_rotation = 0;
+    fsmBodyRotate_goal_angle = 0;
+    fsmTurretRotate_rotation = 0;
+    fsmTurretRotate_goal_angle = 0;
+    
+    interpolation_speed = 0;
+    fsmMove_first_stamp = false;
+    fsmMove_offset_x = fsmMove_offset_y = 0;
+    fsmMove_moves_counter = 0;
+    fsmMove_moves_per_square = 0;
+
+    move_opcode_sent = false;
+    fsmMoveMapSquare_movement_type = 0;
+
+    aiFsmDefendHold_state = 0;
+
+    // from unit profiles
+    setUnitProperties(utype);
+    iXY zero;
+    zero.zero();
+    body_anim.setAttrib( zero, zero, unitLayer );
+    turret_anim.setAttrib( zero, zero, unitLayer );
+    body_anim_shadow.setAttrib( zero, zero, unitLayer);
+    turret_anim_shadow.setAttrib( zero, zero, unitLayer);
+    
+    select_info_box.setBoxState( false );
+    select_info_box.setFlag( player-&gt;getFlag() );
+    select_info_box.setName( player-&gt;getName() );
+    
+    body_anim_shadow.attachSprite( &amp;body_anim, zero );
+    body_anim_shadow.attachSprite( &amp;turret_anim_shadow, zero );
+    body_anim_shadow.attachSprite( &amp;turret_anim, zero );
+    body_anim_shadow.attachSprite( &amp;select_info_box, zero );
+    
+    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+}
+
+void Unit::setUnitProperties( unsigned char utype )
+{
+    UnitProfile *profile;
+    
+    profile = UnitProfileInterface::getUnitProfile( utype );
+    
+    unit_state.hit_points = profile-&gt;hit_points;
+    unit_state.max_hit_points = profile-&gt;hit_points;
+    unit_state.damage_factor = profile-&gt;attack_factor;
+    unit_state.defend_range = profile-&gt;defend_range;
+    unit_state.speed_factor = profile-&gt;speed_factor;
+    unit_state.speed_rate = profile-&gt;speed_rate;
+    unit_state.reload_time = profile-&gt;reload_time;
+    unit_state.weapon_range = profile-&gt;attack_range;
+    unit_state.unit_type = utype;
+    select_info_box.setHitBarAttributes( profile-&gt;hit_points, Color::yellow );
+    body_anim.setData( profile-&gt;bodySprite );
+    body_anim_shadow.setData( profile-&gt;bodyShadow );
+    turret_anim.setData( profile-&gt;turretSprite );
+    turret_anim_shadow.setData( profile-&gt;turretShadow );
+    soundSelect = profile-&gt;soundSelected;
+    fireSound = profile-&gt;fireSound;
+    if ( profile-&gt;weaponType == &quot;QUADMISSILE&quot; )
+    {
+        weaponType = Weapon::_quad_missile;
+    }
+    else if ( profile-&gt;weaponType == &quot;BULLET&quot; )
+    {
+        weaponType = Weapon::_bullet;
+    }
+    else if ( profile-&gt;weaponType == &quot;SHELL&quot; )
+    {
+        weaponType = Weapon::_shell;
+    }
+    else if ( profile-&gt;weaponType == &quot;DOUBLEMISSILE&quot; )
+    {
+        weaponType = Weapon::_double_missile;
+    }
+    else
+    {
+        weaponType = Weapon::_bullet;
+    }
+    int bsize = profile-&gt;boundBox / 2;
+    select_info_box.setBoxAttributes( BoundBox( -bsize, -bsize, bsize, bsize), Color::blue);
+}
+
+
+void Unit::updateUnitStateProperties()
+{
+    if ( reload_counter &lt; unit_state.reload_time )
+        reload_counter++;
+
+    if ( (unit_state.lifecycle_state == _UNIT_LIFECYCLE_PENDING_DESTRUCT) &amp;&amp;
+            (ai_command_state == _ai_command_idle)
+       )
+    {
+        unit_state.lifecycle_state = _UNIT_LIFECYCLE_DESTROYED;
+        death_counter = 0;
+    }
+
+    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+    {
+        if ( death_counter == 5 )
+        {
+            unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
+
+            DestructUnitOpcode destruct_opcode;
+            destruct_opcode.setUnitID(id);
+            UnitInterface::sendOpcode(&amp;destruct_opcode);
+        }
+        else
+        {
+            death_counter++;
+        }
+    }
+}
+
+void Unit::orientationToOffset( unsigned short orientation, signed char *offset_x, signed char *offset_y )
+{
+    switch ( orientation )
+    {
+        case 0:
+            *offset_x =  1; *offset_y =  0;
+            break;
+        case 1:
+            *offset_x =  1; *offset_y = -1;
+            break;
+        case 2:
+            *offset_x =  0; *offset_y = -1;
+            break;
+        case 3:
+            *offset_x = -1; *offset_y = -1;
+            break;
+        case 4:
+            *offset_x = -1; *offset_y =  0;
+            break;
+        case 5:
+            *offset_x = -1; *offset_y =  1;
+            break;
+        case 6:
+            *offset_x =  0; *offset_y =  1;
+            break;
+        case 7:
+            *offset_x =  1; *offset_y =  1;
+            break;
+    }
+
+}
+
+unsigned short Unit::mapXYtoOrientation( unsigned long square, long *goal_angle )
+{
+    iXY current_loc, next_loc;
+
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
+    MapInterface::offsetToMapXY( square, &amp;next_loc );
+    
+    // so many magic numbers
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y == current_loc.y) )
+    {
+        *goal_angle = 0;
+        return( 0 );
+    }
+
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
+        *goal_angle = 5;
+        return( 1 );
+    }
+
+    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
+        *goal_angle = 9;
+        return( 2 );
+    }
+
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
+        *goal_angle = 14;
+        return( 3 );
+    }
+
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y  == current_loc.y) )
+    {
+        *goal_angle = 18;
+        return( 4 );
+    }
+
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
+        *goal_angle = 23;
+        return( 5 );
+    }
+
+    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
+        *goal_angle = 27;
+        return( 6 );
+    }
+
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
+        *goal_angle = 32;
+        return( 7 );
+    }
+
+    return( 0xFFFF );
+
+
+}
+
+unsigned short Unit::shortestRotation( AngleInt &amp;angle, long goal_angle, long *delta )
+{
+    long delta_plus, delta_minus;
+
+    if( goal_angle &gt; angle.angle_int )
+        delta_plus  = ( goal_angle ) - (angle.angle_int) ;
+    else
+        delta_plus  = (angle.angle_limit + goal_angle) - angle.angle_int;
+
+    if ( goal_angle &gt; angle.angle_int )
+        delta_minus = angle.angle_limit - (goal_angle  -  angle.angle_int) ;
+    else
+        delta_minus = (angle.angle_int ) - ( goal_angle );
+
+    if (delta_minus &gt; delta_plus)
+    {
+        *delta = delta_plus;
+        return( _rotate_pos );
+    }
+    else
+    {
+        *delta = delta_minus;
+        return( _rotate_neg );
+    }
+}
+
+void Unit::locationOffset( unsigned long square, iXY &amp;offset )
+{
+    iXY square_map_loc;
+    iXY unit_map_loc;
+
+    MapInterface::offsetToMapXY( square, &amp;square_map_loc );
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;unit_map_loc );
+
+    offset = unit_map_loc - square_map_loc ;
+}
+
+void Unit::setFsmBodyRotate( long goal_angle, unsigned short rotation )
+{
+    fsmBodyRotate_rotation = rotation;
+    fsmBodyRotate_goal_angle = goal_angle;
+}
+
+bool Unit::fsmBodyRotate()
+{
+    if( unit_state.body_angle.angle_int != fsmBodyRotate_goal_angle )
+    {
+        if ( fsmBodyRotate_rotation == _rotate_pos )
+        {
+            ++unit_state.body_angle;
+        }
+        else
+        {
+            --unit_state.body_angle;
+        }  // ** else turn_rotation **
+    }
+    else
+    {
+        return( true );   // goal direction achieved
+    }
+
+    return( false );
+}
+
+void Unit::setFsmTurretRotate( long goal_angle, unsigned short rotation )
+{
+    fsmTurretRotate_rotation = rotation;
+    fsmTurretRotate_goal_angle = goal_angle;
+}
+
+bool Unit::fsmTurretRotate()
+{
+    if( unit_state.turret_angle.angle_int != fsmTurretRotate_goal_angle )
+    {
+        if ( fsmTurretRotate_rotation == _rotate_pos )
+        {
+            ++unit_state.turret_angle;
+        }
+        else
+        {
+            --unit_state.turret_angle;
+        }  // ** else turn_rotation **
+    }
+    else
+    {
+        return( true );   // goal direction achieved
+    }
+
+    return( false );
+}
+
+void Unit::setFsmMove( unsigned short orientation )
+{
+    fsm_timer.changeRate( unit_state.speed_rate );
+    orientationToOffset( orientation, &amp;fsmMove_offset_x, &amp;fsmMove_offset_y );
+    fsmMove_moves_counter = 0;
+    fsmMove_moves_per_square = 32 / unit_state.speed_factor;
+    /*
+    fsmMove_moves_per_square = 32;
+    interpolation_speed = unit_state.speed_rate * unit_state.speed_factor;
+    if ( NetworkState::status == _network_state_client )
+     { interpolation_speed += 2; } 
+    fsmMove_first_stamp = true;
+    */
+}
+
+bool Unit::fsmMove()
+{
+    /*
+    long move_offset;
+
+    if( fsmMove_first_stamp == true )
+       {
+        start_move_stamp = now();
+        fsmMove_first_stamp = false;
+       }
+
+    end_move_stamp = now();
+
+    move_offset = (end_move_stamp - start_move_stamp) * interpolation_speed;  
+
+    if( (move_offset + fsmMove_moves_counter) &gt; fsmMove_moves_per_square )
+     {
+      move_offset = fsmMove_moves_per_square - fsmMove_moves_counter;
+     }
+    */
+
+    if ( fsmMove_moves_counter &lt; fsmMove_moves_per_square )
+    {
+        /*
+        fsmMove_moves_counter += move_offset;
+
+        unit_state.location.x = unit_state.location.x + ( move_offset * fsmMove_offset_x );
+
+        unit_state.location.y = unit_state.location.y + ( move_offset * fsmMove_offset_y );
+        */
+
+        fsmMove_moves_counter++;
+
+        unit_state.location.x = unit_state.location.x + ( unit_state.speed_factor * fsmMove_offset_x );
+
+        unit_state.location.y = unit_state.location.y + ( unit_state.speed_factor * fsmMove_offset_y );
+
+        ParticleInterface::addMoveDirtPuff(unit_state);
+        //start_move_stamp = now();
+    }
+
+    if( fsmMove_moves_counter &gt;= fsmMove_moves_per_square)
+    {
+        //fsmMove_first_stamp = true;
+        fsm_timer.changeRate( 10 );
+        return( true );
+    }
+
+    return( false );
+}
+
+void Unit::setFsmMoveMapSquare( unsigned long square )
+{
+    long goal_angle = 0;
+    long delta;
+    unsigned short rotation;
+
+    unit_state.orientation = mapXYtoOrientation( square, &amp;goal_angle );
+    rotation = shortestRotation( unit_state.body_angle, goal_angle, &amp;delta );
+
+    setFsmBodyRotate( goal_angle, rotation );
+    setFsmMove( unit_state.orientation );
+
+    if ( delta &lt;= 9 )
+        fsmMoveMapSquare_movement_type = _rotate_and_move;
+    else
+        fsmMoveMapSquare_movement_type = _rotate_stop_move;
+
+    fsm_active_list[ _control_move_map_square ] = true;
+    critical_ai_section = true;
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        iXY loc_offset;
+
+        move_opcode.opcode = _UNIT_OPCODE_MOVE;
+        move_opcode.setUnitID(id);
+        move_opcode.setSquare(square);
+        locationOffset( square, loc_offset );
+        move_opcode.loc_x_offset = (signed char) loc_offset.x;
+        move_opcode.loc_y_offset = (signed char) loc_offset.y;
+        if ( move_opcode_sent == true )
+        {
+            UnitInterface::sendOpcode(&amp;move_opcode);
+        }
+    }
+
+}
+
+
+
+
+bool Unit::fsmMoveMapSquare()
+{
+    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
+    {
+        if ( opcode_move_timer.count() )
+        {
+            UnitInterface::sendOpcode(&amp;move_opcode);
+            move_opcode_sent = true;
+        }
+    }
+
+    switch( fsmMoveMapSquare_movement_type )
+    {
+        case  _rotate_stop_move :
+        {
+            if ( fsmBodyRotate() )
+            {
+                if ( fsmMove() )
+                {
+                    fsm_active_list[ _control_move_map_square ] = false;
+                    critical_ai_section = false;
+
+                    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
+                    {
+                        UnitInterface::sendOpcode(&amp;move_opcode);
+                        move_opcode_sent = true;
+                    }
+                    
+                    return( true );
+                }
+            }
+        }
+        break;
+
+        case _rotate_and_move :
+        {
+            fsmBodyRotate();
+            if ( fsmMove() )
+            {
+                fsm_active_list[ _control_move_map_square ] = false;
+                critical_ai_section = false;
+
+                if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
+                {
+                    UnitInterface::sendOpcode(&amp;move_opcode);
+                    move_opcode_sent = true;
+                }
+
+                return( true );
+            }
+        }
+        break;
+    } // ** switch
+
+    return( false );
+}
+
+
+void Unit::setFsmTurretTrackPoint(const iXY&amp; target)
+{
+    iXY direction_vector;
+
+    fsmTurretTrackPoint_target = target;
+    direction_vector = fsmTurretTrackPoint_target - unit_state.location;
+    fsmTurretTrackPoint_target_angle.set( direction_vector );
+
+    fsmTurretTrackPoint_on_target = false;
+
+    fsm_active_list[ _control_turret_track_point ] = true;
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        TurretTrackPointOpcode track_point_opcode;
+        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
+        track_point_opcode.setUnitID(id);
+        track_point_opcode.setTarget(target);
+        track_point_opcode.activate = true;
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
+    }
+
+}
+
+void Unit::clearFsmTurretTrackPoint()
+{
+    fsm_active_list[ _control_turret_track_point ] = false;
+
+    fsmTurretTrackPoint_on_target = false;
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        TurretTrackPointOpcode track_point_opcode;
+        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
+        track_point_opcode.setUnitID(id);
+        track_point_opcode.activate = false;
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
+    }
+}
+
+void Unit::syncFsmTurretTrackPoint()
+{
+    if ( fsm_active_list[ _control_turret_track_point ] == true )
+    {
+        TurretTrackPointOpcode track_point_opcode;
+        track_point_opcode.flags = _unit_opcode_flag_sync;
+        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
+        track_point_opcode.setUnitID(id);
+        track_point_opcode.setTarget(fsmTurretTrackPoint_target);
+        track_point_opcode.activate = true;
+
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
+    }
+}
+
+void Unit::fsmTurretTrackPoint()
+{
+    long goal_angle;
+    long delta;
+    unsigned short rotation;
+    iXY direction_vector;
+
+    direction_vector = fsmTurretTrackPoint_target - unit_state.location;
+    fsmTurretTrackPoint_target_angle.set( direction_vector );
+
+    goal_angle = fsmTurretTrackPoint_target_angle.DegreesInt( 10 );
+    rotation = shortestRotation( unit_state.turret_angle, goal_angle, &amp;delta );
+    setFsmTurretRotate( goal_angle, rotation );
+
+    if (  fsmTurretRotate() == true )
+        fsmTurretTrackPoint_on_target = true;
+    else
+        fsmTurretTrackPoint_on_target = false;
+
+}
+
+void Unit::setFsmTurretTrackTarget(UnitID target_id)
+{
+    fsmTurretTrackTarget_target_id = target_id;
+    fsm_active_list[ _control_turret_track_target ] = true;
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        TurretTrackTargetOpcode track_target_opcode;
+        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
+        track_target_opcode.setUnitID(id);
+        track_target_opcode.setTargetUnitID(target_id);
+        track_target_opcode.activate = true;
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
+    }
+
+}
+
+void Unit::clearFsmTurretTrackTarget()
+{
+    fsm_active_list[ _control_turret_track_target ] = false;
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        TurretTrackTargetOpcode track_target_opcode;
+        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
+        track_target_opcode.setUnitID(id);
+        track_target_opcode.activate = false;
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
+    }
+
+}
+
+void Unit::syncFsmTurretTrackTarget()
+{
+    if ( fsm_active_list[ _control_turret_track_target ] == true )
+    {
+        TurretTrackTargetOpcode track_target_opcode;
+        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
+        track_target_opcode.flags = _unit_opcode_flag_sync;
+        track_target_opcode.setUnitID(id);
+        track_target_opcode.setTargetUnitID(fsmTurretTrackTarget_target_id);
+        track_target_opcode.activate = true;
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
+    }
+
+}
+
+
+void Unit::fsmTurretTrackTarget()
+{
+    long goal_angle;
+    long delta;
+    unsigned short rotation;
+    Unit *target_unit_ptr;
+    iXY direction_vector;
+
+    target_unit_ptr = UnitInterface::getUnit( fsmTurretTrackTarget_target_id );
+
+    if ( target_unit_ptr != 0 )
+    {
+        direction_vector = target_unit_ptr-&gt;unit_state.location - unit_state.location;
+        Angle float_angle( direction_vector );
+
+        goal_angle = float_angle.DegreesInt( 10 );
+        rotation = shortestRotation( unit_state.turret_angle, goal_angle, &amp;delta );
+        setFsmTurretRotate( goal_angle, rotation );
+    }
+
+    if ( fsmTurretRotate() == true )
+    {
+        fsmTurretTrackTarget_on_target = true;
+    }
+    else
+    {
+        fsmTurretTrackTarget_on_target = false;
+    }
+}
+
+
+
+void Unit::setFsmGunneryLocation(const iXY&amp; target )
+{
+    if ( fsm_active_list[ _control_gunnery_target ] == true )
+    {
+        clearFsmGunneryTarget();
+    }
+
+    fsmGunneryLocation_target = target;
+    setFsmTurretTrackPoint( target );
+    fsm_active_list[ _control_gunnery_location ] = true;
+}
+
+void Unit::clearFsmGunneryLocation()
+{
+    fsm_active_list[ _control_gunnery_location ] = false;
+    clearFsmTurretTrackPoint();
+}
+
+void Unit::fsmGunneryLocation()
+{
+    iXY range_vector;
+
+    range_vector = fsmGunneryLocation_target - unit_state.location;
+
+    if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
+            (fsmTurretTrackPoint_on_target == true) &amp;&amp;
+            (reload_counter &gt;= unit_state.reload_time)
+       )
+    {
+        fireWeapon( fsmGunneryLocation_target );
+        clearFsmGunneryLocation();
+    }
+
+}
+
+void Unit::setFsmGunneryTarget(UnitID target_id)
+{
+    if ( fsm_active_list[ _control_gunnery_location ] == true )
+    {
+        clearFsmGunneryLocation();
+    }
+
+    if ( fsm_active_list[ _control_turret_track_point ] == true )
+    {
+        clearFsmTurretTrackPoint();
+    }
+
+    fsmGunneryTarget_target_id = target_id;
+    setFsmTurretTrackTarget( target_id );
+    fsm_active_list[ _control_gunnery_target ] = true;
+}
+
+void Unit::clearFsmGunneryTarget()
+{
+    fsm_active_list[ _control_gunnery_target ] = false;
+    clearFsmTurretTrackTarget();
+}
+
+void Unit::fsmGunneryTarget()
+{
+    Unit *target_unit_ptr;
+    UnitState *target_unit_state;
+    iXY range_vector;
+
+    target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
+    if ( target_unit_ptr == 0 )
+    {
+        clearFsmGunneryTarget();
+    }
+    else
+    {
+        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+
+        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+        {
+            clearFsmGunneryTarget();
+        }
+        else
+        {
+            range_vector = target_unit_state-&gt;location - unit_state.location;
+
+            if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
+                    (fsmTurretTrackTarget_on_target == true) &amp;&amp;
+                    (reload_counter == unit_state.reload_time )
+               )
+            {
+                fireWeapon( target_unit_state-&gt;location );
+            }
+        }
+    }
+
+
+}
+
+void Unit::aiFsmIdle()
+{
+    if ( pending_AI_comm == true )
+    {
+        ai_fsm_transition_complete = true;
+    }
+
+}
+
+bool Unit::ruleMoveToLoc_GoalReached()
+{
+    iXY map_loc;
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;map_loc );
+    if ( map_loc == aiFsmMoveToLoc_goal )
+        return true;
+
+    return false;
+}
+
+
+void Unit::aiFsmMoveToLoc()
+{
+    bool end_cycle = false;
+
+    do
+    {
+        switch ( aiFsmMoveToLoc_state )
+        {
+
+            // *************************************************************
+            case _aiFsmMoveToLoc_path_generate :
+            {
+                // QueryPath: Has a path been generated for unit ?
+                path_generated = PathScheduler::queryPath(id);
+
+
+                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmMoveToLoc_OnExitCleanUp();
+
+                    iXY current_map_loc;
+                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
+                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( path_generated == true )
+                {
+                    // Rule QueryPath: is true move to next state
+                    //LOG( (&quot;Path Successfully Generated&quot;) );
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+                }
+                else
+                {
+                    end_cycle = true;                    
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmMoveToLoc_check_goal :
+            {
+                //  GoalReached: Has the goal been reached ?
+                if ( ruleMoveToLoc_GoalReached() == true )
+                {
+                    // Rule GoalReached : is true
+                    // Action : Exit fsm
+                    aiFsmMoveToLoc_prev_loc = unit_state.location;
+                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
+                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
+
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    setAiFsmDefendHold();
+
+                    end_cycle = true;
+                }
+                else
+                {
+                    if ( aiFsmMoveToLoc_path_not_finished == false )
+                    {
+                        //  Rule: GoalReached is false AND Unit is at the end of path
+                        //  Action : Request path generation to goal
+                        iXY start;
+                        PathRequest path_request;
+
+                        //LOG( (&quot;Incomplete Path -- Regenerating Path&quot;) );
+                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
+                        path_request.set(id, start, aiFsmMoveToLoc_goal, 0,  &amp;path, _path_request_full );
+                        PathScheduler::requestPath( path_request );
+                        aiFsmMoveToLoc_path_not_finished = true;
+                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
+                    }
+                    else
+                    {
+                        // Rule GoalReached: is false
+                        // Action: Get next move;
+                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
+                    }
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmMoveToLoc_next_move :
+            {
+                // CurrentPathComplete: is Unit at the end of the current path
+                aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
+                MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
+
+                if ( !aiFsmMoveToLoc_path_not_finished )
+                {
+                    // Rule: CurrentPathComplete is true
+                    // Action : check if unit is at the goal
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+                }
+                else
+                {
+                    // Rule: CurrentPathComplete is false
+                    // Action: Check if next location is empty
+                    aiFsmMoveToLoc_prev_loc = unit_state.location;
+                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
+                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
+
+                    //aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+                    aiFsmMoveToLoc_wait_timer.reset();
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmMoveToLoc_wait_clear_loc :
+            {
+
+                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                } // NextSquareOccupied: does the next square contain a abstruction
+                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
+                {
+                    // Rule: NextSquareOccupied is true
+                    // Action: Check Wait Timer
+
+                    if ( aiFsmMoveToLoc_wait_timer.count() )
+                    {
+                        // Rule: NextSquareOccupied is true AND WaitTimer is finished
+                        // Action: Preform path update
+                        if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
+                        {
+
+                            UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
+                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
+
+                            PathRequest path_request;
+                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
+                            PathScheduler::requestPath( path_request );
+                            aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+                        }
+                        else
+                        {
+//                            LOGGER.warning(&quot;Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
+//                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
+//                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
+                            PathRequest path_request;
+                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
+                            PathScheduler::requestPath( path_request );
+                            // XXX the more times timeout the longer will take next time
+                            aiFsmMoveToLoc_wait_timer.changePeriod( aiFsmMoveToLoc_wait_timer.getPeriod() * 2.0f );
+                        }
+
+                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
+                    }
+                    // can't move and has to wait, finish the loop.
+                    end_cycle = true;
+                }
+                else
+                {
+                    // Rule: NextSquareOccupied is false
+                    // Action: Begin move to next square
+                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
+                    setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
+
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
+                    aiFsmMoveToLoc_wait_timer.changePeriod( 0.8f );
+                }
+
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmMoveToLoc_move_wait :
+            {
+                // MoveFinished : has the low level fsm finshed
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
+                    // Rule: MoveFinished is true
+                    // Action: Check for a pending transition
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
+                    end_cycle = true;
+                }
+                else
+                {
+                    end_cycle = true;
+                } // ** else
+
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmMoveToLoc_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+                }
+
+            }
+            break;
+            
+        } // ** switch
+        
+    } while (end_cycle == false);
+}
+
+void Unit::aiFsmMoveToLoc_OnExitCleanUp()
+{
+    PathScheduler::killRequest(id);
+    clearFsmTurretTrackPoint();
+}
+
+void Unit::aiFsmAttackUnit()
+{
+    bool end_cycle = false;
+
+    UnitState *target_unit_state = 0;
+    iXY range_vector;
+
+    Unit* target_unit_ptr
+        = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
+    if ( target_unit_ptr == 0 )
+    {
+        aiFsmAttackUnit_target_destroyed = true;
+        if(aiFsmAttackUnit_state != _aiFsmAttackUnit_move_wait)
+        {
+            setAiFsmDefendHold();
+            aiFsmAttackUnit_OnExitCleanUp();
+            return;
+        }
+    }
+    else
+    {
+        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+
+        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+        {
+            aiFsmAttackUnit_target_destroyed = true;
+
+            if ( aiFsmAttackUnit_state !=  _aiFsmAttackUnit_move_wait )
+            {
+                setAiFsmDefendHold();
+                aiFsmAttackUnit_OnExitCleanUp();
+                return;
+            }
+        }
+    }
+
+    do
+    {
+        switch ( aiFsmAttackUnit_state )
+        {
+            // *************************************************************
+
+            case _aiFsmAttackUnit_path_generate :
+            {
+                // QueryPath: Has a path been generated for unit ?
+                path_generated = PathScheduler::queryPath(id);
+
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmAttackUnit_OnExitCleanUp();
+
+                    iXY current_map_loc;
+                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
+                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( path_generated == true )
+                {
+                    // Rule QueryPath: is true move to next state
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
+                }
+                else
+                {
+                    end_cycle = true;
+                }
+
+            }
+            break;
+            // *************************************************************
+
+            case _aiFsmAttackUnit_range_check :
+            {
+                // RangeVector: the absolute distance between unit and target
+                range_vector = target_unit_state-&gt;location - unit_state.location;
+
+                if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                {
+                    // Rule: RangeVector &lt; WeaponRange, unit is in range
+                    // Action: Remain in position
+                    aiFsmAttackUnit_prev_loc = unit_state.location;
+                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
+                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
+                    end_cycle = true;
+                }
+                else
+                {
+                    if ( aiFsmAttackUnit_path_not_finished == false )
+                    {
+                        iXY start;
+                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
+
+                        PathRequest path_request;
+                        path_request.set(id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+                        PathScheduler::requestPath( path_request );
+
+                        aiFsmAttackUnit_path_not_finished = true;
+                        aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
+                    }
+                    else
+                    {
+                        // Rule: RangeVector &gt; WeaponRange
+                        // Action: Get next move
+                        aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
+                    }
+                }
+            }
+            break;
+            // *************************************************************
+
+            case _aiFsmAttackUnit_idle :
+            {
+                range_vector = target_unit_state-&gt;location - unit_state.location;
+
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                {
+                    // Rule: RangeVector &lt; WeaponRange, unit is in range
+                    // Action: Remain in position
+                    end_cycle = true;
+                }
+                else
+                {
+                    // Rule: RangeVector &gt; WeaponRange
+                    // Action: Get next move
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmAttackUnit_next_move :
+            {
+                // CurrentPathComplete: is Unit at the end of the current path
+                aiFsmAttackUnit_path_not_finished = path.popFirst( &amp;aiFsmAttackUnit_next_square );
+                MapInterface::offsetToMapXY( aiFsmAttackUnit_next_square, &amp;aiFsmAttackUnit_next_loc );
+
+                if ( !aiFsmAttackUnit_path_not_finished )
+                {
+                    // Rule: CurrentPathComplete is true
+                    // Action : check if unit is at the goal
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
+                }
+                else
+                {
+                    // Rule: CurrentPathComplete is false
+                    // Action: Check if next location is empty
+                    aiFsmAttackUnit_prev_loc = unit_state.location;
+                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
+                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    aiFsmAttackUnit_wait_timer.changePeriod( 0.8f );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_wait_clear_loc;
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmAttackUnit_wait_clear_loc :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
+                {
+                    if ( aiFsmAttackUnit_wait_timer.count() )
+                    {
+                        if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
+                        {
+                            UnitInterface::unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
+                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
+
+                            PathRequest path_request;
+                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+                            PathScheduler::requestPath( path_request );
+
+                        }
+                        else
+                        {
+                            PathRequest path_request;
+                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_update );
+                            PathScheduler::requestPath( path_request );
+                        }
+
+                        aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
+                    }
+
+                    end_cycle = true;
+                }
+                else
+                {
+                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_next_loc );
+                    setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmAttackUnit_move_wait :
+            {
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
+                }
+                end_cycle = true;
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmAttackUnit_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_next_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if (  aiFsmAttackUnit_target_destroyed == true )
+                {
+                    setAiFsmDefendHold();
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
+                }
+            }
+            break;
+            // *************************************************************
+
+            case _aiFsmAttackUnit_check_path_deviation :
+            {
+                iXY deviation_vector;
+                iXY goal_point_loc;
+
+                MapInterface::mapXYtoPointXY( aiFsmAttackUnit_target_goal_loc, &amp;goal_point_loc );
+                deviation_vector = target_unit_state-&gt;location - goal_point_loc;
+
+                if ( deviation_vector.mag2() &gt; unit_state.weapon_range )
+                {
+                    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
+
+                    PathRequest path_request;
+                    path_request.set( id, aiFsmAttackUnit_next_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+                    PathScheduler::requestPath( path_request );
+
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
+                }
+
+            }
+            break;
+
+        } // ** switch
+
+    } while ( end_cycle == false );
+
+}
+
+void Unit::aiFsmAttackUnit_OnExitCleanUp()
+{
+    PathScheduler::killRequest( id );
+    clearFsmGunneryTarget();
+}
+
+void Unit::setAiFsmDefendHold()
+{
+    ai_command_state = _ai_command_defend_hold;
+    aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
+    aiFsmDefendHold_search_timer.changePeriod( .5 );
+}
+
+void Unit::aiFsmDefendHold()
+{
+    bool end_cycle = false;
+
+    Unit  *target_unit_ptr;
+    UnitState *target_unit_state;
+
+    iXY range_vector;
+
+    do
+    {
+        switch ( aiFsmDefendHold_state )
+        {
+            case _aiFsmDefendHold_search_for_enemy :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else if ( aiFsmDefendHold_search_timer.count() )
+                {
+                    if (UnitInterface::queryClosestEnemyUnit(
+                                &amp;target_unit_ptr, unit_state.location,
+                                player-&gt;getID() ) )
+                    {
+                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+                        range_vector = target_unit_state-&gt;location - unit_state.location;
+                        if ( range_vector.mag2() &lt;= unit_state.defend_range )
+                        {
+                            aiFsmDefendHold_target_ID = target_unit_ptr-&gt;id;
+                            setFsmGunneryTarget( aiFsmDefendHold_target_ID );
+                            aiFsmDefendHold_state = _aiFsmDefendHold_attack_enemy;
+                            end_cycle = true;
+                        }
+                        else
+                        {
+                            end_cycle = true;
+                        }
+                    } // **  quearyClosestEnemyUnit
+                    else
+                    {
+                        end_cycle = true;
+                    }
+
+                } // ** aiFsmDefendHold_search_timer.count()
+                else
+                {
+                    end_cycle = true;
+                }
+            }
+            break;
+
+            case _aiFsmDefendHold_attack_enemy :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    clearFsmGunneryTarget();
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    clearFsmGunneryTarget();
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else
+                {
+                    target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
+                    if ( target_unit_ptr == 0 )
+                    {
+                        clearFsmGunneryTarget();
+                        aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
+                        end_cycle = true;
+                    }
+                    else
+                    {
+                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+                        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+                        {
+                            clearFsmGunneryTarget();
+                            aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
+                            end_cycle = true;
+                        } // ** if
+                        else
+                        {
+                            range_vector = target_unit_state-&gt;location - unit_state.location;
+                            if ( range_vector.mag2() &gt; unit_state.defend_range )
+                            {
+                                clearFsmGunneryTarget();
+                                aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
+                                end_cycle = true;
+                            }
+                        } 
+                    }
+                }
+                end_cycle = true;
+            }
+            break;
+        } // ** switch
+
+    } while ( end_cycle == false );
+
+}
+
+
+
+
+
+void Unit::aiFsmManualMove()
+{
+    bool end_cycle = false;
+    signed char offset_x = 0, offset_y = 0;
+    size_t next_square;
+
+    do
+    {
+        switch( aiFsmManualMove_state )
+        {
+            case _aiFsmManualMove_next_move :
+            {
+                aiFsmManualMove_prev_loc = aiFsmManualMove_next_loc;
+                orientationToOffset( aiFsmManualMove_move_orientation, &amp;offset_x, &amp;offset_y );
+                aiFsmManualMove_next_loc.x += offset_x;
+                aiFsmManualMove_next_loc.y += offset_y;
+                next_square = MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
+
+                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF )
+                {
+                    setAiFsmDefendHold();
+                    end_cycle = true;
+                }
+                else if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
+                {
+                    setAiFsmDefendHold();
+                    end_cycle = true;
+                }
+                else
+                {
+                    UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
+                    setFsmMoveMapSquare( next_square );
+                    aiFsmManualMove_state = _aiFsmManualMove_move_wait;
+                }
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmManualMove_move_wait :
+            {
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_prev_loc );
+                    aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
+                    end_cycle = true;
+                }
+                else
+                {
+                    end_cycle = true;
+                } // ** else
+            }
+            break;
+
+            // *************************************************************
+
+            case _aiFsmManualMove_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
+                    // External Event: This unit is about to be deleted
+                    // Action : Exit fsm gracefully
+                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_next_loc );
+                    external_ai_event = _external_event_null;
+                    ai_command_state = _ai_command_idle;
+                    end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmManualMove_state = _aiFsmManualMove_next_move;
+                }
+            }
+            break;
+
+        } // ** switch
+    } while ( end_cycle == false );
+
+}
+
+void Unit::fireWeapon( iXY &amp;target_loc )
+{
+    reload_counter = 0;
+
+    unsigned short projectile_type = launchProjectile();
+    ProjectileInterface::newProjectile(projectile_type, unit_state.unit_type, id,
+                                       unit_state.damage_factor,
+                                       unit_state.location,
+                                       target_loc
+                                      );
+
+    if ( NetworkState::status == _network_state_server ) {
+        FireWeaponOpcode fire_opcode;
+        fire_opcode.opcode = _UNIT_OPCODE_FIRE_WEAPON;
+        fire_opcode.setUnitID(id);
+        fire_opcode.setTarget(target_loc);
+        UnitInterface::sendOpcode(&amp;fire_opcode);
+    }
+}
+
+//-----------------------------------------------------------------
+void Unit::soundSelected()
+{
+        sound-&gt;playSound( soundSelect.size()?soundSelect.c_str():&quot;yessir&quot;);
+}
+
+void Unit::accessThreatLevels()
+{
+    if ( unit_state.threat_level == _threat_level_under_attack )
+    {
+        if( threat_level_under_attack_timer.count() )
+        {
+            unit_state.threat_level = _threat_level_all_clear;
+        }
+    }
+
+}
+
+//-----------------------------------------------------------------
+unsigned short Unit::launchProjectile()
+{
+    long distance = WorldViewInterface::getCameraDistance(unit_state.location);
+    sound-&gt;playAmbientSound(fireSound.c_str(), distance );
+    sound-&gt;playBattle();
+    
+    return weaponType;
+}
+
+//-----------------------------------------------------------------
+void Unit::updateFsmState()
+{
+    if ( fsm_timer.count() ) {
+        if ( fsm_active_list[ _control_move_map_square ] == true )
+            fsmMoveMapSquare();
+
+        if ( fsm_active_list[ _control_turret_track_point ] == true )
+            fsmTurretTrackPoint();
+
+        if ( fsm_active_list[ _control_turret_track_target ] == true )
+            fsmTurretTrackTarget();
+
+        if ( fsm_active_list[ _control_gunnery_location ] == true )
+            fsmGunneryLocation();
+
+        if ( fsm_active_list[ _control_gunnery_target ] == true )
+            fsmGunneryTarget();
+    }
+}
+
+
+void Unit::updateAIState()
+{
+    switch(ai_command_state)
+    {
+        case _ai_command_idle:
+            aiFsmIdle();
+            break;
+
+        case _ai_command_defend_hold:
+            aiFsmDefendHold();
+            break;
+
+        case _ai_command_move_to_loc:
+            aiFsmMoveToLoc();
+            break;
+
+        case _ai_command_attack_unit:
+            aiFsmAttackUnit();
+            break;
+
+        case _ai_command_manual_move:
+            aiFsmManualMove();
+            break;
+    }
+}
+
+
+void Unit::checkPendingAICommStatus()
+{
+    if ( (pending_AI_comm == true) &amp;&amp;
+            (ai_fsm_transition_complete == true) )
+    {
+        pending_AI_comm = false;
+        ai_fsm_transition_complete = false;
+
+        if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
+        {
+            switch( pending_AI_comm_mesg.command )
+            {
+                case _command_move_to_loc :
+                    setCommandMoveToLoc( &amp;pending_AI_comm_mesg );
+                    break;
+
+                case _command_attack_unit :
+                    setCommandAttackUnit( &amp;pending_AI_comm_mesg );
+                    break;
+
+                case _command_start_manual_move :
+                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
+                    break;
+
+                case _command_stop_manual_move :
+                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
+                    break;
+            } // ** switch
+
+        } // ** unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE
+
+    } // ** if
+
+}
+
+void Unit::setCommandMoveToLoc(const UMesgAICommand* message)
+{
+    iXY start;
+
+    if ( fsm_active_list[ _control_gunnery_location ] == true )
+    {
+        clearFsmGunneryLocation();
+    }
+
+    aiFsmMoveToLoc_goal = message-&gt;getGoalLoc();
+    ai_command_state = _ai_command_move_to_loc;
+    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
+    aiFsmMoveToLoc_path_not_finished = true;
+    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+
+    opcode_move_timer.changePeriod( 0.10f );
+    move_opcode_sent = false;
+    //move_opcode_sent = true;
+
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
+
+    //LOG( (&quot;UnitID %d, %d : Start %d, %d : Goal %d, %d&quot;, id.getPlayer(), id.getIndex(),
+    //                                                    start.x, start.y,
+    //                                                    aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
+
+    PathRequest path_request;
+    path_request.set( id, start, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
+    PathScheduler::requestPath( path_request );
+
+    iXY target;
+    MapInterface::mapXYtoPointXY( aiFsmMoveToLoc_goal, &amp;target);
+    setFsmTurretTrackPoint( target );
+}
+
+void Unit::setCommandAttackUnit(const UMesgAICommand* message)
+{
+    iXY start;
+    Unit *target_unit_ptr;
+    UnitState *target_unit_state;
+
+    aiFsmAttackUnit_target_ID = message-&gt;getTargetUnitID();
+
+    target_unit_ptr = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
+    if ( target_unit_ptr == 0 )
+        return;
+
+    target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+
+    ai_command_state = _ai_command_attack_unit;
+
+    aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
+    aiFsmAttackUnit_path_not_finished = true;
+    aiFsmAttackUnit_target_destroyed = false;
+
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
+    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
+
+    PathRequest path_request;
+    path_request.set( id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+    PathScheduler::requestPath( path_request );
+
+    opcode_move_timer.changePeriod( 0.10f );
+    move_opcode_sent = false;
+    //move_opcode_sent = true;
+
+    setFsmGunneryTarget( aiFsmAttackUnit_target_ID );
+}
+
+void Unit::setCommandManualMove(const UMesgAICommand* message)
+{
+    if ( message-&gt;command == _command_start_manual_move )
+    {
+        aiFsmManualMove_move_orientation = message-&gt;manual_move_orientation;
+        MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmManualMove_next_loc );
+        aiFsmManualMove_state = _aiFsmManualMove_next_move;
+        ai_command_state = _ai_command_manual_move;
+    }
+    else if ( message-&gt;command == _command_stop_manual_move )
+    {
+        ai_command_state = _ai_command_idle;
+    }
+}
+
+void Unit::setCommandManualFire(const UMesgAICommand* message)
+{
+    setFsmGunneryLocation(message-&gt;getTargetLoc());
+}
+
+void Unit::messageAICommand(const UnitMessage* message)
+{
+    const UMesgAICommand *command_mesg = (const UMesgAICommand *) message;
+
+    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
+    {
+        if (command_mesg-&gt;command == _command_manual_fire)
+        {
+            setCommandManualFire( command_mesg );
+        }
+        else
+        {
+            memcpy(&amp;pending_AI_comm_mesg, command_mesg, sizeof(UMesgAICommand));
+            pending_AI_comm = true;
+        }
+    }
+}
+
+
+void Unit::messageWeaponHit(const UnitMessage *message)
+{
+    const UMesgWeaponHit *weapon_hit = (const UMesgWeaponHit *) message;
+
+    if (!unit_state.bounds(weapon_hit-&gt;getHitLocation()))
+        return;
+    
+    unit_state.hit_points -= weapon_hit-&gt;getDamageFactor();
+    unit_state.threat_level = _threat_level_under_attack;
+    threat_level_under_attack_timer.changePeriod(
+            gameconfig-&gt;attacknotificationtime);
+
+    UpdateStateUnitOpcode update_state_opcode;
+
+    update_state_opcode.setUnitID(id);
+    update_state_opcode.setHitPoints(unit_state.hit_points);
+    UnitInterface::sendOpcode( &amp;update_state_opcode );
+
+    if ( unit_state.hit_points &lt;= 0 )
+    {
+        unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
+        external_ai_event = _external_event_pending_unit_destruct;
+
+        UMesgEndLifeCycleUpdate lifecycle_update;
+        lifecycle_update.set(id, weapon_hit-&gt;getOwnerUnitID(),
+                unit_state.unit_type);
+        UnitInterface::sendMessage(&amp;lifecycle_update);
+
+        // ** Note: Temp
+        iXY current_map_loc;
+        MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
+        UnitBlackBoard::unmarkUnitLoc(current_map_loc);
+    }
+}
+
+void Unit::messageSelectBoxUpdate(const UnitMessage* message)
+{
+    const UMesgUpdateSelectBoxInfo *select_box_update 
+        = (const UMesgUpdateSelectBoxInfo *) message;
+
+    switch (select_box_update-&gt;request_type)
+    {
+        case _select_box_allie_visibility:
+        {
+            select_info_box.setAllieIcon(select_box_update-&gt;allie_flag_visiblity );
+            break;
+        }
+        break;
+
+        case _select_box_flag_visiblity:
+        {
+            select_info_box.setFlagIcon( select_box_update-&gt;flag_visiblity );
+            break;
+        }
+
+        case _select_box_is_allied:
+        {
+            select_info_box.setAllieState( select_box_update-&gt;allied_state );
+            break;
+        }
+    }
+}
+
+void Unit::messageSelfDestruct(const UnitMessage* )
+{
+    unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
+    external_ai_event = _external_event_pending_unit_destruct;
+
+    // ** Note: Temp
+    iXY current_map_loc;
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
+    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+}
+
+void Unit::processMessage(const UnitMessage* message)
+{
+    if (unit_state.lifecycle_state != _UNIT_LIFECYCLE_ACTIVE)
+        return;
+    
+    switch(message-&gt;message_id)
+    {
+        case _umesg_ai_command:
+            messageAICommand(message);
+            break;
+
+        case _umesg_weapon_hit:
+            messageWeaponHit(message);
+            break;
+
+        case _umesg_update_select_box_info:
+            messageSelectBoxUpdate(message);
+            break;
+
+        case _umesg_self_destruct:
+            messageSelfDestruct(message);
+            break;
+
+        default:
+            LOGGER.warning(&quot;Unknown unit message (id %d)&quot;,
+                    message-&gt;message_id);
+            break;
+    }
+}
+
+void Unit::unitOpcodeMove(const UnitOpcode* opcode)
+{
+    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
+            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
+       )
+        return;
+
+    const MoveOpcode* move_opcode = (const MoveOpcode *) opcode;
+
+    iXY sync_loc;
+    iXY current_loc;
+
+    MapInterface::offsetToMapXY(move_opcode-&gt;getSquare(), &amp;sync_loc );
+    sync_loc.x = sync_loc.x + move_opcode-&gt;loc_x_offset;
+    sync_loc.y = sync_loc.y + move_opcode-&gt;loc_y_offset;
+
+    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
+
+    if ( current_loc != sync_loc )
+    {
+        MapInterface::mapXYtoPointXY( sync_loc, &amp;(unit_state.location) );
+    }
+
+    setFsmMoveMapSquare(move_opcode-&gt;getSquare());
+}
+
+void Unit::unitOpcodeTrackPoint(const UnitOpcode* opcode )
+{
+    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
+            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
+       )
+        return;
+
+    const TurretTrackPointOpcode* track_point_opcode 
+        = (const TurretTrackPointOpcode *) opcode;
+
+    if ( track_point_opcode-&gt;activate == true )
+    {
+        iXY target = track_point_opcode-&gt;getTarget();
+        setFsmTurretTrackPoint( target );
+    }
+    else
+    {
+        fsm_active_list[ _control_turret_track_point ] = false;
+    }
+
+}
+
+void Unit::unitOpcodeTrackTarget(const UnitOpcode* opcode )
+{
+    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
+            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
+       )
+        return;
+
+    const TurretTrackTargetOpcode* track_target_opcode 
+        = (const TurretTrackTargetOpcode *) opcode;
+
+    if ( track_target_opcode-&gt;activate == true )
+    {
+        setFsmTurretTrackTarget( track_target_opcode-&gt;getTargetUnitID() );
+    }
+    else
+    {
+        fsm_active_list[ _control_turret_track_target ] = false;
+    }
+
+}
+
+void Unit::unitOpcodeFireWeapon(const UnitOpcode* opcode )
+{
+    iXY target_loc;
+
+    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
+            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
+       )
+        return;
+
+    const FireWeaponOpcode *fire_weapon = (const FireWeaponOpcode *) opcode;
+    target_loc = fire_weapon-&gt;getTarget();
+    fireWeapon( target_loc );
+}
+
+void Unit::unitOpcodeSync(const UnitOpcode* )
+{
+    in_sync_flag = true;
+}
+
+void Unit::unitOpcodeUpdateState(const UnitOpcode* opcode )
+{
+    const UpdateStateUnitOpcode *update_state_opcode
+        = (const UpdateStateUnitOpcode *) opcode;
+
+    unit_state.hit_points = update_state_opcode-&gt;getHitPoints();
+
+    unit_state.threat_level = _threat_level_under_attack;
+    threat_level_under_attack_timer.changePeriod( 30 );
+}
+
+void Unit::unitOpcodeDestruct(const UnitOpcode* )
+{
+    unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
+}
+
+void Unit::syncUnit()
+{
+    syncFsmTurretTrackPoint();
+    syncFsmTurretTrackTarget();
+
+    SyncUnitOpcode sync_opcode;
+
+    sync_opcode.opcode = _UNIT_OPCODE_SYNC_UNIT;
+    sync_opcode.setUnitID(id);
+    UnitInterface::sendOpcode( &amp;sync_opcode );
+}
+
+
+void Unit::processMoveOpcodeQueue()
+{
+    if (!move_opcode_queue.empty())
+    {
+        if( fsm_active_list[ _control_move_map_square ] == false )
+        {
+            if ( move_opcode_queue.size() &gt;= 3 )
+            {
+                for( int i = 0; i &lt; 2; i++ )
+                {
+                    move_opcode_queue.pop();
+                }
+                //ConsoleInterface::postMessage( &quot;Move Opcode Queue Adjusted&quot; );
+            }
+            UnitOpcodeStruct opcodedata = move_opcode_queue.front();
+            move_opcode_queue.pop();
+            const UnitOpcode* opcode = (UnitOpcode*) &opcodedata; 
+            unitOpcodeMove(opcode);
+        }
+    }
+
+}
+
+void Unit::processOpcodeQueue()
+{
+    processMoveOpcodeQueue();
+
+    if (!opcode_queue.empty())
+    {
+        UnitOpcodeStruct opcodedata = opcode_queue.front();
+        const UnitOpcode* opcode = (UnitOpcode*) &opcodedata;
+
+        switch(opcode-&gt;opcode )
+        {
+            case _UNIT_OPCODE_TURRET_TRACK_POINT:
+                unitOpcodeTrackPoint(opcode);
+                break;
+
+            case _UNIT_OPCODE_TURRET_TRACK_TARGET:
+                unitOpcodeTrackTarget(opcode);
+                break;
+
+            case _UNIT_OPCODE_FIRE_WEAPON:
+                unitOpcodeFireWeapon(opcode);
+                break;
+
+            case _UNIT_OPCODE_SYNC_UNIT:
+                unitOpcodeSync(opcode);
+                break;
+
+            case _UNIT_OPCODE_UPDATE_STATE:
+                unitOpcodeUpdateState(opcode);
+                break;
+
+            case _UNIT_OPCODE_DESTRUCT:
+                unitOpcodeDestruct(opcode);
+                break;
+
+            default:
+                LOGGER.warning(&quot;Unknown Opcode: %d.\n&quot;, opcode-&gt;opcode);
+                assert(false);
+                break;
+        }
+        opcode_queue.pop();
+    }
+}
+
+void Unit::evalCommandOpcode(const UnitOpcode* opcode)
+{
+    if (opcode-&gt;opcode == _UNIT_OPCODE_MOVE)
+    {
+        move_opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
+    }
+    else
+    {
+        opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
+    }
+}
+
+void Unit::updateState()
+{
+    updateFsmState();
+
+    if ( NetworkState::status == _network_state_server )
+    {
+        if( unit_state_timer.count() )
+            updateUnitStateProperties();
+
+        updateAIState();
+        checkPendingAICommStatus();
+    }
+    else
+    {
+        processOpcodeQueue();
+    }
+
+    accessThreatLevels();
+
+    if( unit_state.hit_points &lt; unit_state.max_hit_points )
+    {
+        smolderWait += TimerInterface::getTimeSlice();
+
+        int intPercent = unit_state.percentDamageInt();
+
+        if (intPercent &gt; 50 &amp;&amp; (rand() % 100) &lt; intPercent)
+        {
+            if (smolderWait &gt; smolderWaitMin)
+            {
+                float percent = unit_state.percentDamageFloat();
+
+                smolderWaitMin  = (float(100 - percent) / 100.0) + (float(100 - percent) / 100.0) * 0.3;
+
+                ParticleInterface::addUnitDamagePuffParticle(unit_state);
+
+                smolderWait = 0.0f;
+            }
+        }
+    }
+}
+
+
+void Unit::offloadGraphics( SpriteSorter &amp;sorter )
+{
+    body_anim_shadow.setWorldPos( unit_state.location);
+
+    if ( sorter.cullSprite( body_anim_shadow ) == false )
+    {
+        // Body
+        body_anim.setWorldPos( unit_state.location );
+        body_anim.setFrame( unit_state.body_angle.angle_int );
+
+        // Turret
+        turret_anim.setWorldPos( unit_state.location );
+        turret_anim.setFrame( unit_state.turret_angle.angle_int );
+
+        // Body Shadow
+        body_anim_shadow.setFrame( unit_state.body_angle.angle_int );
+
+        // Turret Shadow
+        turret_anim_shadow.setWorldPos( unit_state.location );
+        turret_anim_shadow.setFrame( unit_state.turret_angle.angle_int );
+
+        select_info_box.setBoxState( unit_state.select );
+
+        //Added layer selection to the selection box info.
+        select_info_box.setAttrib( unit_state.location,
+                gameconfig-&gt;unitinfodrawlayer );
+        select_info_box.setHitPoints( unit_state.hit_points );
+
+        sorter.forceAddSprite( &amp;body_anim_shadow );
+    }
+
+    //sorter.addSprite( &amp;body_anim_shadow );
+}

Added: trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -0,0 +1,286 @@
+/*
+Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
+ 
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+ 
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+ 
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef _VEHICLE_HPP
+#define _VEHICLE_HPP
+#include &lt;string&gt;
+
+#include &quot;UnitState.hpp&quot;
+#include &quot;Util/Timer.hpp&quot;
+#include &quot;Classes/UnitMessageTypes.hpp&quot;
+#include &quot;Units/UnitOpcodes.hpp&quot;
+#include &quot;Classes/AI/PathList.hpp&quot;
+
+#include &quot;Classes/Sprite.hpp&quot;
+#include &quot;Classes/SelectionBoxSprite.hpp&quot;
+#include &quot;Classes/SpriteSorter.hpp&quot;
+
+enum { _control_idle,
+       _control_move,
+       _control_move_map_square,
+       _control_turret_track_point,
+       _control_turret_track_target,
+       _control_gunnery_location,
+       _control_gunnery_target    };
+
+enum { _ai_command_idle,
+       _ai_command_move_to_loc,
+       _ai_command_attack_unit,
+       _ai_command_manual_move,
+       _ai_command_defend_hold };
+
+enum { _aiFsmMoveToLoc_path_generate,
+       _aiFsmMoveToLoc_check_goal,
+       _aiFsmMoveToLoc_next_move,
+       _aiFsmMoveToLoc_move_wait,
+       _aiFsmMoveToLoc_wait_clear_loc,
+       _aiFsmMoveToLoc_check_fsm_transition };
+
+enum { _aiFsmAttackUnit_path_generate,
+       _aiFsmAttackUnit_range_check,
+       _aiFsmAttackUnit_idle,
+       _aiFsmAttackUnit_next_move,
+       _aiFsmAttackUnit_move_wait,
+       _aiFsmAttackUnit_wait_clear_loc,
+       _aiFsmAttackUnit_check_fsm_transition,
+       _aiFsmAttackUnit_check_path_deviation };
+
+enum { _aiFsmDefendHold_search_for_enemy,
+       _aiFsmDefendHold_attack_enemy };
+
+enum { _aiFsmManualMove_next_move,
+       _aiFsmManualMove_move_wait,
+       _aiFsmManualMove_check_fsm_transition };
+
+enum { _external_event_null,
+       _external_event_pending_unit_destruct };
+
+enum { _rotate_pos, _rotate_neg };
+
+
+class PlayerState;
+
+class Unit
+{
+    friend class UnitInterface;
+public:
+    PlayerState* player;
+    UnitID       id;
+    UnitState    unit_state;
+    bool         in_sync_flag;
+
+    void soundSelected();
+
+
+protected:
+    SpritePacked body_anim;
+    SpritePacked turret_anim;
+
+    SpritePacked body_anim_shadow;
+    SpritePacked turret_anim_shadow;
+
+    UnitSelectionBox select_info_box;
+    
+    std::string soundSelect;
+    std::string fireSound;
+    unsigned short weaponType;
+
+    Timer unit_state_timer;
+    Timer fsm_timer;
+    bool fsm_active_list[ 7 ];
+
+    PathList path;
+    bool path_generated;
+    bool critical_ai_section;
+    bool ai_fsm_transition_complete;
+
+    unsigned short reload_counter;
+    unsigned short death_counter;
+    void updateUnitStateProperties();
+
+    unsigned char ai_command_state;
+    unsigned char external_ai_event;
+
+
+    unsigned short shortestRotation( AngleInt &amp;angle, long goal_angle, long *delta );
+    unsigned short mapXYtoOrientation( unsigned long square, long *goal_angle  );
+    void orientationToOffset( unsigned short orientation, signed char *offset_x, signed char *offset_y );
+    void locationOffset( unsigned long square, iXY &amp;offset );
+
+    // ** FSMs and AI FSMs
+    unsigned short fsmBodyRotate_rotation;
+    long           fsmBodyRotate_goal_angle;
+    void    setFsmBodyRotate( long goal_angle, unsigned short rotation );
+    bool fsmBodyRotate();
+
+    unsigned short fsmTurretRotate_rotation;
+    long           fsmTurretRotate_goal_angle;
+    void    setFsmTurretRotate( long goal_angle, unsigned short rotation );
+    bool fsmTurretRotate();
+
+    float interpolation_speed;
+    TimeStamp start_move_stamp;
+    TimeStamp end_move_stamp;
+    bool     fsmMove_first_stamp;
+    signed char fsmMove_offset_x;
+    signed char fsmMove_offset_y;
+    unsigned char fsmMove_moves_counter;
+    unsigned char fsmMove_moves_per_square;
+    void setFsmMove( unsigned short orientation );
+    bool fsmMove();
+
+    MoveOpcode move_opcode;
+    Timer opcode_move_timer;
+    bool move_opcode_sent;
+    unsigned char fsmMoveMapSquare_movement_type;
+    void setFsmMoveMapSquare( unsigned long square );
+    bool fsmMoveMapSquare();
+
+    iXY fsmTurretTrackPoint_target;
+    Angle fsmTurretTrackPoint_target_angle;
+    bool fsmTurretTrackPoint_on_target;
+    void setFsmTurretTrackPoint(const iXY&amp; target );
+    void clearFsmTurretTrackPoint();
+    void syncFsmTurretTrackPoint();
+    void fsmTurretTrackPoint();
+
+    UnitID fsmTurretTrackTarget_target_id;
+    bool fsmTurretTrackTarget_on_target;
+    void setFsmTurretTrackTarget(UnitID target_id);
+    void clearFsmTurretTrackTarget();
+    void syncFsmTurretTrackTarget();
+    void fsmTurretTrackTarget();
+
+    iXY fsmGunneryLocation_target;
+    void setFsmGunneryLocation(const iXY&amp; target );
+    void clearFsmGunneryLocation();
+    void fsmGunneryLocation();
+
+    UnitID fsmGunneryTarget_target_id;
+    void setFsmGunneryTarget(UnitID target_id);
+    void clearFsmGunneryTarget();
+    void fsmGunneryTarget();
+
+    void aiFsmIdle();
+
+    unsigned char aiFsmDefendHold_state;
+    Timer	  aiFsmDefendHold_search_timer;
+    UnitID  aiFsmDefendHold_target_ID;
+    void setAiFsmDefendHold();
+    void aiFsmDefendHold();
+
+    iXY aiFsmMoveToLoc_goal;
+    unsigned char aiFsmMoveToLoc_state;
+    unsigned long aiFsmMoveToLoc_next_square;
+    iXY aiFsmMoveToLoc_next_loc;
+    iXY aiFsmMoveToLoc_prev_loc;
+    Timer	   aiFsmMoveToLoc_wait_timer;
+    bool  aiFsmMoveToLoc_path_not_finished;
+    bool ruleMoveToLoc_GoalReached();
+    void aiFsmMoveToLoc_OnExitCleanUp();
+    void aiFsmMoveToLoc();
+
+    UnitID   aiFsmAttackUnit_target_ID;
+    iXY aiFsmAttackUnit_target_goal_loc;
+    unsigned char aiFsmAttackUnit_state;
+    unsigned long aiFsmAttackUnit_next_square;
+    iXY aiFsmAttackUnit_next_loc;
+    iXY aiFsmAttackUnit_prev_loc;
+    Timer	   aiFsmAttackUnit_wait_timer;
+    bool  aiFsmAttackUnit_path_not_finished;
+    bool  aiFsmAttackUnit_target_destroyed;
+    void aiFsmAttackUnit_OnExitCleanUp();
+    void aiFsmAttackUnit();
+
+
+    unsigned char aiFsmManualMove_move_orientation;
+    unsigned char aiFsmManualMove_state;
+    iXY aiFsmManualMove_next_loc;
+    iXY aiFsmManualMove_prev_loc;
+    void aiFsmManualMove();
+
+    void fireWeapon( iXY &amp;target_loc );
+    unsigned short launchProjectile();
+
+    TimerFrameBase threat_level_under_attack_timer;
+    void accessThreatLevels();
+
+    void updateFsmState();
+    void updateAIState();
+
+    // ** Opcode Functions
+    void unitOpcodeMove(const UnitOpcode* opcode );
+    void unitOpcodeTrackPoint(const UnitOpcode* opcode );
+    void unitOpcodeTrackTarget(const UnitOpcode* opcode );
+    void unitOpcodeFireWeapon(const UnitOpcode* opcode );
+    void unitOpcodeSync(const UnitOpcode* opcode );
+    void unitOpcodeUpdateState(const UnitOpcode* opcode );
+    void unitOpcodeDestruct(const UnitOpcode* opcode );
+
+    UnitOpcodeQueue opcode_queue;
+    UnitOpcodeQueue move_opcode_queue;
+    void processMoveOpcodeQueue();
+    void processOpcodeQueue();
+
+    // ** Message Handlers
+    UMesgAICommand pending_AI_comm_mesg;
+    bool	     pending_AI_comm;
+    void checkPendingAICommStatus();
+
+    void setCommandMoveToLoc(const UMesgAICommand* message);
+    void setCommandAttackUnit(const UMesgAICommand* message);
+    void setCommandManualMove(const UMesgAICommand* message);
+    void setCommandManualFire(const UMesgAICommand* message);
+
+    void messageAICommand(const UnitMessage* message);
+    void messageWeaponHit(const UnitMessage* message);
+    void messageSelectBoxUpdate(const UnitMessage* message);
+    void messageSelfDestruct(const UnitMessage* message);
+    
+    void setUnitProperties( unsigned char utype );
+
+public:
+    Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc);
+
+    void updateState();
+
+    void processMessage(const UnitMessage* message);
+
+    void evalCommandOpcode(const UnitOpcode* opcode);
+
+    void syncUnit();
+
+    void offloadGraphics( SpriteSorter &amp;sorter );
+
+    float smolderWait;
+    float smolderWaitMin;
+
+private:
+    void setID(UnitID id)
+    {
+        this-&gt;id = id;
+    }
+
+    UnitID getID() const
+    {
+        return id;
+    }
+
+};
+
+
+#endif // ** _VEHICLE_HPP

Deleted: trunk/netpanzer/src/NetPanzer/Units/UnitBase.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBase.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBase.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,66 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _UNITBASE_HPP
-#define _UNITBASE_HPP
-
-#include &quot;Core/CoreTypes.hpp&quot;
-#include &quot;Units/UnitState.hpp&quot;
-
-class UnitMessage;
-class UnitOpcode;
-class SpriteSorter;
-class PlayerState;
-
-class UnitBase
-{
-public:
-    PlayerState* player;
-    UnitID       id;
-    UnitState    unit_state;
-    bool         in_sync_flag;
-
-    UnitBase(PlayerState* newPlayer, UnitID newId)
-        : player(newPlayer), id(newId)
-    { }
-    virtual ~UnitBase()
-    { }
-
-    virtual void processMessage(const UnitMessage* ) = 0;
-    virtual void evalCommandOpcode(const UnitOpcode* ) = 0;
-    virtual void updateState() = 0;
-    virtual void syncUnit() = 0;
-    virtual void offloadGraphics(SpriteSorter&amp; ) = 0;
-    virtual void soundSelected() = 0;
-
-private:
-    friend class UnitInterface;
-    void setID(UnitID id)
-    {
-        this-&gt;id = id;
-    }
-
-    UnitID getID() const
-    {
-        return id;
-    }
-
-protected:
-    UnitBase *groupLinkNext;
-};
-
-#endif // ** _UNITBASE_HPP

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -24,7 +24,7 @@
 class UnitBlackBoard
 {
 protected:
-    friend class Vehicle;
+    friend class Unit;
     friend class UnitInterface; // for unmark unit hack
     
     static BitArray unit_loc_map;

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -17,11 +17,15 @@
 */
 #include &lt;config.h&gt;
 
+#include &quot;Util/Log.hpp&quot;
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+
 #include &quot;2D/Palette.hpp&quot;
 #include &quot;Units/UnitBucketArray.hpp&quot;
 
 UnitBucketArray::UnitBucketArray( )
-        : UnitBucketArrayTemplate( )
+//        : UnitBucketArrayTemplate( )
 {
     map_x_sample_factor = 0;
     map_y_sample_factor = 0;
@@ -41,6 +45,8 @@
 UnitBucketArray::initialize( iXY map_size, iXY tile_size,
         long x_super_sample, long y_super_sample )
 {
+    cleanUp();
+
     unsigned long rows, columns;
 
     assert( x_super_sample &gt;= 1 );
@@ -68,27 +74,39 @@
     rows = (unsigned long) map_size.y / map_y_sample_factor;
     columns = (unsigned long) map_size.x / map_x_sample_factor;
 
-    UnitBucketArrayTemplate::initialize( rows, columns );
+    row_size = rows;
+    column_size = columns;
+    size = rows*columns;
+    buckets.resize(size);
+    //UnitBucketArrayTemplate::initialize( rows, columns );
 }
 
+void
+UnitBucketArray::cleanUp()
+{
+    buckets.clear();
+}
+
 iRect
-UnitBucketArray::worldRectToBucketRectClip( iRect &amp;world_rect )
+UnitBucketArray::getWorldRectBucketUnits( iRect &amp;world_rect )
 {
-    long bucket_max_x;
-    long bucket_max_y;
+    long bucket_min_x = world_rect.min.x / pixel_x_sample_factor;
+    long bucket_min_y = world_rect.min.y / pixel_y_sample_factor;
+    long bucket_max_x = world_rect.max.x / pixel_x_sample_factor;
+    long bucket_max_y = world_rect.max.y / pixel_y_sample_factor;
 
-    bucket_max_x = world_rect.max.x / pixel_x_sample_factor;
-    if ( bucket_max_x &gt;= (long) column_size ) {
+    if ( bucket_max_x &gt;= (long) column_size )
+    {
         bucket_max_x = column_size - 1;
     }
 
-    bucket_max_y = world_rect.max.y / pixel_y_sample_factor;
-    if ( bucket_max_y &gt;= (long) row_size ) {
+    if ( bucket_max_y &gt;= (long) row_size )
+    {
         bucket_max_y = row_size  - 1;
     }
 
-    return( iRect( world_rect.min.x / pixel_x_sample_factor,
-                   world_rect.min.y / pixel_y_sample_factor,
+    return( iRect( bucket_min_x,
+                   bucket_min_y,
                    bucket_max_x,
                    bucket_max_y
                  )
@@ -105,7 +123,7 @@
 
     assert( bucket_index &lt; (long) size );
 
-    return( &amp;(array[ bucket_index ]) );
+    return( &amp;(buckets[ bucket_index ]) );
 }
 
 UnitBucketList*
@@ -118,13 +136,12 @@
 
     assert( bucket_index &lt; (long) size );
 
-    return( &amp;(array[ bucket_index ]) );
+    return( &amp;(buckets[ bucket_index ]) );
 }
 
 void
-UnitBucketArray::addUnit( UnitBase *unit )
+UnitBucketArray::addUnit( Unit *unit )
 {
-    UnitBucketPointer *unit_bucket_ptr;
     long bucket_index;
 
     bucket_index = ((unit-&gt;unit_state.location.y / pixel_y_sample_factor) * column_size) +
@@ -132,64 +149,55 @@
 
     assert( bucket_index &lt; (long) size );
 
-    unit_bucket_ptr = new UnitBucketPointer(unit);
-
-    array[ bucket_index ].addFront( unit_bucket_ptr );
+    buckets[ bucket_index ].push_front( unit );
 }
 
-void
-UnitBucketArray::addUnit( UnitBucketPointer *unit_bucket_ptr )
+struct
+FindUnit
 {
-    long bucket_index;
-    UnitBase *unit;
+    UnitID toFind;
+    FindUnit(UnitID u) : toFind(u) {}
+    bool operator()(Unit* ub)
+    {
+        return ub-&gt;id == toFind;
+    }
+};
 
-    unit = unit_bucket_ptr-&gt;unit;
-
-    bucket_index = ((unit-&gt;unit_state.location.y / pixel_y_sample_factor) * column_size) +
-                   (unit-&gt;unit_state.location.x / pixel_x_sample_factor);
-
-    assert( bucket_index &lt; (long) size );
-
-    array[ bucket_index ].addFront( unit_bucket_ptr );
-}
-
-
 long
 UnitBucketArray::getUnitBucketIndex(UnitID unit_id)
 {
-    for( unsigned long bucket_index = 0; bucket_index &lt; size; bucket_index++ ) {
-        UnitBucketPointer *traversal_ptr;
+    UnitBucketList::iterator iter;
+    for( unsigned long bucket_index = 0; bucket_index &lt; size; bucket_index++ )
+    {
+        iter = std::find_if( buckets[bucket_index].begin(),
+                             buckets[bucket_index].end(), FindUnit(unit_id));
 
-        traversal_ptr = array[ bucket_index ].getFront();
-
-        while( traversal_ptr != 0 ) {
-            if( traversal_ptr-&gt;unit-&gt;id == unit_id )
-                return (long) bucket_index;
-
-            traversal_ptr = traversal_ptr-&gt;next;
+        if ( iter != buckets[bucket_index].end() )
+        {
+            return (long) bucket_index;
         }
-
     }
 
     return -1;
 }
 
-UnitBase*
+Unit*
 UnitBucketArray::getUnit(UnitID unit_id, unsigned long bucket_index)
 {
-    UnitBucketPointer *traversal_ptr = array[bucket_index].getFront();
+    UnitBucketList::iterator iter;
 
-    while( traversal_ptr != 0 ) {
-        if(traversal_ptr-&gt;unit-&gt;id == unit_id)
-            return traversal_ptr-&gt;unit;
+    iter = std::find_if( buckets[bucket_index].begin(),
+                         buckets[bucket_index].end(), FindUnit(unit_id));
 
-        traversal_ptr = traversal_ptr-&gt;next;
+    if ( iter != buckets[bucket_index].end() )
+    {
+        return *iter;
     }
 
     return 0;
 }
 
-UnitBase* UnitBucketArray::getUnitAtWorldLoc(UnitID unit_id, iXY world_loc)
+Unit* UnitBucketArray::getUnitAtWorldLoc(UnitID unit_id, iXY world_loc)
 {
     long bucket_index;
 
@@ -198,21 +206,19 @@
 
     assert( bucket_index &lt; (long) size );
 
-    UnitBucketPointer *traversal_ptr;
+    UnitBucketList::iterator iter;
+    iter = std::find_if( buckets[bucket_index].begin(),
+                         buckets[bucket_index].end(), FindUnit(unit_id));
 
-    traversal_ptr = array[ bucket_index ].getFront();
-
-    while( traversal_ptr != 0 ) {
-        if(traversal_ptr-&gt;unit-&gt;id == unit_id)
-            return traversal_ptr-&gt;unit;
-
-        traversal_ptr = traversal_ptr-&gt;next;
+    if ( iter != buckets[bucket_index].end() )
+    {
+        return *iter;
     }
 
     return 0;
 }
 
-UnitBase*
+Unit*
 UnitBucketArray::getUnitAtMapLoc(UnitID unit_id, iXY map_loc)
 {
     long bucket_index;
@@ -221,16 +227,13 @@
                    (map_loc.x / map_x_sample_factor);
 
     assert( bucket_index &lt; (long) size );
+    UnitBucketList::iterator iter;
+    iter = std::find_if( buckets[bucket_index].begin(),
+                         buckets[bucket_index].end(), FindUnit(unit_id));
 
-    UnitBucketPointer *traversal_ptr;
-
-    traversal_ptr = array[ bucket_index ].getFront();
-
-    while( traversal_ptr != 0 ) {
-        if(traversal_ptr-&gt;unit-&gt;id == unit_id)
-            return traversal_ptr-&gt;unit;
-
-        traversal_ptr = traversal_ptr-&gt;next;
+    if ( iter != buckets[bucket_index].end() )
+    {
+        return *iter;
     }
 
     return 0;
@@ -242,55 +245,37 @@
 {
     assert(from_bucket_index &lt; size);
     assert(to_bucket_index &lt; size);
-    
-    bool found = false;
-    UnitBucketPointer *traversal_ptr;
-    UnitBucketPointer *move_ptr;
 
-    traversal_ptr = array[ from_bucket_index ].getFront();
+    UnitBucketList::iterator iter = std::find_if( buckets[from_bucket_index].begin(),
+                                                  buckets[from_bucket_index].end(),
+                                                  FindUnit(unit_id));
 
-    while( (traversal_ptr != 0) &amp;&amp; (found == false) ) {
-        if(traversal_ptr-&gt;unit-&gt;id == unit_id) {
-            move_ptr = traversal_ptr;
-            traversal_ptr = traversal_ptr-&gt;next;
-            array[ from_bucket_index ].removeObject( move_ptr );
-            array[ to_bucket_index ].addFront( move_ptr );
-            found = true;
-        } else {
-            traversal_ptr = traversal_ptr-&gt;next;
-        }
+    if ( iter != buckets[from_bucket_index].end() )
+    {
+        buckets[ to_bucket_index ].push_front( *iter );
+        buckets[ from_bucket_index ].erase( iter );
     }
-
-    if ( found == false ) {
+    else
+    {
         long from_bucket_index = getUnitBucketIndex( unit_id );
-        if(from_bucket_index != -1) {
+        if(from_bucket_index != -1)
+        {
             return( moveUnit( unit_id, from_bucket_index, to_bucket_index ) );
-        } else
+        }
+        else
+        {
             return false;
+        }
     }
 
     return true;
 }
 
-bool
-UnitBucketArray::deleteUnitBucketPointer(UnitID unit_id, iXY world_loc)
+void
+UnitBucketArray::removeUnit( Unit *unit )
 {
     long bucket_index;
 
-    bucket_index = worldLocToBucketIndex( world_loc );
-
-    UnitBucketPointer *traversal_ptr;
-
-    traversal_ptr = array[ bucket_index ].getFront();
-
-    while( traversal_ptr != 0 ) {
-        if(traversal_ptr-&gt;unit-&gt;id == unit_id) {
-            array[ bucket_index ].deleteObject( traversal_ptr );
-            return true;
-        }
-
-        traversal_ptr = traversal_ptr-&gt;next;
-    }
-
-    return false;
+    bucket_index = worldLocToBucketIndex( unit-&gt;unit_state.location );
+    buckets[bucket_index].remove(unit);
 }

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,39 +18,16 @@
 #ifndef _UNIT_BUCKET_ARRAY_HPP
 #define _UNIT_BUCKET_ARRAY_HPP
 
-#include &quot;ArrayUtil/BucketArrayTemplate.hpp&quot;
+#include &lt;vector&gt;
+#include &lt;list&gt;
+#include &quot;Units/Unit.hpp&quot;
 
-#include &quot;Units/UnitBase.hpp&quot;
+typedef std::list&lt;Unit *&gt; UnitBucketList;
 
-class UnitBucketPointer
+class UnitBucketArray // : public UnitBucketArrayTemplate
 {
-public:
-    UnitBase *unit;
-
-    UnitBucketPointer()
-    {
-        unit = 0;
-        next = 0;
-        prev = 0;
-    }
-
-    UnitBucketPointer(UnitBase *unit)
-    {
-        UnitBucketPointer::unit = unit;
-        next = 0;
-        prev = 0;
-    }
-
-    UnitBucketPointer *next;
-    UnitBucketPointer *prev;
-};
-
-typedef BucketArrayTemplate&lt; UnitBucketPointer &gt; UnitBucketArrayTemplate;
-typedef LinkListDoubleTemplate&lt; UnitBucketPointer &gt; UnitBucketList;
-
-class UnitBucketArray : public UnitBucketArrayTemplate
-{
 protected:
+    std::vector&lt;UnitBucketList&gt; buckets;
     long map_x_sample_factor;
     long map_y_sample_factor;
     long pixel_x_sample_factor;
@@ -59,14 +36,38 @@
     long map_size_x;
     long map_size_y;
     iXY tile_size;
+    size_t size;
+    size_t row_size;
+    size_t column_size;
 
+
 public:
 
     UnitBucketArray( );
     ~UnitBucketArray( );
 
+    size_t getSize() const
+    {
+        return size;
+    }
+
+    UnitBucketList * getBucket(size_t bucket_index)
+    {
+        assert( bucket_index &lt; size );
+        return( &amp;(buckets[ bucket_index ]) );
+    }
+
+    UnitBucketList * getBucket( size_t row, size_t column )
+    {
+        size_t bucket_index = (row * column_size) + column;
+
+        assert( bucket_index &lt; size );
+        return( &amp;(buckets[ bucket_index ]) );
+    }
+
     void initialize( iXY map_size, iXY tile_size);
     void initialize( iXY map_size, iXY tile_size, long x_super_sample, long y_super_sample );
+    void cleanUp();
 
     inline long getXSample( void )
     {
@@ -122,9 +123,8 @@
               );
     }
 
-    iRect worldRectToBucketRectClip( iRect &amp;world_rect );
+    iRect getWorldRectBucketUnits( iRect &amp;world_rect );
 
-
     inline iRect mapRectToBucketRect( iRect &amp;map_rect )
     {
         return( iRect( map_rect.min.x / map_x_sample_factor,
@@ -137,18 +137,17 @@
     UnitBucketList * getBucketAssocWorldLoc( iXY world_loc );
     UnitBucketList * getBucketAssocMapLoc( iXY map_loc );
 
-    void addUnit( UnitBase *unit );
-    void addUnit( UnitBucketPointer *unit_bucket_ptr );
+    void addUnit( Unit *unit );
+    void removeUnit( Unit *unit );
 
     long getUnitBucketIndex( UnitID unit_id );
 
-    UnitBase * getUnit( UnitID unit_id, unsigned long bucket_index );
-    UnitBase * getUnitAtWorldLoc( UnitID unit_id, iXY world_loc );
-    UnitBase * getUnitAtMapLoc( UnitID unit_id, iXY map_loc );
+    Unit * getUnit( UnitID unit_id, unsigned long bucket_index );
+    Unit * getUnitAtWorldLoc( UnitID unit_id, iXY world_loc );
+    Unit * getUnitAtMapLoc( UnitID unit_id, iXY map_loc );
 
     bool moveUnit( UnitID unit_id, unsigned long from_bucket_index, unsigned long to_bucket_index );
 
-    bool deleteUnitBucketPointer( UnitID unit_id, iXY world_loc );
 };
 
 #endif // ** _UNIT_BUCKET_ARRAY_HPP

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -26,7 +26,7 @@
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
 
-#include &quot;Units/Vehicle.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 
 #include &quot;Types/iXY.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
@@ -45,6 +45,7 @@
 #include &quot;Particles/ParticleInterface.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
 #include &quot;UnitBlackBoard.hpp&quot;
+#include &quot;Interfaces/GameConfig.hpp&quot;
 
 
 //UnitList * UnitInterface::unit_lists;
@@ -94,7 +95,8 @@
 
 void UnitInterface::cleanUp()
 {
-    // XXX why doesn't clean the unit_bucket_array?
+    unit_bucket_array.cleanUp();
+
     delete[] playerUnitLists;
     playerUnitLists = 0;
 
@@ -140,7 +142,7 @@
 UnitInterface::sendMessage(const UnitMessage* message,const PlayerState* player)
 {
     if (message-&gt;isFlagged(_umesg_flag_unique)) {
-        UnitBase* unit = getUnit(message-&gt;getUnitID());
+        Unit* unit = getUnit(message-&gt;getUnitID());
         if(unit == 0)
             return;
         if(player &amp;&amp; unit-&gt;player != player) {
@@ -161,7 +163,7 @@
         }
             
         for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-            UnitBase* unit = i-&gt;second;
+            Unit* unit = i-&gt;second;
             unit-&gt;processMessage(message);
         }
     } else if (message-&gt;isFlagged( _umesg_flag_manager_request) ) {
@@ -179,7 +181,7 @@
 
 void UnitInterface::removeUnit(Units::iterator i)
 {
-    UnitBase* unit = i-&gt;second;
+    Unit* unit = i-&gt;second;
     
     // unit explosion particles
     ParticleInterface::addHit(unit-&gt;unit_state);
@@ -190,8 +192,8 @@
                 unit-&gt;unit_state.location ) );
     
     // delete the unit
-    unit_bucket_array.deleteUnitBucketPointer(unit-&gt;id, 
-            unit-&gt;unit_state.location );
+    unit_bucket_array.removeUnit(unit);
+
     PlayerUnitList&amp; plist =
         playerUnitLists[unit-&gt;player-&gt;getID()];
     
@@ -210,7 +212,7 @@
 void UnitInterface::updateUnitStatus()
 {
     for(Units::iterator i = units.begin(); i != units.end(); /*nothing*/ ) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
 	    
         if (unit-&gt;unit_state.lifecycle_state == _UNIT_LIFECYCLE_INACTIVE) {
             Units::iterator next = i;
@@ -251,19 +253,60 @@
     iRect world_window_rect;
     iRect bucket_rect;
     UnitBucketList *bucket_list;
+    UnitBucketList::iterator bucket_iter;
+    Unit * unit = 0;
 
     world_window_rect = sorter.getWorldWindow();
-    bucket_rect = unit_bucket_array.worldRectToBucketRectClip(world_window_rect);
+    bucket_rect = unit_bucket_array.getWorldRectBucketUnits(world_window_rect);
 
     for(long row_index = bucket_rect.min.y;
-            row_index &lt;= bucket_rect.max.y; row_index++ ) {
+            row_index &lt;= bucket_rect.max.y; row_index++ )
+    {
         for(long column_index = bucket_rect.min.x;
-                column_index &lt;= bucket_rect.max.x; column_index++ ) {
+                column_index &lt;= bucket_rect.max.x; column_index++ )
+        {
             bucket_list = unit_bucket_array.getBucket(row_index, column_index);
 
-            for(UnitBucketPointer* t = bucket_list-&gt;getFront();
-                    t != 0; t = t-&gt;next) {
-                t-&gt;unit-&gt;offloadGraphics(sorter);
+            for(bucket_iter = bucket_list-&gt;begin();
+                    bucket_iter != bucket_list-&gt;end(); ++bucket_iter)
+            {
+                unit = *bucket_iter;
+
+
+                unit-&gt;body_anim_shadow.setWorldPos( unit-&gt;unit_state.location);
+
+                if ( sorter.cullSprite( unit-&gt;body_anim_shadow ) == false )
+                {
+                    // Body
+                    unit-&gt;body_anim.setWorldPos( unit-&gt;unit_state.location );
+                    unit-&gt;body_anim.setFrame( unit-&gt;unit_state.body_angle.angle_int );
+
+                    // Turret
+                    unit-&gt;turret_anim.setWorldPos( unit-&gt;unit_state.location );
+                    unit-&gt;turret_anim.setFrame( unit-&gt;unit_state.turret_angle.angle_int );
+
+                    // Body Shadow
+                    unit-&gt;body_anim_shadow.setFrame( unit-&gt;unit_state.body_angle.angle_int );
+
+                    // Turret Shadow
+                    unit-&gt;turret_anim_shadow.setWorldPos( unit-&gt;unit_state.location );
+                    unit-&gt;turret_anim_shadow.setFrame( unit-&gt;unit_state.turret_angle.angle_int );
+
+                    unit-&gt;select_info_box.setBoxState( unit-&gt;unit_state.select );
+
+                    //Added layer selection to the selection box info.
+                    unit-&gt;select_info_box.setAttrib( unit-&gt;unit_state.location,
+                            gameconfig-&gt;unitinfodrawlayer );
+                    unit-&gt;select_info_box.setHitPoints( unit-&gt;unit_state.hit_points );
+
+                    sorter.forceAddSprite( &amp;(unit-&gt;body_anim_shadow) );
+                }
+
+
+
+
+
+//                (*bucket_iter)-&gt;offloadGraphics(sorter);
             }
         }
     }
@@ -282,12 +325,12 @@
 
 // ******************************************************************
 
-UnitBase * UnitInterface::newUnit( unsigned short unit_type,
+Unit * UnitInterface::newUnit( unsigned short unit_type,
                                    const iXY &amp;location,
                                    unsigned short player_index,
                                    UnitID id)
 {
-    UnitBase* unit = 0;
+    Unit* unit = 0;
     bool color_flag;
     unsigned char unit_flag;
 
@@ -302,7 +345,7 @@
 
     if ( unit_type &lt; UnitProfileInterface::getNumUnitTypes() )
     {
-        unit = new Vehicle(player, unit_type, id, location);        
+        unit = new Unit(player, unit_type, id, location);
     }
     else
     {   // XXX change for a error window
@@ -314,7 +357,7 @@
 
 // ******************************************************************
 
-void UnitInterface::addNewUnit(UnitBase *unit)
+void UnitInterface::addNewUnit(Unit *unit)
 {
     units.insert(std::make_pair(unit-&gt;id, unit));
    
@@ -331,33 +374,32 @@
     unsigned long bucket_count;
     unsigned long bucket_index;
     UnitBucketList *bucket_list;
-    UnitBucketPointer *traversal_ptr;
+    UnitBucketList::iterator bucket_iter;
 
+
     bucket_count = unit_bucket_array.getSize();
 
     for( bucket_index = 0; bucket_index &lt; bucket_count; bucket_index++ ) {
         bucket_list = unit_bucket_array.getBucket( bucket_index );
 
-        traversal_ptr = bucket_list-&gt;getFront();
-
-        while( traversal_ptr != 0 ) {
+        for (bucket_iter = bucket_list-&gt;begin(); bucket_iter != bucket_list-&gt;end();
+                    ++bucket_iter)
+        {
             unsigned long unit_bucket_index;
 
-            unit_bucket_index = unit_bucket_array.worldLocToBucketIndex( traversal_ptr-&gt;unit-&gt;unit_state.location );
+            unit_bucket_index = unit_bucket_array.worldLocToBucketIndex( (*bucket_iter)-&gt;unit_state.location );
 
             if( unit_bucket_index != bucket_index ) {
-                unit_bucket_array.moveUnit( traversal_ptr-&gt;unit-&gt;id,
+                unit_bucket_array.moveUnit( (*bucket_iter)-&gt;id,
                         bucket_index, unit_bucket_index );
             }
-
-            traversal_ptr = traversal_ptr-&gt;next;
-        } // ** while
+        }
     }
 }
 
 // ******************************************************************
 
-UnitBase*
+Unit*
 UnitInterface::getUnit(UnitID id)
 {
     Units::iterator i = units.find(id);
@@ -369,14 +411,14 @@
 }
 
 // ******************************************************************
-UnitBase* UnitInterface::createUnit( unsigned short unit_type,
+Unit* UnitInterface::createUnit( unsigned short unit_type,
                                       const iXY &amp;location,
                                       Uint16 player_id)
 {
     if (playerUnitLists[player_id].size() &gt;= units_per_player)
 	return 0;
 
-    UnitBase* unit = newUnit(unit_type, location, player_id, newUnitID());
+    Unit* unit = newUnit(unit_type, location, player_id, newUnitID());
     addNewUnit(unit);
 
     return unit;
@@ -389,7 +431,7 @@
                                      const PlayerUnitConfig &amp;unit_config)
 {
     iXY next_loc;
-    UnitBase *unit;
+    Unit *unit;
     unsigned long unit_type_index;
     unsigned long unit_spawn_count;
     unsigned long unit_spawn_index;
@@ -422,7 +464,7 @@
         const iXY&amp; point, Uint16 player_id, unsigned char search_flags)
 {
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         if(!unit-&gt;unit_state.bounds(point))
             continue;
 
@@ -444,7 +486,7 @@
         const iRect&amp; rect, Uint16 player_id, unsigned char search_flags)
 {
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         if(!rect.contains(unit-&gt;unit_state.location))
             continue;
 
@@ -461,15 +503,15 @@
 
 /****************************************************************************/
 
-bool UnitInterface::queryClosestUnit( UnitBase **closest_unit_ptr,
+bool UnitInterface::queryClosestUnit( Unit **closest_unit_ptr,
                                        iXY &amp;loc, Uint16 player_id,
                                        unsigned char search_flags )
 {
     long closest_magnitude = 0;
-    UnitBase* closest_unit = 0;
+    Unit* closest_unit = 0;
 
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
 
         if(search_flags == _search_exclude_player
                 &amp;&amp; unit-&gt;player-&gt;getID() == player_id)
@@ -505,13 +547,13 @@
     return false;
 }
 
-bool UnitInterface::queryClosestUnit( UnitBase **closest_unit_ptr, iRect &amp;bounding_rect, iXY &amp;loc )
+bool UnitInterface::queryClosestUnit( Unit **closest_unit_ptr, iRect &amp;bounding_rect, iXY &amp;loc )
 {
-    UnitBase *closest_unit = 0;
+    Unit *closest_unit = 0;
     long closest_magnitude = 0;
     iRect bucket_rect;
     UnitBucketList *bucket_list;
-    UnitBucketPointer *traversal_ptr;
+    UnitBucketList::iterator bucket_iter;
 
     bucket_rect = unit_bucket_array.worldRectToBucketRect( bounding_rect );
 
@@ -519,27 +561,25 @@
         for( long column_index = bucket_rect.min.x; column_index &lt;= bucket_rect.max.x; column_index++ ) {
             bucket_list = unit_bucket_array.getBucket( row_index, column_index );
 
-            traversal_ptr = bucket_list-&gt;getFront();
-
-            while( traversal_ptr != 0 ) {
+            for ( bucket_iter = bucket_list-&gt;begin();
+                    bucket_iter != bucket_list-&gt;end(); ++bucket_iter)
+            {
                 iXY delta;
                 long temp_mag;
 
                 if ( closest_unit == 0 ) {
-                    closest_unit = traversal_ptr-&gt;unit;
-                    delta  = loc - traversal_ptr-&gt;unit-&gt;unit_state.location;
+                    closest_unit = *bucket_iter;
+                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
                     closest_magnitude = long(delta.mag2());
                 } else {
-                    delta  = loc - traversal_ptr-&gt;unit-&gt;unit_state.location;
+                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
                     temp_mag = long(delta.mag2());
 
                     if ( closest_magnitude &gt; temp_mag ) {
-                        closest_unit = traversal_ptr-&gt;unit;
+                        closest_unit = *bucket_iter;
                         closest_magnitude = temp_mag;
                     }
                 }
-
-                traversal_ptr = traversal_ptr-&gt;next;
             }
         }
     }
@@ -555,14 +595,14 @@
 
 // ******************************************************************
 
-bool UnitInterface::queryClosestEnemyUnit(UnitBase **closest_unit_ptr,
+bool UnitInterface::queryClosestEnemyUnit(Unit **closest_unit_ptr,
         iXY &amp;loc, Uint16 player_index)
 {
-    UnitBase *closest_unit = 0;
+    Unit *closest_unit = 0;
     long closest_magnitude = 0;
 
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         Uint16 unitPlayerID = unit-&gt;player-&gt;getID();
         
         if(unitPlayerID == player_index
@@ -609,7 +649,7 @@
     }
 
     UnitID id = locUnits[0];
-    UnitBase* unit = getUnit(id);
+    Unit* unit = getUnit(id);
     if(!unit) {
         return _no_unit_found;
     }
@@ -630,7 +670,7 @@
     iXY unit_map_loc;
 
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         UnitState* unit_state = &amp; unit-&gt;unit_state;
             
         MapInterface::pointXYtoMapXY( unit_state-&gt;location, &amp;unit_map_loc );
@@ -667,8 +707,8 @@
     const UMesgEndLifeCycleUpdate *lifecycle_update
         = (const UMesgEndLifeCycleUpdate *) message;
 
-    UnitBase* unit1 = getUnit(lifecycle_update-&gt;getDestroyer());
-    UnitBase* unit2 = getUnit(lifecycle_update-&gt;getDestroyed());
+    Unit* unit1 = getUnit(lifecycle_update-&gt;getDestroyer());
+    Unit* unit2 = getUnit(lifecycle_update-&gt;getDestroyed());
     if(unit1 == 0 || unit2 == 0) {
         LOGGER.warning(
                 &quot;Unit in EndLifeCycle message doesn't exist anymore&quot;
@@ -712,13 +752,13 @@
         = (const UnitIniSyncMessage *) net_message;
 
     try {
-        std::map&lt;UnitID, UnitBase*&gt;::iterator uit = units.find(sync_message-&gt;getUnitID());
+        std::map&lt;UnitID, Unit*&gt;::iterator uit = units.find(sync_message-&gt;getUnitID());
         if ( uit != units.end() ) {
             LOGGER.warning(&quot;UnitInterface::unitSyncMessage() Received an existing unit [%d]&quot;,
                             sync_message-&gt;getUnitID());
             return;
         }
-        UnitBase* unit = newUnit(sync_message-&gt;unit_type,
+        Unit* unit = newUnit(sync_message-&gt;unit_type,
                 iXY(sync_message-&gt;getLocX(), sync_message-&gt;getLocY()),
                 sync_message-&gt;getPlayerID(), sync_message-&gt;getUnitID());
         unit-&gt;in_sync_flag = false;
@@ -737,7 +777,7 @@
 
     UnitOpcode* opcode;
     while(decoder.decode(&amp;opcode)) {
-        UnitBase* unit = getUnit(opcode-&gt;getUnitID());
+        Unit* unit = getUnit(opcode-&gt;getUnitID());
 
         if(!unit) {
             LOGGER.debug(&quot;Update for non-existant unit: %d&quot;,
@@ -772,14 +812,14 @@
     Uint16 player_index = create_mesg-&gt;getPlayerID();
 
     try {
-        std::map&lt;UnitID, UnitBase*&gt;::iterator uit = units.find(create_mesg-&gt;getUnitID());
+        std::map&lt;UnitID, Unit*&gt;::iterator uit = units.find(create_mesg-&gt;getUnitID());
         if ( uit != units.end() ) {
             LOGGER.warning(&quot;UnitInterface::unitCreateMessage() Received an existing unit [%d]&quot;,
                             create_mesg-&gt;getUnitID());
             return;
         }
         iXY unitpos(create_mesg-&gt;getLocX(), create_mesg-&gt;getLocY());
-        UnitBase* unit = newUnit(create_mesg-&gt;unit_type, unitpos,
+        Unit* unit = newUnit(create_mesg-&gt;unit_type, unitpos,
                                  player_index, create_mesg-&gt;getUnitID());
         addNewUnit(unit);
         // remove unit from blackboard in client (we are client here)
@@ -840,7 +880,7 @@
     PlayerUnitList&amp; unitlist = playerUnitLists[player_id];
     for(PlayerUnitList::iterator i = unitlist.begin();
             i != unitlist.end(); ++i) {
-        UnitBase* unit = *i;
+        Unit* unit = *i;
         unit-&gt;processMessage(&amp;self_destruct);
     }
 }

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -41,8 +41,8 @@
 class UnitInterface
 {
 public:
-    typedef std::map&lt;UnitID, UnitBase*&gt; Units;
-    typedef std::vector&lt;UnitBase*&gt; PlayerUnitList;
+    typedef std::map&lt;UnitID, Unit*&gt; Units;
+    typedef std::vector&lt;Unit*&gt; PlayerUnitList;
     
 private:
     static Units units;
@@ -56,11 +56,11 @@
     static Uint16 lastUnitID;
     static UnitID newUnitID();
 
-    static UnitBase* newUnit(unsigned short unit_type,
+    static Unit* newUnit(unsigned short unit_type,
                              const iXY &amp;location,
                              unsigned short player_index,
                              UnitID id);
-    static void addNewUnit(UnitBase *unit);
+    static void addNewUnit(Unit *unit);
     static void removeUnit(Units::iterator i);
 
     static void sortBucketArray();
@@ -100,7 +100,7 @@
         return units.size();
     }
 
-    static UnitBase* getUnit(UnitID unit_id);
+    static Unit* getUnit(UnitID unit_id);
 
     static void processNetPacket(const NetPacket* packet);
     static void sendMessage(const UnitMessage* message,
@@ -110,7 +110,7 @@
 
     static void offloadGraphics( SpriteSorter &amp;sorter );
 
-    static UnitBase* createUnit( unsigned short unit_type,
+    static Unit* createUnit( unsigned short unit_type,
                                   const iXY &amp;location,
                                   Uint16 player_id);
 
@@ -126,16 +126,16 @@
                             const iRect&amp; rect, Uint16 player_id,
                             unsigned char search_flags);
 
-    static bool queryClosestUnit( UnitBase **closest_unit_ptr,
+    static bool queryClosestUnit( Unit **closest_unit_ptr,
                                    iXY &amp;loc,
                                    Uint16 player_id,
                                    unsigned char search_flags );
 
-    static bool queryClosestUnit( UnitBase **closest_unit_ptr,
+    static bool queryClosestUnit( Unit **closest_unit_ptr,
                                    iRect &amp;bounding_rect,
                                    iXY &amp;loc );
 
-    static bool queryClosestEnemyUnit(UnitBase **closest_unit_ptr,
+    static bool queryClosestEnemyUnit(Unit **closest_unit_ptr,
                                       iXY &amp;loc,
                                       Uint16 player_index);
 
@@ -149,7 +149,7 @@
     static void unitManagerMesgEndLifecycle(const UnitMessage *message);
 
 protected:
-    friend class Vehicle;
+    friend class Unit;
     
     // Network Message Handler Variables
     static Timer message_timer;

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitOpcodes.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitOpcodes.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitOpcodes.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -18,7 +18,8 @@
 #ifndef _UNITOPCODES_HPP
 #define _UNITOPCODES_HPP
 
-#include &quot;Units/UnitBase.hpp&quot;
+#include &quot;Core/CoreTypes.hpp&quot;
+#include &quot;Types/iXY.hpp&quot;
 #include &lt;queue&gt;
 
 enum { _unit_opcode_flag_sync = 0x01 };

Deleted: trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,2233 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#include &lt;config.h&gt;
-
-#include &lt;stdexcept&gt;
-
-#include &lt;string.h&gt;
-#include &quot;Util/Log.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
-#include &quot;Units/Vehicle.hpp&quot;
-#include &quot;Units/UnitGlobals.hpp&quot;
-#include &quot;Classes/Network/NetworkState.hpp&quot;
-#include &quot;Interfaces/PathScheduler.hpp&quot;
-#include &quot;Interfaces/MapInterface.hpp&quot;
-#include &quot;Weapons/ProjectileInterface.hpp&quot;
-#include &quot;Units/UnitInterface.hpp&quot;
-#include &quot;Units/UnitProfileInterface.hpp&quot;
-#include &quot;System/Sound.hpp&quot;
-
-
-// NOTE: Temp unit new sprites put in
-#include &quot;Interfaces/GameConfig.hpp&quot;
-
-#include &quot;Interfaces/ConsoleInterface.hpp&quot;
-#include &quot;Particles/ParticleInterface.hpp&quot;
-#include &quot;Interfaces/WorldViewInterface.hpp&quot;
-
-#define MOVEWAIT_TIME 0.8f
-
-enum{ _rotate_and_move, _rotate_stop_move };
-
-Vehicle::Vehicle(PlayerState* player, unsigned char utype, UnitID id, iXY initial_loc)
-    : UnitBase(player, id)
-{
-    smolderWait    = 0.0f;
-    smolderWaitMin = 0.0f;
-
-    if(!MapInterface::inside(initial_loc))
-        throw std::runtime_error(&quot;Invalid position&quot;);
-
-    iXY loc = MapInterface::mapXYtoPointXY(initial_loc);
-    unit_state.location = loc;
-    UnitBlackBoard::markUnitLoc( initial_loc );
-    fsm_timer.changeRate( 10 );
-    unit_state_timer.changeRate( 10 );
-    setAiFsmDefendHold();
-    pending_AI_comm = false;
-    unit_state.lifecycle_state = _UNIT_LIFECYCLE_ACTIVE;
-    memset( fsm_active_list, 0, sizeof( bool ) * 7 );
-
-    in_sync_flag = true;
-
-    body_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
-    turret_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
-
-    path_generated = false;
-    critical_ai_section = false;
-    ai_fsm_transition_complete = false;
-    
-    reload_counter = 0;
-    death_counter = 0;
-
-    ai_command_state = 0;
-    external_ai_event = _external_event_null;
-
-    fsmBodyRotate_rotation = 0;
-    fsmBodyRotate_goal_angle = 0;
-    fsmTurretRotate_rotation = 0;
-    fsmTurretRotate_goal_angle = 0;
-    
-    interpolation_speed = 0;
-    fsmMove_first_stamp = false;
-    fsmMove_offset_x = fsmMove_offset_y = 0;
-    fsmMove_moves_counter = 0;
-    fsmMove_moves_per_square = 0;
-
-    move_opcode_sent = false;
-    fsmMoveMapSquare_movement_type = 0;
-
-    aiFsmDefendHold_state = 0;
-
-    // from unit profiles
-    setUnitProperties(utype);
-    iXY zero;
-    zero.zero();
-    body_anim.setAttrib( zero, zero, unitLayer );
-    turret_anim.setAttrib( zero, zero, unitLayer );
-    body_anim_shadow.setAttrib( zero, zero, unitLayer);
-    turret_anim_shadow.setAttrib( zero, zero, unitLayer);
-    
-    select_info_box.setBoxState( false );
-    select_info_box.setFlag( player-&gt;getFlag() );
-    select_info_box.setName( player-&gt;getName() );
-    
-    body_anim_shadow.attachSprite( &amp;body_anim, zero );
-    body_anim_shadow.attachSprite( &amp;turret_anim_shadow, zero );
-    body_anim_shadow.attachSprite( &amp;turret_anim, zero );
-    body_anim_shadow.attachSprite( &amp;select_info_box, zero );
-    
-    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-}
-
-void Vehicle::setUnitProperties( unsigned char utype )
-{
-    UnitProfile *profile;
-    
-    profile = UnitProfileInterface::getUnitProfile( utype );
-    
-    unit_state.hit_points = profile-&gt;hit_points;
-    unit_state.max_hit_points = profile-&gt;hit_points;
-    unit_state.damage_factor = profile-&gt;attack_factor;
-    unit_state.defend_range = profile-&gt;defend_range;
-    unit_state.speed_factor = profile-&gt;speed_factor;
-    unit_state.speed_rate = profile-&gt;speed_rate;
-    unit_state.reload_time = profile-&gt;reload_time;
-    unit_state.weapon_range = profile-&gt;attack_range;
-    unit_state.unit_type = utype;
-    select_info_box.setHitBarAttributes( profile-&gt;hit_points, Color::yellow );
-    body_anim.setData( profile-&gt;bodySprite );
-    body_anim_shadow.setData( profile-&gt;bodyShadow );
-    turret_anim.setData( profile-&gt;turretSprite );
-    turret_anim_shadow.setData( profile-&gt;turretShadow );
-    soundSelect = profile-&gt;soundSelected;
-    fireSound = profile-&gt;fireSound;
-    if ( profile-&gt;weaponType == &quot;QUADMISSILE&quot; )
-    {
-        weaponType = Weapon::_quad_missile;
-    }
-    else if ( profile-&gt;weaponType == &quot;BULLET&quot; )
-    {
-        weaponType = Weapon::_bullet;
-    }
-    else if ( profile-&gt;weaponType == &quot;SHELL&quot; )
-    {
-        weaponType = Weapon::_shell;
-    }
-    else if ( profile-&gt;weaponType == &quot;DOUBLEMISSILE&quot; )
-    {
-        weaponType = Weapon::_double_missile;
-    }
-    else
-    {
-        weaponType = Weapon::_bullet;
-    }
-    int bsize = profile-&gt;boundBox / 2;
-    select_info_box.setBoxAttributes( BoundBox( -bsize, -bsize, bsize, bsize), Color::blue);
-}
-
-
-void Vehicle::updateUnitStateProperties()
-{
-    if ( reload_counter &lt; unit_state.reload_time )
-        reload_counter++;
-
-    if ( (unit_state.lifecycle_state == _UNIT_LIFECYCLE_PENDING_DESTRUCT) &amp;&amp;
-            (ai_command_state == _ai_command_idle)
-       )
-    {
-        unit_state.lifecycle_state = _UNIT_LIFECYCLE_DESTROYED;
-        death_counter = 0;
-    }
-
-    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
-    {
-        if ( death_counter == 5 )
-        {
-            unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
-
-            DestructUnitOpcode destruct_opcode;
-            destruct_opcode.setUnitID(id);
-            UnitInterface::sendOpcode(&amp;destruct_opcode);
-        }
-        else
-        {
-            death_counter++;
-        }
-    }
-}
-
-void Vehicle::orientationToOffset( unsigned short orientation, signed char *offset_x, signed char *offset_y )
-{
-    switch ( orientation )
-    {
-        case 0:
-            *offset_x =  1; *offset_y =  0;
-            break;
-        case 1:
-            *offset_x =  1; *offset_y = -1;
-            break;
-        case 2:
-            *offset_x =  0; *offset_y = -1;
-            break;
-        case 3:
-            *offset_x = -1; *offset_y = -1;
-            break;
-        case 4:
-            *offset_x = -1; *offset_y =  0;
-            break;
-        case 5:
-            *offset_x = -1; *offset_y =  1;
-            break;
-        case 6:
-            *offset_x =  0; *offset_y =  1;
-            break;
-        case 7:
-            *offset_x =  1; *offset_y =  1;
-            break;
-    }
-
-}
-
-unsigned short Vehicle::mapXYtoOrientation( unsigned long square, long *goal_angle )
-{
-    iXY current_loc, next_loc;
-
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
-    MapInterface::offsetToMapXY( square, &amp;next_loc );
-    
-    // so many magic numbers
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y == current_loc.y) )
-    {
-        *goal_angle = 0;
-        return( 0 );
-    }
-
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
-    {
-        *goal_angle = 5;
-        return( 1 );
-    }
-
-    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
-    {
-        *goal_angle = 9;
-        return( 2 );
-    }
-
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
-    {
-        *goal_angle = 14;
-        return( 3 );
-    }
-
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y  == current_loc.y) )
-    {
-        *goal_angle = 18;
-        return( 4 );
-    }
-
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
-    {
-        *goal_angle = 23;
-        return( 5 );
-    }
-
-    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
-    {
-        *goal_angle = 27;
-        return( 6 );
-    }
-
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
-    {
-        *goal_angle = 32;
-        return( 7 );
-    }
-
-    return( 0xFFFF );
-
-
-}
-
-unsigned short Vehicle::shortestRotation( AngleInt &amp;angle, long goal_angle, long *delta )
-{
-    long delta_plus, delta_minus;
-
-    if( goal_angle &gt; angle.angle_int )
-        delta_plus  = ( goal_angle ) - (angle.angle_int) ;
-    else
-        delta_plus  = (angle.angle_limit + goal_angle) - angle.angle_int;
-
-    if ( goal_angle &gt; angle.angle_int )
-        delta_minus = angle.angle_limit - (goal_angle  -  angle.angle_int) ;
-    else
-        delta_minus = (angle.angle_int ) - ( goal_angle );
-
-    if (delta_minus &gt; delta_plus)
-    {
-        *delta = delta_plus;
-        return( _rotate_pos );
-    }
-    else
-    {
-        *delta = delta_minus;
-        return( _rotate_neg );
-    }
-}
-
-void Vehicle::locationOffset( unsigned long square, iXY &amp;offset )
-{
-    iXY square_map_loc;
-    iXY unit_map_loc;
-
-    MapInterface::offsetToMapXY( square, &amp;square_map_loc );
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;unit_map_loc );
-
-    offset = unit_map_loc - square_map_loc ;
-}
-
-void Vehicle::setFsmBodyRotate( long goal_angle, unsigned short rotation )
-{
-    fsmBodyRotate_rotation = rotation;
-    fsmBodyRotate_goal_angle = goal_angle;
-}
-
-bool Vehicle::fsmBodyRotate()
-{
-    if( unit_state.body_angle.angle_int != fsmBodyRotate_goal_angle )
-    {
-        if ( fsmBodyRotate_rotation == _rotate_pos )
-        {
-            ++unit_state.body_angle;
-        }
-        else
-        {
-            --unit_state.body_angle;
-        }  // ** else turn_rotation **
-    }
-    else
-    {
-        return( true );   // goal direction achieved
-    }
-
-    return( false );
-}
-
-void Vehicle::setFsmTurretRotate( long goal_angle, unsigned short rotation )
-{
-    fsmTurretRotate_rotation = rotation;
-    fsmTurretRotate_goal_angle = goal_angle;
-}
-
-bool Vehicle::fsmTurretRotate()
-{
-    if( unit_state.turret_angle.angle_int != fsmTurretRotate_goal_angle )
-    {
-        if ( fsmTurretRotate_rotation == _rotate_pos )
-        {
-            ++unit_state.turret_angle;
-        }
-        else
-        {
-            --unit_state.turret_angle;
-        }  // ** else turn_rotation **
-    }
-    else
-    {
-        return( true );   // goal direction achieved
-    }
-
-    return( false );
-}
-
-void Vehicle::setFsmMove( unsigned short orientation )
-{
-    fsm_timer.changeRate( unit_state.speed_rate );
-    orientationToOffset( orientation, &amp;fsmMove_offset_x, &amp;fsmMove_offset_y );
-    fsmMove_moves_counter = 0;
-    fsmMove_moves_per_square = 32 / unit_state.speed_factor;
-    /*
-    fsmMove_moves_per_square = 32;
-    interpolation_speed = unit_state.speed_rate * unit_state.speed_factor;
-    if ( NetworkState::status == _network_state_client )
-     { interpolation_speed += 2; } 
-    fsmMove_first_stamp = true;
-    */
-}
-
-bool Vehicle::fsmMove()
-{
-    /*
-    long move_offset;
-
-    if( fsmMove_first_stamp == true )
-       {
-        start_move_stamp = now();
-        fsmMove_first_stamp = false;
-       }
-
-    end_move_stamp = now();
-
-    move_offset = (end_move_stamp - start_move_stamp) * interpolation_speed;  
-
-    if( (move_offset + fsmMove_moves_counter) &gt; fsmMove_moves_per_square )
-     {
-      move_offset = fsmMove_moves_per_square - fsmMove_moves_counter;
-     }
-    */
-
-    if ( fsmMove_moves_counter &lt; fsmMove_moves_per_square )
-    {
-        /*
-        fsmMove_moves_counter += move_offset;
-
-        unit_state.location.x = unit_state.location.x + ( move_offset * fsmMove_offset_x );
-
-        unit_state.location.y = unit_state.location.y + ( move_offset * fsmMove_offset_y );
-        */
-
-        fsmMove_moves_counter++;
-
-        unit_state.location.x = unit_state.location.x + ( unit_state.speed_factor * fsmMove_offset_x );
-
-        unit_state.location.y = unit_state.location.y + ( unit_state.speed_factor * fsmMove_offset_y );
-
-        ParticleInterface::addMoveDirtPuff(unit_state);
-        //start_move_stamp = now();
-    }
-
-    if( fsmMove_moves_counter &gt;= fsmMove_moves_per_square)
-    {
-        //fsmMove_first_stamp = true;
-        fsm_timer.changeRate( 10 );
-        return( true );
-    }
-
-    return( false );
-}
-
-void Vehicle::setFsmMoveMapSquare( unsigned long square )
-{
-    long goal_angle = 0;
-    long delta;
-    unsigned short rotation;
-
-    unit_state.orientation = mapXYtoOrientation( square, &amp;goal_angle );
-    rotation = shortestRotation( unit_state.body_angle, goal_angle, &amp;delta );
-
-    setFsmBodyRotate( goal_angle, rotation );
-    setFsmMove( unit_state.orientation );
-
-    if ( delta &lt;= 9 )
-        fsmMoveMapSquare_movement_type = _rotate_and_move;
-    else
-        fsmMoveMapSquare_movement_type = _rotate_stop_move;
-
-    fsm_active_list[ _control_move_map_square ] = true;
-    critical_ai_section = true;
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        iXY loc_offset;
-
-        move_opcode.opcode = _UNIT_OPCODE_MOVE;
-        move_opcode.setUnitID(id);
-        move_opcode.setSquare(square);
-        locationOffset( square, loc_offset );
-        move_opcode.loc_x_offset = (signed char) loc_offset.x;
-        move_opcode.loc_y_offset = (signed char) loc_offset.y;
-        if ( move_opcode_sent == true )
-        {
-            UnitInterface::sendOpcode(&amp;move_opcode);
-        }
-    }
-
-}
-
-
-
-
-bool Vehicle::fsmMoveMapSquare()
-{
-    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-    {
-        if ( opcode_move_timer.count() )
-        {
-            UnitInterface::sendOpcode(&amp;move_opcode);
-            move_opcode_sent = true;
-        }
-    }
-
-    switch( fsmMoveMapSquare_movement_type )
-    {
-        case  _rotate_stop_move :
-        {
-            if ( fsmBodyRotate() )
-            {
-                if ( fsmMove() )
-                {
-                    fsm_active_list[ _control_move_map_square ] = false;
-                    critical_ai_section = false;
-
-                    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-                    {
-                        UnitInterface::sendOpcode(&amp;move_opcode);
-                        move_opcode_sent = true;
-                    }
-                    
-                    return( true );
-                }
-            }
-        }
-        break;
-
-        case _rotate_and_move :
-        {
-            fsmBodyRotate();
-            if ( fsmMove() )
-            {
-                fsm_active_list[ _control_move_map_square ] = false;
-                critical_ai_section = false;
-
-                if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-                {
-                    UnitInterface::sendOpcode(&amp;move_opcode);
-                    move_opcode_sent = true;
-                }
-
-                return( true );
-            }
-        }
-        break;
-    } // ** switch
-
-    return( false );
-}
-
-
-void Vehicle::setFsmTurretTrackPoint(const iXY&amp; target)
-{
-    iXY direction_vector;
-
-    fsmTurretTrackPoint_target = target;
-    direction_vector = fsmTurretTrackPoint_target - unit_state.location;
-    fsmTurretTrackPoint_target_angle.set( direction_vector );
-
-    fsmTurretTrackPoint_on_target = false;
-
-    fsm_active_list[ _control_turret_track_point ] = true;
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        TurretTrackPointOpcode track_point_opcode;
-        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
-        track_point_opcode.setUnitID(id);
-        track_point_opcode.setTarget(target);
-        track_point_opcode.activate = true;
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
-    }
-
-}
-
-void Vehicle::clearFsmTurretTrackPoint()
-{
-    fsm_active_list[ _control_turret_track_point ] = false;
-
-    fsmTurretTrackPoint_on_target = false;
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        TurretTrackPointOpcode track_point_opcode;
-        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
-        track_point_opcode.setUnitID(id);
-        track_point_opcode.activate = false;
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
-    }
-}
-
-void Vehicle::syncFsmTurretTrackPoint()
-{
-    if ( fsm_active_list[ _control_turret_track_point ] == true )
-    {
-        TurretTrackPointOpcode track_point_opcode;
-        track_point_opcode.flags = _unit_opcode_flag_sync;
-        track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
-        track_point_opcode.setUnitID(id);
-        track_point_opcode.setTarget(fsmTurretTrackPoint_target);
-        track_point_opcode.activate = true;
-
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
-    }
-}
-
-void Vehicle::fsmTurretTrackPoint()
-{
-    long goal_angle;
-    long delta;
-    unsigned short rotation;
-    iXY direction_vector;
-
-    direction_vector = fsmTurretTrackPoint_target - unit_state.location;
-    fsmTurretTrackPoint_target_angle.set( direction_vector );
-
-    goal_angle = fsmTurretTrackPoint_target_angle.DegreesInt( 10 );
-    rotation = shortestRotation( unit_state.turret_angle, goal_angle, &amp;delta );
-    setFsmTurretRotate( goal_angle, rotation );
-
-    if (  fsmTurretRotate() == true )
-        fsmTurretTrackPoint_on_target = true;
-    else
-        fsmTurretTrackPoint_on_target = false;
-
-}
-
-void Vehicle::setFsmTurretTrackTarget(UnitID target_id)
-{
-    fsmTurretTrackTarget_target_id = target_id;
-    fsm_active_list[ _control_turret_track_target ] = true;
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        TurretTrackTargetOpcode track_target_opcode;
-        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
-        track_target_opcode.setUnitID(id);
-        track_target_opcode.setTargetUnitID(target_id);
-        track_target_opcode.activate = true;
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
-    }
-
-}
-
-void Vehicle::clearFsmTurretTrackTarget()
-{
-    fsm_active_list[ _control_turret_track_target ] = false;
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        TurretTrackTargetOpcode track_target_opcode;
-        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
-        track_target_opcode.setUnitID(id);
-        track_target_opcode.activate = false;
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
-    }
-
-}
-
-void Vehicle::syncFsmTurretTrackTarget()
-{
-    if ( fsm_active_list[ _control_turret_track_target ] == true )
-    {
-        TurretTrackTargetOpcode track_target_opcode;
-        track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
-        track_target_opcode.flags = _unit_opcode_flag_sync;
-        track_target_opcode.setUnitID(id);
-        track_target_opcode.setTargetUnitID(fsmTurretTrackTarget_target_id);
-        track_target_opcode.activate = true;
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
-    }
-
-}
-
-
-void Vehicle::fsmTurretTrackTarget()
-{
-    long goal_angle;
-    long delta;
-    unsigned short rotation;
-    UnitBase *target_unit_ptr;
-    iXY direction_vector;
-
-    target_unit_ptr = UnitInterface::getUnit( fsmTurretTrackTarget_target_id );
-
-    if ( target_unit_ptr != 0 )
-    {
-        direction_vector = target_unit_ptr-&gt;unit_state.location - unit_state.location;
-        Angle float_angle( direction_vector );
-
-        goal_angle = float_angle.DegreesInt( 10 );
-        rotation = shortestRotation( unit_state.turret_angle, goal_angle, &amp;delta );
-        setFsmTurretRotate( goal_angle, rotation );
-    }
-
-    if ( fsmTurretRotate() == true )
-    {
-        fsmTurretTrackTarget_on_target = true;
-    }
-    else
-    {
-        fsmTurretTrackTarget_on_target = false;
-    }
-}
-
-
-
-void Vehicle::setFsmGunneryLocation(const iXY&amp; target )
-{
-    if ( fsm_active_list[ _control_gunnery_target ] == true )
-    {
-        clearFsmGunneryTarget();
-    }
-
-    fsmGunneryLocation_target = target;
-    setFsmTurretTrackPoint( target );
-    fsm_active_list[ _control_gunnery_location ] = true;
-}
-
-void Vehicle::clearFsmGunneryLocation()
-{
-    fsm_active_list[ _control_gunnery_location ] = false;
-    clearFsmTurretTrackPoint();
-}
-
-void Vehicle::fsmGunneryLocation()
-{
-    iXY range_vector;
-
-    range_vector = fsmGunneryLocation_target - unit_state.location;
-
-    if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
-            (fsmTurretTrackPoint_on_target == true) &amp;&amp;
-            (reload_counter &gt;= unit_state.reload_time)
-       )
-    {
-        fireWeapon( fsmGunneryLocation_target );
-        clearFsmGunneryLocation();
-    }
-
-}
-
-void Vehicle::setFsmGunneryTarget(UnitID target_id)
-{
-    if ( fsm_active_list[ _control_gunnery_location ] == true )
-    {
-        clearFsmGunneryLocation();
-    }
-
-    if ( fsm_active_list[ _control_turret_track_point ] == true )
-    {
-        clearFsmTurretTrackPoint();
-    }
-
-    fsmGunneryTarget_target_id = target_id;
-    setFsmTurretTrackTarget( target_id );
-    fsm_active_list[ _control_gunnery_target ] = true;
-}
-
-void Vehicle::clearFsmGunneryTarget()
-{
-    fsm_active_list[ _control_gunnery_target ] = false;
-    clearFsmTurretTrackTarget();
-}
-
-void Vehicle::fsmGunneryTarget()
-{
-    UnitBase *target_unit_ptr;
-    UnitState *target_unit_state;
-    iXY range_vector;
-
-    target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
-    if ( target_unit_ptr == 0 )
-    {
-        clearFsmGunneryTarget();
-    }
-    else
-    {
-        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-
-        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
-        {
-            clearFsmGunneryTarget();
-        }
-        else
-        {
-            range_vector = target_unit_state-&gt;location - unit_state.location;
-
-            if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
-                    (fsmTurretTrackTarget_on_target == true) &amp;&amp;
-                    (reload_counter == unit_state.reload_time )
-               )
-            {
-                fireWeapon( target_unit_state-&gt;location );
-            }
-        }
-    }
-
-
-}
-
-void Vehicle::aiFsmIdle()
-{
-    if ( pending_AI_comm == true )
-    {
-        ai_fsm_transition_complete = true;
-    }
-
-}
-
-bool Vehicle::ruleMoveToLoc_GoalReached()
-{
-    iXY map_loc;
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;map_loc );
-    if ( map_loc == aiFsmMoveToLoc_goal )
-        return true;
-
-    return false;
-}
-
-
-void Vehicle::aiFsmMoveToLoc()
-{
-    bool end_cycle = false;
-
-    do
-    {
-        switch ( aiFsmMoveToLoc_state )
-        {
-
-            // *************************************************************
-            case _aiFsmMoveToLoc_path_generate :
-            {
-                // QueryPath: Has a path been generated for unit ?
-                path_generated = PathScheduler::queryPath(id);
-
-
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
-
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( path_generated == true )
-                {
-                    // Rule QueryPath: is true move to next state
-                    //LOG( (&quot;Path Successfully Generated&quot;) );
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-                else
-                {
-                    end_cycle = true;                    
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_check_goal :
-            {
-                //  GoalReached: Has the goal been reached ?
-                if ( ruleMoveToLoc_GoalReached() == true )
-                {
-                    // Rule GoalReached : is true
-                    // Action : Exit fsm
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
-
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    setAiFsmDefendHold();
-
-                    end_cycle = true;
-                }
-                else
-                {
-                    if ( aiFsmMoveToLoc_path_not_finished == false )
-                    {
-                        //  Rule: GoalReached is false AND Unit is at the end of path
-                        //  Action : Request path generation to goal
-                        iXY start;
-                        PathRequest path_request;
-
-                        //LOG( (&quot;Incomplete Path -- Regenerating Path&quot;) );
-                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-                        path_request.set(id, start, aiFsmMoveToLoc_goal, 0,  &amp;path, _path_request_full );
-                        PathScheduler::requestPath( path_request );
-                        aiFsmMoveToLoc_path_not_finished = true;
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-                    }
-                    else
-                    {
-                        // Rule GoalReached: is false
-                        // Action: Get next move;
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
-                    }
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_next_move :
-            {
-                // CurrentPathComplete: is Unit at the end of the current path
-                aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
-                MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
-
-                if ( !aiFsmMoveToLoc_path_not_finished )
-                {
-                    // Rule: CurrentPathComplete is true
-                    // Action : check if unit is at the goal
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-                else
-                {
-                    // Rule: CurrentPathComplete is false
-                    // Action: Check if next location is empty
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
-
-                    //aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                    aiFsmMoveToLoc_wait_timer.reset();
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_wait_clear_loc :
-            {
-
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                } // NextSquareOccupied: does the next square contain a abstruction
-                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
-                {
-                    // Rule: NextSquareOccupied is true
-                    // Action: Check Wait Timer
-
-                    if ( aiFsmMoveToLoc_wait_timer.count() )
-                    {
-                        // Rule: NextSquareOccupied is true AND WaitTimer is finished
-                        // Action: Preform path update
-                        if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
-                        {
-
-                            UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
-                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
-
-                            PathRequest path_request;
-                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
-                            PathScheduler::requestPath( path_request );
-                            aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                        }
-                        else
-                        {
-//                            LOGGER.warning(&quot;Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
-//                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
-//                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
-                            PathRequest path_request;
-                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
-                            PathScheduler::requestPath( path_request );
-                            // XXX the more times timeout the longer will take next time
-                            aiFsmMoveToLoc_wait_timer.changePeriod( aiFsmMoveToLoc_wait_timer.getPeriod() * 2.0f );
-                        }
-
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-                    }
-                    // can't move and has to wait, finish the loop.
-                    end_cycle = true;
-                }
-                else
-                {
-                    // Rule: NextSquareOccupied is false
-                    // Action: Begin move to next square
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
-                    setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
-
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
-                    aiFsmMoveToLoc_wait_timer.changePeriod( 0.8f );
-                }
-
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_move_wait :
-            {
-                // MoveFinished : has the low level fsm finshed
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    // Rule: MoveFinished is true
-                    // Action: Check for a pending transition
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
-                    end_cycle = true;
-                }
-                else
-                {
-                    end_cycle = true;
-                } // ** else
-
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-
-            }
-            break;
-            
-        } // ** switch
-        
-    } while (end_cycle == false);
-}
-
-void Vehicle::aiFsmMoveToLoc_OnExitCleanUp()
-{
-    PathScheduler::killRequest(id);
-    clearFsmTurretTrackPoint();
-}
-
-void Vehicle::aiFsmAttackUnit()
-{
-    bool end_cycle = false;
-
-    UnitState *target_unit_state = 0;
-    iXY range_vector;
-
-    UnitBase* target_unit_ptr 
-        = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
-    if ( target_unit_ptr == 0 )
-    {
-        aiFsmAttackUnit_target_destroyed = true;
-        if(aiFsmAttackUnit_state != _aiFsmAttackUnit_move_wait)
-        {
-            setAiFsmDefendHold();
-            aiFsmAttackUnit_OnExitCleanUp();
-            return;
-        }
-    }
-    else
-    {
-        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-
-        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
-        {
-            aiFsmAttackUnit_target_destroyed = true;
-
-            if ( aiFsmAttackUnit_state !=  _aiFsmAttackUnit_move_wait )
-            {
-                setAiFsmDefendHold();
-                aiFsmAttackUnit_OnExitCleanUp();
-                return;
-            }
-        }
-    }
-
-    do
-    {
-        switch ( aiFsmAttackUnit_state )
-        {
-            // *************************************************************
-
-            case _aiFsmAttackUnit_path_generate :
-            {
-                // QueryPath: Has a path been generated for unit ?
-                path_generated = PathScheduler::queryPath(id);
-
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
-
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( path_generated == true )
-                {
-                    // Rule QueryPath: is true move to next state
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
-                }
-                else
-                {
-                    end_cycle = true;
-                }
-
-            }
-            break;
-            // *************************************************************
-
-            case _aiFsmAttackUnit_range_check :
-            {
-                // RangeVector: the absolute distance between unit and target
-                range_vector = target_unit_state-&gt;location - unit_state.location;
-
-                if ( range_vector.mag2() &lt; unit_state.weapon_range )
-                {
-                    // Rule: RangeVector &lt; WeaponRange, unit is in range
-                    // Action: Remain in position
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
-                    end_cycle = true;
-                }
-                else
-                {
-                    if ( aiFsmAttackUnit_path_not_finished == false )
-                    {
-                        iXY start;
-                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-
-                        PathRequest path_request;
-                        path_request.set(id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
-                        PathScheduler::requestPath( path_request );
-
-                        aiFsmAttackUnit_path_not_finished = true;
-                        aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-                    }
-                    else
-                    {
-                        // Rule: RangeVector &gt; WeaponRange
-                        // Action: Get next move
-                        aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
-                    }
-                }
-            }
-            break;
-            // *************************************************************
-
-            case _aiFsmAttackUnit_idle :
-            {
-                range_vector = target_unit_state-&gt;location - unit_state.location;
-
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( range_vector.mag2() &lt; unit_state.weapon_range )
-                {
-                    // Rule: RangeVector &lt; WeaponRange, unit is in range
-                    // Action: Remain in position
-                    end_cycle = true;
-                }
-                else
-                {
-                    // Rule: RangeVector &gt; WeaponRange
-                    // Action: Get next move
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmAttackUnit_next_move :
-            {
-                // CurrentPathComplete: is Unit at the end of the current path
-                aiFsmAttackUnit_path_not_finished = path.popFirst( &amp;aiFsmAttackUnit_next_square );
-                MapInterface::offsetToMapXY( aiFsmAttackUnit_next_square, &amp;aiFsmAttackUnit_next_loc );
-
-                if ( !aiFsmAttackUnit_path_not_finished )
-                {
-                    // Rule: CurrentPathComplete is true
-                    // Action : check if unit is at the goal
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
-                }
-                else
-                {
-                    // Rule: CurrentPathComplete is false
-                    // Action: Check if next location is empty
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
-                    aiFsmAttackUnit_wait_timer.changePeriod( 0.8f );
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_wait_clear_loc;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmAttackUnit_wait_clear_loc :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
-                {
-                    if ( aiFsmAttackUnit_wait_timer.count() )
-                    {
-                        if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
-                        {
-                            UnitInterface::unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
-                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
-
-                            PathRequest path_request;
-                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
-                            PathScheduler::requestPath( path_request );
-
-                        }
-                        else
-                        {
-                            PathRequest path_request;
-                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_update );
-                            PathScheduler::requestPath( path_request );
-                        }
-
-                        aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-                    }
-
-                    end_cycle = true;
-                }
-                else
-                {
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_next_loc );
-                    setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmAttackUnit_move_wait :
-            {
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
-                }
-                end_cycle = true;
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmAttackUnit_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if (  aiFsmAttackUnit_target_destroyed == true )
-                {
-                    setAiFsmDefendHold();
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
-                }
-            }
-            break;
-            // *************************************************************
-
-            case _aiFsmAttackUnit_check_path_deviation :
-            {
-                iXY deviation_vector;
-                iXY goal_point_loc;
-
-                MapInterface::mapXYtoPointXY( aiFsmAttackUnit_target_goal_loc, &amp;goal_point_loc );
-                deviation_vector = target_unit_state-&gt;location - goal_point_loc;
-
-                if ( deviation_vector.mag2() &gt; unit_state.weapon_range )
-                {
-                    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
-
-                    PathRequest path_request;
-                    path_request.set( id, aiFsmAttackUnit_next_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
-                    PathScheduler::requestPath( path_request );
-
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
-                }
-
-            }
-            break;
-
-        } // ** switch
-
-    } while ( end_cycle == false );
-
-}
-
-void Vehicle::aiFsmAttackUnit_OnExitCleanUp()
-{
-    PathScheduler::killRequest( id );
-    clearFsmGunneryTarget();
-}
-
-void Vehicle::setAiFsmDefendHold()
-{
-    ai_command_state = _ai_command_defend_hold;
-    aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-    aiFsmDefendHold_search_timer.changePeriod( .5 );
-}
-
-void Vehicle::aiFsmDefendHold()
-{
-    bool end_cycle = false;
-
-    UnitBase  *target_unit_ptr;
-    UnitState *target_unit_state;
-
-    iXY range_vector;
-
-    do
-    {
-        switch ( aiFsmDefendHold_state )
-        {
-            case _aiFsmDefendHold_search_for_enemy :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else if ( aiFsmDefendHold_search_timer.count() )
-                {
-                    if (UnitInterface::queryClosestEnemyUnit(
-                                &amp;target_unit_ptr, unit_state.location,
-                                player-&gt;getID() ) )
-                    {
-                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                        range_vector = target_unit_state-&gt;location - unit_state.location;
-                        if ( range_vector.mag2() &lt;= unit_state.defend_range )
-                        {
-                            aiFsmDefendHold_target_ID = target_unit_ptr-&gt;id;
-                            setFsmGunneryTarget( aiFsmDefendHold_target_ID );
-                            aiFsmDefendHold_state = _aiFsmDefendHold_attack_enemy;
-                            end_cycle = true;
-                        }
-                        else
-                        {
-                            end_cycle = true;
-                        }
-                    } // **  quearyClosestEnemyUnit
-                    else
-                    {
-                        end_cycle = true;
-                    }
-
-                } // ** aiFsmDefendHold_search_timer.count()
-                else
-                {
-                    end_cycle = true;
-                }
-            }
-            break;
-
-            case _aiFsmDefendHold_attack_enemy :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    clearFsmGunneryTarget();
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    clearFsmGunneryTarget();
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else
-                {
-                    target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
-                    if ( target_unit_ptr == 0 )
-                    {
-                        clearFsmGunneryTarget();
-                        aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                        end_cycle = true;
-                    }
-                    else
-                    {
-                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
-                        {
-                            clearFsmGunneryTarget();
-                            aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                            end_cycle = true;
-                        } // ** if
-                        else
-                        {
-                            range_vector = target_unit_state-&gt;location - unit_state.location;
-                            if ( range_vector.mag2() &gt; unit_state.defend_range )
-                            {
-                                clearFsmGunneryTarget();
-                                aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                                end_cycle = true;
-                            }
-                        } 
-                    }
-                }
-                end_cycle = true;
-            }
-            break;
-        } // ** switch
-
-    } while ( end_cycle == false );
-
-}
-
-
-
-
-
-void Vehicle::aiFsmManualMove()
-{
-    bool end_cycle = false;
-    signed char offset_x = 0, offset_y = 0;
-    size_t next_square;
-
-    do
-    {
-        switch( aiFsmManualMove_state )
-        {
-            case _aiFsmManualMove_next_move :
-            {
-                aiFsmManualMove_prev_loc = aiFsmManualMove_next_loc;
-                orientationToOffset( aiFsmManualMove_move_orientation, &amp;offset_x, &amp;offset_y );
-                aiFsmManualMove_next_loc.x += offset_x;
-                aiFsmManualMove_next_loc.y += offset_y;
-                next_square = MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
-
-                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                }
-                else if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                }
-                else
-                {
-                    UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
-                    setFsmMoveMapSquare( next_square );
-                    aiFsmManualMove_state = _aiFsmManualMove_move_wait;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_move_wait :
-            {
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_prev_loc );
-                    aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
-                    end_cycle = true;
-                }
-                else
-                {
-                    end_cycle = true;
-                } // ** else
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmManualMove_state = _aiFsmManualMove_next_move;
-                }
-            }
-            break;
-
-        } // ** switch
-    } while ( end_cycle == false );
-
-}
-
-void Vehicle::fireWeapon( iXY &amp;target_loc )
-{
-    reload_counter = 0;
-
-    unsigned short projectile_type = launchProjectile();
-    ProjectileInterface::newProjectile(projectile_type, unit_state.unit_type, id,
-                                       unit_state.damage_factor,
-                                       unit_state.location,
-                                       target_loc
-                                      );
-
-    if ( NetworkState::status == _network_state_server ) {
-        FireWeaponOpcode fire_opcode;
-        fire_opcode.opcode = _UNIT_OPCODE_FIRE_WEAPON;
-        fire_opcode.setUnitID(id);
-        fire_opcode.setTarget(target_loc);
-        UnitInterface::sendOpcode(&amp;fire_opcode);
-    }
-}
-
-//-----------------------------------------------------------------
-void Vehicle::soundSelected()
-{
-        sound-&gt;playSound( soundSelect.size()?soundSelect.c_str():&quot;yessir&quot;);
-}
-
-void Vehicle::accessThreatLevels()
-{
-    if ( unit_state.threat_level == _threat_level_under_attack )
-    {
-        if( threat_level_under_attack_timer.count() )
-        {
-            unit_state.threat_level = _threat_level_all_clear;
-        }
-    }
-
-}
-
-//-----------------------------------------------------------------
-unsigned short Vehicle::launchProjectile()
-{
-    long distance = WorldViewInterface::getCameraDistance(unit_state.location);
-    sound-&gt;playAmbientSound(fireSound.c_str(), distance );
-    sound-&gt;playBattle();
-    
-    return weaponType;
-}
-
-//-----------------------------------------------------------------
-void Vehicle::updateFsmState()
-{
-    if ( fsm_timer.count() ) {
-        if ( fsm_active_list[ _control_move_map_square ] == true )
-            fsmMoveMapSquare();
-
-        if ( fsm_active_list[ _control_turret_track_point ] == true )
-            fsmTurretTrackPoint();
-
-        if ( fsm_active_list[ _control_turret_track_target ] == true )
-            fsmTurretTrackTarget();
-
-        if ( fsm_active_list[ _control_gunnery_location ] == true )
-            fsmGunneryLocation();
-
-        if ( fsm_active_list[ _control_gunnery_target ] == true )
-            fsmGunneryTarget();
-    }
-}
-
-
-void Vehicle::updateAIState()
-{
-    switch(ai_command_state)
-    {
-        case _ai_command_idle:
-            aiFsmIdle();
-            break;
-
-        case _ai_command_defend_hold:
-            aiFsmDefendHold();
-            break;
-
-        case _ai_command_move_to_loc:
-            aiFsmMoveToLoc();
-            break;
-
-        case _ai_command_attack_unit:
-            aiFsmAttackUnit();
-            break;
-
-        case _ai_command_manual_move:
-            aiFsmManualMove();
-            break;
-    }
-}
-
-
-void Vehicle::checkPendingAICommStatus()
-{
-    if ( (pending_AI_comm == true) &amp;&amp;
-            (ai_fsm_transition_complete == true) )
-    {
-        pending_AI_comm = false;
-        ai_fsm_transition_complete = false;
-
-        if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
-        {
-            switch( pending_AI_comm_mesg.command )
-            {
-                case _command_move_to_loc :
-                    setCommandMoveToLoc( &amp;pending_AI_comm_mesg );
-                    break;
-
-                case _command_attack_unit :
-                    setCommandAttackUnit( &amp;pending_AI_comm_mesg );
-                    break;
-
-                case _command_start_manual_move :
-                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                    break;
-
-                case _command_stop_manual_move :
-                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                    break;
-            } // ** switch
-
-        } // ** unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE
-
-    } // ** if
-
-}
-
-void Vehicle::setCommandMoveToLoc(const UMesgAICommand* message)
-{
-    iXY start;
-
-    if ( fsm_active_list[ _control_gunnery_location ] == true )
-    {
-        clearFsmGunneryLocation();
-    }
-
-    aiFsmMoveToLoc_goal = message-&gt;getGoalLoc();
-    ai_command_state = _ai_command_move_to_loc;
-    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-    aiFsmMoveToLoc_path_not_finished = true;
-    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-
-    opcode_move_timer.changePeriod( 0.10f );
-    move_opcode_sent = false;
-    //move_opcode_sent = true;
-
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-
-    //LOG( (&quot;UnitID %d, %d : Start %d, %d : Goal %d, %d&quot;, id.getPlayer(), id.getIndex(),
-    //                                                    start.x, start.y,
-    //                                                    aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
-
-    PathRequest path_request;
-    path_request.set( id, start, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
-    PathScheduler::requestPath( path_request );
-
-    iXY target;
-    MapInterface::mapXYtoPointXY( aiFsmMoveToLoc_goal, &amp;target);
-    setFsmTurretTrackPoint( target );
-}
-
-void Vehicle::setCommandAttackUnit(const UMesgAICommand* message)
-{
-    iXY start;
-    UnitBase *target_unit_ptr;
-    UnitState *target_unit_state;
-
-    aiFsmAttackUnit_target_ID = message-&gt;getTargetUnitID();
-
-    target_unit_ptr = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
-    if ( target_unit_ptr == 0 )
-        return;
-
-    target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-
-    ai_command_state = _ai_command_attack_unit;
-
-    aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-    aiFsmAttackUnit_path_not_finished = true;
-    aiFsmAttackUnit_target_destroyed = false;
-
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
-
-    PathRequest path_request;
-    path_request.set( id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
-    PathScheduler::requestPath( path_request );
-
-    opcode_move_timer.changePeriod( 0.10f );
-    move_opcode_sent = false;
-    //move_opcode_sent = true;
-
-    setFsmGunneryTarget( aiFsmAttackUnit_target_ID );
-}
-
-void Vehicle::setCommandManualMove(const UMesgAICommand* message)
-{
-    if ( message-&gt;command == _command_start_manual_move )
-    {
-        aiFsmManualMove_move_orientation = message-&gt;manual_move_orientation;
-        MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmManualMove_next_loc );
-        aiFsmManualMove_state = _aiFsmManualMove_next_move;
-        ai_command_state = _ai_command_manual_move;
-    }
-    else if ( message-&gt;command == _command_stop_manual_move )
-    {
-        ai_command_state = _ai_command_idle;
-    }
-}
-
-void Vehicle::setCommandManualFire(const UMesgAICommand* message)
-{
-    setFsmGunneryLocation(message-&gt;getTargetLoc());
-}
-
-void Vehicle::messageAICommand(const UnitMessage* message)
-{
-    const UMesgAICommand *command_mesg = (const UMesgAICommand *) message;
-
-    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
-    {
-        if (command_mesg-&gt;command == _command_manual_fire)
-        {
-            setCommandManualFire( command_mesg );
-        }
-        else
-        {
-            memcpy(&amp;pending_AI_comm_mesg, command_mesg, sizeof(UMesgAICommand));
-            pending_AI_comm = true;
-        }
-    }
-}
-
-
-void Vehicle::messageWeaponHit(const UnitMessage *message)
-{
-    const UMesgWeaponHit *weapon_hit = (const UMesgWeaponHit *) message;
-
-    if (!unit_state.bounds(weapon_hit-&gt;getHitLocation()))
-        return;
-    
-    unit_state.hit_points -= weapon_hit-&gt;getDamageFactor();
-    unit_state.threat_level = _threat_level_under_attack;
-    threat_level_under_attack_timer.changePeriod(
-            gameconfig-&gt;attacknotificationtime);
-
-    UpdateStateUnitOpcode update_state_opcode;
-
-    update_state_opcode.setUnitID(id);
-    update_state_opcode.setHitPoints(unit_state.hit_points);
-    UnitInterface::sendOpcode( &amp;update_state_opcode );
-
-    if ( unit_state.hit_points &lt;= 0 )
-    {
-        unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
-        external_ai_event = _external_event_pending_unit_destruct;
-
-        UMesgEndLifeCycleUpdate lifecycle_update;
-        lifecycle_update.set(id, weapon_hit-&gt;getOwnerUnitID(),
-                unit_state.unit_type);
-        UnitInterface::sendMessage(&amp;lifecycle_update);
-
-        // ** Note: Temp
-        iXY current_map_loc;
-        MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
-        UnitBlackBoard::unmarkUnitLoc(current_map_loc);
-    }
-}
-
-void Vehicle::messageSelectBoxUpdate(const UnitMessage* message)
-{
-    const UMesgUpdateSelectBoxInfo *select_box_update 
-        = (const UMesgUpdateSelectBoxInfo *) message;
-
-    switch (select_box_update-&gt;request_type)
-    {
-        case _select_box_allie_visibility:
-        {
-            select_info_box.setAllieIcon(select_box_update-&gt;allie_flag_visiblity );
-            break;
-        }
-        break;
-
-        case _select_box_flag_visiblity:
-        {
-            select_info_box.setFlagIcon( select_box_update-&gt;flag_visiblity );
-            break;
-        }
-
-        case _select_box_is_allied:
-        {
-            select_info_box.setAllieState( select_box_update-&gt;allied_state );
-            break;
-        }
-    }
-}
-
-void Vehicle::messageSelfDestruct(const UnitMessage* )
-{
-    unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
-    external_ai_event = _external_event_pending_unit_destruct;
-
-    // ** Note: Temp
-    iXY current_map_loc;
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
-}
-
-void Vehicle::processMessage(const UnitMessage* message)
-{
-    if (unit_state.lifecycle_state != _UNIT_LIFECYCLE_ACTIVE)
-        return;
-    
-    switch(message-&gt;message_id)
-    {
-        case _umesg_ai_command:
-            messageAICommand(message);
-            break;
-
-        case _umesg_weapon_hit:
-            messageWeaponHit(message);
-            break;
-
-        case _umesg_update_select_box_info:
-            messageSelectBoxUpdate(message);
-            break;
-
-        case _umesg_self_destruct:
-            messageSelfDestruct(message);
-            break;
-
-        default:
-            LOGGER.warning(&quot;Unknown unit message (id %d)&quot;,
-                    message-&gt;message_id);
-            break;
-    }
-}
-
-void Vehicle::unitOpcodeMove(const UnitOpcode* opcode)
-{
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
-    const MoveOpcode* move_opcode = (const MoveOpcode *) opcode;
-
-    iXY sync_loc;
-    iXY current_loc;
-
-    MapInterface::offsetToMapXY(move_opcode-&gt;getSquare(), &amp;sync_loc );
-    sync_loc.x = sync_loc.x + move_opcode-&gt;loc_x_offset;
-    sync_loc.y = sync_loc.y + move_opcode-&gt;loc_y_offset;
-
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
-
-    if ( current_loc != sync_loc )
-    {
-        MapInterface::mapXYtoPointXY( sync_loc, &amp;(unit_state.location) );
-    }
-
-    setFsmMoveMapSquare(move_opcode-&gt;getSquare());
-}
-
-void Vehicle::unitOpcodeTrackPoint(const UnitOpcode* opcode )
-{
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
-    const TurretTrackPointOpcode* track_point_opcode 
-        = (const TurretTrackPointOpcode *) opcode;
-
-    if ( track_point_opcode-&gt;activate == true )
-    {
-        iXY target = track_point_opcode-&gt;getTarget();
-        setFsmTurretTrackPoint( target );
-    }
-    else
-    {
-        fsm_active_list[ _control_turret_track_point ] = false;
-    }
-
-}
-
-void Vehicle::unitOpcodeTrackTarget(const UnitOpcode* opcode )
-{
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
-    const TurretTrackTargetOpcode* track_target_opcode 
-        = (const TurretTrackTargetOpcode *) opcode;
-
-    if ( track_target_opcode-&gt;activate == true )
-    {
-        setFsmTurretTrackTarget( track_target_opcode-&gt;getTargetUnitID() );
-    }
-    else
-    {
-        fsm_active_list[ _control_turret_track_target ] = false;
-    }
-
-}
-
-void Vehicle::unitOpcodeFireWeapon(const UnitOpcode* opcode )
-{
-    iXY target_loc;
-
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
-    const FireWeaponOpcode *fire_weapon = (const FireWeaponOpcode *) opcode;
-    target_loc = fire_weapon-&gt;getTarget();
-    fireWeapon( target_loc );
-}
-
-void Vehicle::unitOpcodeSync(const UnitOpcode* )
-{
-    in_sync_flag = true;
-}
-
-void Vehicle::unitOpcodeUpdateState(const UnitOpcode* opcode )
-{
-    const UpdateStateUnitOpcode *update_state_opcode
-        = (const UpdateStateUnitOpcode *) opcode;
-
-    unit_state.hit_points = update_state_opcode-&gt;getHitPoints();
-
-    unit_state.threat_level = _threat_level_under_attack;
-    threat_level_under_attack_timer.changePeriod( 30 );
-}
-
-void Vehicle::unitOpcodeDestruct(const UnitOpcode* )
-{
-    unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
-}
-
-void Vehicle::syncUnit()
-{
-    syncFsmTurretTrackPoint();
-    syncFsmTurretTrackTarget();
-
-    SyncUnitOpcode sync_opcode;
-
-    sync_opcode.opcode = _UNIT_OPCODE_SYNC_UNIT;
-    sync_opcode.setUnitID(id);
-    UnitInterface::sendOpcode( &amp;sync_opcode );
-}
-
-
-void Vehicle::processMoveOpcodeQueue()
-{
-    if (!move_opcode_queue.empty())
-    {
-        if( fsm_active_list[ _control_move_map_square ] == false )
-        {
-            if ( move_opcode_queue.size() &gt;= 3 )
-            {
-                for( int i = 0; i &lt; 2; i++ )
-                {
-                    move_opcode_queue.pop();
-                }
-                //ConsoleInterface::postMessage( &quot;Move Opcode Queue Adjusted&quot; );
-            }
-            UnitOpcodeStruct opcodedata = move_opcode_queue.front();
-            move_opcode_queue.pop();
-            const UnitOpcode* opcode = (UnitOpcode*) &opcodedata; 
-            unitOpcodeMove(opcode);
-        }
-    }
-
-}
-
-void Vehicle::processOpcodeQueue()
-{
-    processMoveOpcodeQueue();
-
-    if (!opcode_queue.empty())
-    {
-        UnitOpcodeStruct opcodedata = opcode_queue.front();
-        const UnitOpcode* opcode = (UnitOpcode*) &opcodedata;
-
-        switch(opcode-&gt;opcode )
-        {
-            case _UNIT_OPCODE_TURRET_TRACK_POINT:
-                unitOpcodeTrackPoint(opcode);
-                break;
-
-            case _UNIT_OPCODE_TURRET_TRACK_TARGET:
-                unitOpcodeTrackTarget(opcode);
-                break;
-
-            case _UNIT_OPCODE_FIRE_WEAPON:
-                unitOpcodeFireWeapon(opcode);
-                break;
-
-            case _UNIT_OPCODE_SYNC_UNIT:
-                unitOpcodeSync(opcode);
-                break;
-
-            case _UNIT_OPCODE_UPDATE_STATE:
-                unitOpcodeUpdateState(opcode);
-                break;
-
-            case _UNIT_OPCODE_DESTRUCT:
-                unitOpcodeDestruct(opcode);
-                break;
-
-            default:
-                LOGGER.warning(&quot;Unknown Opcode: %d.\n&quot;, opcode-&gt;opcode);
-                assert(false);
-                break;
-        }
-        opcode_queue.pop();
-    }
-}
-
-void Vehicle::evalCommandOpcode(const UnitOpcode* opcode)
-{
-    if (opcode-&gt;opcode == _UNIT_OPCODE_MOVE)
-    {
-        move_opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
-    }
-    else
-    {
-        opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
-    }
-}
-
-void Vehicle::updateState()
-{
-    updateFsmState();
-
-    if ( NetworkState::status == _network_state_server )
-    {
-        if( unit_state_timer.count() )
-            updateUnitStateProperties();
-
-        updateAIState();
-        checkPendingAICommStatus();
-    }
-    else
-    {
-        processOpcodeQueue();
-    }
-
-    accessThreatLevels();
-
-    if( unit_state.hit_points &lt; unit_state.max_hit_points )
-    {
-        smolderWait += TimerInterface::getTimeSlice();
-
-        int intPercent = unit_state.percentDamageInt();
-
-        if (intPercent &gt; 50 &amp;&amp; (rand() % 100) &lt; intPercent)
-        {
-            if (smolderWait &gt; smolderWaitMin)
-            {
-                float percent = unit_state.percentDamageFloat();
-
-                smolderWaitMin  = (float(100 - percent) / 100.0) + (float(100 - percent) / 100.0) * 0.3;
-
-                ParticleInterface::addUnitDamagePuffParticle(unit_state);
-
-                smolderWait = 0.0f;
-            }
-        }
-    }
-}
-
-
-void Vehicle::offloadGraphics( SpriteSorter &amp;sorter )
-{
-    body_anim_shadow.setWorldPos( unit_state.location);
-
-    if ( sorter.cullSprite( body_anim_shadow ) == false )
-    {
-        // Body
-        body_anim.setWorldPos( unit_state.location );
-        body_anim.setFrame( unit_state.body_angle.angle_int );
-
-        // Turret
-        turret_anim.setWorldPos( unit_state.location );
-        turret_anim.setFrame( unit_state.turret_angle.angle_int );
-
-        // Body Shadow
-        body_anim_shadow.setFrame( unit_state.body_angle.angle_int );
-
-        // Turret Shadow
-        turret_anim_shadow.setWorldPos( unit_state.location );
-        turret_anim_shadow.setFrame( unit_state.turret_angle.angle_int );
-
-        select_info_box.setBoxState( unit_state.select );
-
-        //Added layer selection to the selection box info.
-        select_info_box.setAttrib( unit_state.location,
-                gameconfig-&gt;unitinfodrawlayer );
-        select_info_box.setHitPoints( unit_state.hit_points );
-
-        sorter.forceAddSprite( &amp;body_anim_shadow );
-    }
-
-    //sorter.addSprite( &amp;body_anim_shadow );
-}

Deleted: trunk/netpanzer/src/NetPanzer/Units/Vehicle.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.hpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Units/Vehicle.hpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -1,261 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _VEHICLE_HPP
-#define _VEHICLE_HPP
-#include &lt;string&gt;
-
-#include &quot;Units/UnitBase.hpp&quot;
-#include &quot;Util/Timer.hpp&quot;
-#include &quot;Classes/UnitMessageTypes.hpp&quot;
-#include &quot;Units/UnitOpcodes.hpp&quot;
-#include &quot;Classes/AI/PathList.hpp&quot;
-
-#include &quot;Classes/Sprite.hpp&quot;
-#include &quot;Classes/SelectionBoxSprite.hpp&quot;
-
-enum { _control_idle,
-       _control_move,
-       _control_move_map_square,
-       _control_turret_track_point,
-       _control_turret_track_target,
-       _control_gunnery_location,
-       _control_gunnery_target    };
-
-enum { _ai_command_idle,
-       _ai_command_move_to_loc,
-       _ai_command_attack_unit,
-       _ai_command_manual_move,
-       _ai_command_defend_hold };
-
-enum { _aiFsmMoveToLoc_path_generate,
-       _aiFsmMoveToLoc_check_goal,
-       _aiFsmMoveToLoc_next_move,
-       _aiFsmMoveToLoc_move_wait,
-       _aiFsmMoveToLoc_wait_clear_loc,
-       _aiFsmMoveToLoc_check_fsm_transition };
-
-enum { _aiFsmAttackUnit_path_generate,
-       _aiFsmAttackUnit_range_check,
-       _aiFsmAttackUnit_idle,
-       _aiFsmAttackUnit_next_move,
-       _aiFsmAttackUnit_move_wait,
-       _aiFsmAttackUnit_wait_clear_loc,
-       _aiFsmAttackUnit_check_fsm_transition,
-       _aiFsmAttackUnit_check_path_deviation };
-
-enum { _aiFsmDefendHold_search_for_enemy,
-       _aiFsmDefendHold_attack_enemy };
-
-enum { _aiFsmManualMove_next_move,
-       _aiFsmManualMove_move_wait,
-       _aiFsmManualMove_check_fsm_transition };
-
-enum { _external_event_null,
-       _external_event_pending_unit_destruct };
-
-enum { _rotate_pos, _rotate_neg };
-
-class Vehicle : public UnitBase
-{
-protected:
-    SpritePacked body_anim;
-    SpritePacked turret_anim;
-
-    SpritePacked body_anim_shadow;
-    SpritePacked turret_anim_shadow;
-
-    UnitSelectionBox select_info_box;
-    
-    std::string soundSelect;
-    std::string fireSound;
-    unsigned short weaponType;
-
-    Timer unit_state_timer;
-    Timer fsm_timer;
-    bool fsm_active_list[ 7 ];
-
-    PathList path;
-    bool path_generated;
-    bool critical_ai_section;
-    bool ai_fsm_transition_complete;
-
-    unsigned short reload_counter;
-    unsigned short death_counter;
-    void updateUnitStateProperties();
-
-    unsigned char ai_command_state;
-    unsigned char external_ai_event;
-
-
-    unsigned short shortestRotation( AngleInt &amp;angle, long goal_angle, long *delta );
-    unsigned short mapXYtoOrientation( unsigned long square, long *goal_angle  );
-    void orientationToOffset( unsigned short orientation, signed char *offset_x, signed char *offset_y );
-    void locationOffset( unsigned long square, iXY &amp;offset );
-
-    // ** FSMs and AI FSMs
-    unsigned short fsmBodyRotate_rotation;
-    long           fsmBodyRotate_goal_angle;
-    void    setFsmBodyRotate( long goal_angle, unsigned short rotation );
-    bool fsmBodyRotate();
-
-    unsigned short fsmTurretRotate_rotation;
-    long           fsmTurretRotate_goal_angle;
-    void    setFsmTurretRotate( long goal_angle, unsigned short rotation );
-    bool fsmTurretRotate();
-
-    float interpolation_speed;
-    TimeStamp start_move_stamp;
-    TimeStamp end_move_stamp;
-    bool     fsmMove_first_stamp;
-    signed char fsmMove_offset_x;
-    signed char fsmMove_offset_y;
-    unsigned char fsmMove_moves_counter;
-    unsigned char fsmMove_moves_per_square;
-    void setFsmMove( unsigned short orientation );
-    bool fsmMove();
-
-    MoveOpcode move_opcode;
-    Timer opcode_move_timer;
-    bool move_opcode_sent;
-    unsigned char fsmMoveMapSquare_movement_type;
-    void setFsmMoveMapSquare( unsigned long square );
-    bool fsmMoveMapSquare();
-
-    iXY fsmTurretTrackPoint_target;
-    Angle fsmTurretTrackPoint_target_angle;
-    bool fsmTurretTrackPoint_on_target;
-    void setFsmTurretTrackPoint(const iXY&amp; target );
-    void clearFsmTurretTrackPoint();
-    void syncFsmTurretTrackPoint();
-    void fsmTurretTrackPoint();
-
-    UnitID fsmTurretTrackTarget_target_id;
-    bool fsmTurretTrackTarget_on_target;
-    void setFsmTurretTrackTarget(UnitID target_id);
-    void clearFsmTurretTrackTarget();
-    void syncFsmTurretTrackTarget();
-    void fsmTurretTrackTarget();
-
-    iXY fsmGunneryLocation_target;
-    void setFsmGunneryLocation(const iXY&amp; target );
-    void clearFsmGunneryLocation();
-    void fsmGunneryLocation();
-
-    UnitID fsmGunneryTarget_target_id;
-    void setFsmGunneryTarget(UnitID target_id);
-    void clearFsmGunneryTarget();
-    void fsmGunneryTarget();
-
-    void aiFsmIdle();
-
-    unsigned char aiFsmDefendHold_state;
-    Timer	  aiFsmDefendHold_search_timer;
-    UnitID  aiFsmDefendHold_target_ID;
-    void setAiFsmDefendHold();
-    void aiFsmDefendHold();
-
-    iXY aiFsmMoveToLoc_goal;
-    unsigned char aiFsmMoveToLoc_state;
-    unsigned long aiFsmMoveToLoc_next_square;
-    iXY aiFsmMoveToLoc_next_loc;
-    iXY aiFsmMoveToLoc_prev_loc;
-    Timer	   aiFsmMoveToLoc_wait_timer;
-    bool  aiFsmMoveToLoc_path_not_finished;
-    bool ruleMoveToLoc_GoalReached();
-    void aiFsmMoveToLoc_OnExitCleanUp();
-    void aiFsmMoveToLoc();
-
-    UnitID   aiFsmAttackUnit_target_ID;
-    iXY aiFsmAttackUnit_target_goal_loc;
-    unsigned char aiFsmAttackUnit_state;
-    unsigned long aiFsmAttackUnit_next_square;
-    iXY aiFsmAttackUnit_next_loc;
-    iXY aiFsmAttackUnit_prev_loc;
-    Timer	   aiFsmAttackUnit_wait_timer;
-    bool  aiFsmAttackUnit_path_not_finished;
-    bool  aiFsmAttackUnit_target_destroyed;
-    void aiFsmAttackUnit_OnExitCleanUp();
-    void aiFsmAttackUnit();
-
-
-    unsigned char aiFsmManualMove_move_orientation;
-    unsigned char aiFsmManualMove_state;
-    iXY aiFsmManualMove_next_loc;
-    iXY aiFsmManualMove_prev_loc;
-    void aiFsmManualMove();
-
-    void fireWeapon( iXY &amp;target_loc );
-    virtual unsigned short launchProjectile();
-    virtual void soundSelected();
-
-    TimerFrameBase threat_level_under_attack_timer;
-    void accessThreatLevels();
-
-    void updateFsmState();
-    void updateAIState();
-
-    // ** Opcode Functions
-    void unitOpcodeMove(const UnitOpcode* opcode );
-    void unitOpcodeTrackPoint(const UnitOpcode* opcode );
-    void unitOpcodeTrackTarget(const UnitOpcode* opcode );
-    void unitOpcodeFireWeapon(const UnitOpcode* opcode );
-    void unitOpcodeSync(const UnitOpcode* opcode );
-    void unitOpcodeUpdateState(const UnitOpcode* opcode );
-    void unitOpcodeDestruct(const UnitOpcode* opcode );
-
-    UnitOpcodeQueue opcode_queue;
-    UnitOpcodeQueue move_opcode_queue;
-    void processMoveOpcodeQueue();
-    void processOpcodeQueue();
-
-    // ** Message Handlers
-    UMesgAICommand pending_AI_comm_mesg;
-    bool	     pending_AI_comm;
-    void checkPendingAICommStatus();
-
-    void setCommandMoveToLoc(const UMesgAICommand* message);
-    void setCommandAttackUnit(const UMesgAICommand* message);
-    void setCommandManualMove(const UMesgAICommand* message);
-    void setCommandManualFire(const UMesgAICommand* message);
-
-    void messageAICommand(const UnitMessage* message);
-    void messageWeaponHit(const UnitMessage* message);
-    void messageSelectBoxUpdate(const UnitMessage* message);
-    void messageSelfDestruct(const UnitMessage* message);
-    
-    void setUnitProperties( unsigned char utype );
-
-public:
-    Vehicle(PlayerState* player, unsigned char utype, UnitID id, iXY initial_loc);
-
-    virtual void updateState();
-
-    virtual void processMessage(const UnitMessage* message);
-
-    virtual void evalCommandOpcode(const UnitOpcode* opcode);
-
-    virtual void syncUnit();
-
-    virtual void offloadGraphics( SpriteSorter &amp;sorter );
-
-    float smolderWait;
-    float smolderWaitMin;
-};
-
-
-#endif // ** _VEHICLE_HPP

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-02-17 15:44:20 UTC (rev 1092)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-02-21 02:34:05 UTC (rev 1093)
@@ -37,6 +37,7 @@
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;PowerUps/EnemyRadarPowerUp.hpp&quot;
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
+#include &quot;Units/Unit.hpp&quot;
 
 MiniMap::MiniMap(int x, int y, int w, int h) : mousepos(0,0)
 {
@@ -227,7 +228,7 @@
     for(UnitInterface::Units::const_iterator i = units.begin();
             i != units.end(); ++i)
     {
-        UnitBase* unit = i-&gt;second;
+        Unit* unit = i-&gt;second;
         PIX color;
         bool forceLarge = false;
         UnitState&amp; unit_state = unit-&gt;unit_state;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000124.html">[Netpanzer-cvs] r1092 - in trunk/netpanzer: nbproject	src/NetPanzer/Classes src/NetPanzer/Interfaces	src/NetPanzer/Particles src/NetPanzer/Views/Components	src/NetPanzer/Views/Game src/NetPanzer/Views/MainMenu	src/NetPanzer/Views/MainMenu/Options
</A></li>
	<LI>Next message: <A HREF="000126.html">[Netpanzer-cvs] r1094 - trunk/netpanzer/src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#125">[ date ]</a>
              <a href="thread.html#125">[ thread ]</a>
              <a href="subject.html#125">[ subject ]</a>
              <a href="author.html#125">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
