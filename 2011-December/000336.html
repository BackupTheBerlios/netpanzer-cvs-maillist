<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1310 - in branches: . newpath	newpath/src/Lib/Types newpath/src/Lib/Util	newpath/src/NetPanzer/Bot newpath/src/NetPanzer/Classes	newpath/src/NetPanzer/Classes/AI	newpath/src/NetPanzer/Classes/Network	newpath/src/NetPanzer/Interfaces newpath/src/NetPanzer/Objectives	newpath/src/NetPanzer/PowerUps newpath/src/NetPanzer/Units	newpath/src/NetPanzer/Views/Components	newpath/src/NetPanzer/Views/Game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2011-December/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1310%20-%20in%20branches%3A%20.%20newpath%0A%09newpath/src/Lib/Types%20newpath/src/Lib/Util%0A%09newpath/src/NetPanzer/Bot%20newpath/src/NetPanzer/Classes%0A%09newpath/src/NetPanzer/Classes/AI%0A%09newpath/src/NetPanzer/Classes/Network%0A%09newpath/src/NetPanzer/Interfaces%20newpath/src/NetPanzer/Objectives%0A%09newpath/src/NetPanzer/PowerUps%20newpath/src/NetPanzer/Units%0A%09newpath/src/NetPanzer/Views/Components%0A%09newpath/src/NetPanzer/Views/Game&In-Reply-To=%3C20111221165247.1CE00481510%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000335.html">
   <LINK REL="Next"  HREF="000337.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1310 - in branches: . newpath	newpath/src/Lib/Types newpath/src/Lib/Util	newpath/src/NetPanzer/Bot newpath/src/NetPanzer/Classes	newpath/src/NetPanzer/Classes/AI	newpath/src/NetPanzer/Classes/Network	newpath/src/NetPanzer/Interfaces newpath/src/NetPanzer/Objectives	newpath/src/NetPanzer/PowerUps newpath/src/NetPanzer/Units	newpath/src/NetPanzer/Views/Components	newpath/src/NetPanzer/Views/Game</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1310%20-%20in%20branches%3A%20.%20newpath%0A%09newpath/src/Lib/Types%20newpath/src/Lib/Util%0A%09newpath/src/NetPanzer/Bot%20newpath/src/NetPanzer/Classes%0A%09newpath/src/NetPanzer/Classes/AI%0A%09newpath/src/NetPanzer/Classes/Network%0A%09newpath/src/NetPanzer/Interfaces%20newpath/src/NetPanzer/Objectives%0A%09newpath/src/NetPanzer/PowerUps%20newpath/src/NetPanzer/Units%0A%09newpath/src/NetPanzer/Views/Components%0A%09newpath/src/NetPanzer/Views/Game&In-Reply-To=%3C20111221165247.1CE00481510%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1310 - in branches: . newpath	newpath/src/Lib/Types newpath/src/Lib/Util	newpath/src/NetPanzer/Bot newpath/src/NetPanzer/Classes	newpath/src/NetPanzer/Classes/AI	newpath/src/NetPanzer/Classes/Network	newpath/src/NetPanzer/Interfaces newpath/src/NetPanzer/Objectives	newpath/src/NetPanzer/PowerUps newpath/src/NetPanzer/Units	newpath/src/NetPanzer/Views/Components	newpath/src/NetPanzer/Views/Game">kromxp at mail.berlios.de
       </A><BR>
    <I>Wed Dec 21 17:52:46 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="000335.html">[Netpanzer-cvs] r1309 - in trunk/netpanzer: scripts	src/NetPanzer/Classes src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Views/Game support/icon
</A></li>
        <LI>Next message: <A HREF="000337.html">[Netpanzer-cvs] r1311 - in trunk/netpanzer: scripts	src/NetPanzer/Classes src/NetPanzer/Classes/Network	src/NetPanzer/Interfaces src/NetPanzer/Scripts support/icon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#336">[ date ]</a>
              <a href="thread.html#336">[ thread ]</a>
              <a href="subject.html#336">[ subject ]</a>
              <a href="author.html#336">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2011-12-21 17:52:46 +0100 (Wed, 21 Dec 2011)
New Revision: 1310

Added:
   branches/newpath/
Modified:
   branches/newpath/SConstruct
   branches/newpath/src/Lib/Types/iXY.hpp
   branches/newpath/src/Lib/Util/NTimer.hpp
   branches/newpath/src/NetPanzer/Bot/BotPlayer.cpp
   branches/newpath/src/NetPanzer/Classes/AI/Astar.cpp
   branches/newpath/src/NetPanzer/Classes/Network/NetPacketDebugger.cpp
   branches/newpath/src/NetPanzer/Classes/Network/ServerConnectDaemon.cpp
   branches/newpath/src/NetPanzer/Classes/Network/UnitNetMessage.hpp
   branches/newpath/src/NetPanzer/Classes/OpcodeDebugger.cpp
   branches/newpath/src/NetPanzer/Classes/UnitMessageTypes.hpp
   branches/newpath/src/NetPanzer/Classes/ViewCamera.cpp
   branches/newpath/src/NetPanzer/Classes/ViewCamera.hpp
   branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.hpp
   branches/newpath/src/NetPanzer/Interfaces/GameManager.cpp
   branches/newpath/src/NetPanzer/Interfaces/MapInterface.cpp
   branches/newpath/src/NetPanzer/Interfaces/MapInterface.hpp
   branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp
   branches/newpath/src/NetPanzer/Objectives/Objective.cpp
   branches/newpath/src/NetPanzer/Objectives/ObjectiveInterface.cpp
   branches/newpath/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
   branches/newpath/src/NetPanzer/PowerUps/PowerUp.cpp
   branches/newpath/src/NetPanzer/Units/UnitBase.hpp
   branches/newpath/src/NetPanzer/Units/UnitBlackBoard.cpp
   branches/newpath/src/NetPanzer/Units/UnitBlackBoard.hpp
   branches/newpath/src/NetPanzer/Units/UnitInterface.cpp
   branches/newpath/src/NetPanzer/Units/UnitInterface.hpp
   branches/newpath/src/NetPanzer/Units/UnitOpcodes.hpp
   branches/newpath/src/NetPanzer/Units/UnitState.cpp
   branches/newpath/src/NetPanzer/Units/UnitState.hpp
   branches/newpath/src/NetPanzer/Units/Vehicle.cpp
   branches/newpath/src/NetPanzer/Units/Vehicle.hpp
   branches/newpath/src/NetPanzer/Views/Components/MiniMap.cpp
   branches/newpath/src/NetPanzer/Views/Game/GameView.cpp
Log:
Commit current work in a branch to not lose track of changes

Modified: branches/newpath/SConstruct
===================================================================
--- trunk/netpanzer/SConstruct	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/SConstruct	2011-12-21 16:52:46 UTC (rev 1310)
@@ -57,8 +57,8 @@
 # Add options
 ################################################################
 
-opts = Options()
-opts.AddOptions(
+opts = Variables()
+opts.AddVariables(
     ('mode','set compile mode to debug or release','release'),
     ('datadir','define the extra directory where the netpanzer will look for data files, usefull for linux distributions, defaults to no extra directory',''),
     ('sdlconfig','sets the sdl-config full path', 'sdl-config'),
@@ -150,9 +150,9 @@
 
 env.Append(CCFLAGS = ['-Wall'])
 
-env.BuildDir(env['FINALBUILDDIR'],'.',duplicate=0)
-crossmingwenv.BuildDir(crossmingwenv['FINALBUILDDIR'],'.',duplicate=0)
-crosslinuxenv.BuildDir(crosslinuxenv['FINALBUILDDIR'],'.',duplicate=0)
+env.VariantDir(env['FINALBUILDDIR'],'.',duplicate=0)
+crossmingwenv.VariantDir(crossmingwenv['FINALBUILDDIR'],'.',duplicate=0)
+crosslinuxenv.VariantDir(crosslinuxenv['FINALBUILDDIR'],'.',duplicate=0)
 
 luaenv = env.Clone()
 physfsenv = env.Clone()

Modified: branches/newpath/src/Lib/Types/iXY.hpp
===================================================================
--- trunk/netpanzer/src/Lib/Types/iXY.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/Lib/Types/iXY.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -98,6 +98,12 @@
         return x != a.x || y != a.y;
     }
 
+    // this for moves only, if is not straight directions will need checking
+    bool operator&gt;=(const iXY &amp;a) const
+    {
+        return x &gt;= a.x &amp;&amp; y &gt;= a.y;
+    }
+
     // Negation.
     iXY operator -() const
     {

Modified: branches/newpath/src/Lib/Util/NTimer.hpp
===================================================================
--- trunk/netpanzer/src/Lib/Util/NTimer.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/Lib/Util/NTimer.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -36,9 +36,9 @@
 
     inline Uint32 getTimeOut()       { return timeout; }
     
-    inline bool isTimeOut() { return (SDL_GetTicks()-starttime)&gt;timeout; }
-    inline bool isTimeOut(Uint32 t) { return (t-starttime)&gt;timeout; }
-    inline bool checkWithTimeOut(Uint32 tout) { return (SDL_GetTicks()-starttime)&gt;tout; }
+    inline bool isTimeOut() { return (starttime+timeout)&lt;SDL_GetTicks(); }
+    inline bool isTimeOut(Uint32 t) { return (starttime+timeout)&lt;t; }
+    inline bool checkWithTimeOut(Uint32 tout) { return (starttime+tout)&lt;SDL_GetTicks(); }
     
 private:
     Uint32 starttime;

Modified: branches/newpath/src/NetPanzer/Bot/BotPlayer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Bot/BotPlayer.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -222,7 +222,7 @@
         iXY map_loc;
         MapInterface::pointXYtoMapXY(
                 outpost-&gt;location + occupation_pad_offset,
-                &amp;map_loc);
+                map_loc);
         moveUnit(unit, map_loc);
     }
 }

Modified: branches/newpath/src/NetPanzer/Classes/AI/Astar.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/AI/Astar.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -161,7 +161,7 @@
        )
         return 0xFFFFFFFF;
 
-    abs = MapInterface::mapXYtoOffset(map_loc.x, map_loc.y);
+    abs = MapInterface::mapXYtoOffset(map_loc);
 
     return abs;
 }

Modified: branches/newpath/src/NetPanzer/Classes/Network/NetPacketDebugger.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetPacketDebugger.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/Network/NetPacketDebugger.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -227,16 +227,6 @@
             log &lt;&lt; &quot;Attack: &quot; &lt;&lt; cmd.getTargetUnitID();
             break;
         }
-        case _command_start_manual_move:
-        {
-            log &lt;&lt; &quot;mmove: O:&quot; &lt;&lt; cmd.manual_move_orientation;
-            break;
-        }
-        case _command_stop_manual_move:
-        {
-            log &lt;&lt; &quot;stop mm&quot;;
-            break;
-        }
         case _command_manual_fire:
         {
             log &lt;&lt; &quot;MFire: &quot; &lt;&lt; cmd.getTargetLoc().x 

Modified: branches/newpath/src/NetPanzer/Classes/Network/ServerConnectDaemon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/ServerConnectDaemon.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/Network/ServerConnectDaemon.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -595,7 +595,7 @@
             }
 
             unit = i-&gt;second;
-            MapInterface::pointXYtoMapXY(unit-&gt;unit_state.location, &amp;unit_map_loc);
+            MapInterface::pointXYtoMapXY(unit-&gt;unit_state.location, unit_map_loc);
             UnitRemoteCreate urc(unit-&gt;player-&gt;getID(),
                                  unit-&gt;id,
                                  unit_map_loc.x,

Modified: branches/newpath/src/NetPanzer/Classes/Network/UnitNetMessage.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitNetMessage.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/Network/UnitNetMessage.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -54,57 +54,6 @@
     }
 } __attribute__((packed));
 
-
-class UnitIniSyncMessage : public NetMessage
-{
-public:
-    Uint8 unit_type;
-private:
-    PlayerID player_id;
-    Uint16 unit_id;
-    Uint32 location_x;
-    Uint32 location_y;
-public:
-    NetworkUnitState unit_state;
-
-    UnitIniSyncMessage(Uint8 unit_type, PlayerID player_id, UnitID unit_id,
-        Uint32 location_x, Uint32 location_y)
-    {
-        message_class = _net_message_class_unit;
-        message_id = _net_message_id_ini_sync_mesg;
-        this-&gt;unit_type = unit_type;
-        //this-&gt;player_id = htol16(player_id);
-        this-&gt;player_id = player_id;
-        this-&gt;unit_id = htol16(unit_id);
-        this-&gt;location_x = htol32(location_x);
-        this-&gt;location_y = htol32(location_y);
-    }
-      
-    unsigned short realSize() const
-    {
-        return( sizeof( UnitIniSyncMessage ) );
-    }
-    Uint32 getLocX() const
-    {
-        return ltoh32(location_x);
-    }
-    Uint32 getLocY() const
-    {
-        return ltoh32(location_y);
-    }
-
-    UnitID getUnitID() const
-    {
-        return ltoh16(unit_id);
-    }
-    PlayerID getPlayerID() const
-    {
-        return player_id;
-    }
-} __attribute__((packed));
-
-// ** NOTE: A big, mother fucking HACK
-
 class UnitRemoteDestroy : public NetMessage
 {
 private:

Modified: branches/newpath/src/NetPanzer/Classes/OpcodeDebugger.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/OpcodeDebugger.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/OpcodeDebugger.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -28,7 +28,7 @@
 void OpcodeDebugger::logOpcode(std::ostream&amp; log, UnitOpcode* opcode)
 {
     log &lt;&lt; &quot; UNIT:&quot; &lt;&lt; opcode-&gt;getUnitID()
-        &lt;&lt; &quot; FL:&quot; &lt;&lt; (int) opcode-&gt;flags &lt;&lt; &quot; &quot;;
+        &lt;&lt; &quot; &quot;;
     switch(opcode-&gt;opcode) {
         case _UNIT_OPCODE_MOVE:
         {
@@ -61,12 +61,6 @@
                 &lt;&lt; &quot; Y:&quot; &lt;&lt; weaponcode-&gt;getTarget().y;
             break;
         }
-        case _UNIT_OPCODE_SYNC_UNIT:
-        {
-            //SyncUnitOpcode* synccode = (SyncUnitOpcode*) opcode;
-            log &lt;&lt; &quot;sync&quot;;
-            break;
-        }
         case _UNIT_OPCODE_UPDATE_STATE:
         {
             UpdateStateUnitOpcode* updatecode = 

Modified: branches/newpath/src/NetPanzer/Classes/UnitMessageTypes.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/UnitMessageTypes.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/UnitMessageTypes.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -23,13 +23,10 @@
 enum { _umesg_ai_command,
        _umesg_weapon_hit,
        _umesg_end_lifecycle,
-       _umesg_update_select_box_info,
        _umesg_self_destruct };
 
 enum { _command_move_to_loc,
        _command_attack_unit,
-       _command_start_manual_move,
-       _command_stop_manual_move,
        _command_manual_fire };
 
 #ifdef MSVC
@@ -44,8 +41,6 @@
     Sint32 goal_loc_x;
     Sint32 goal_loc_y;
     Uint16 target_id;
-public:
-    Uint8 manual_move_orientation;
 private:
     Sint32 target_loc_x;
     Sint32 target_loc_y;
@@ -55,7 +50,6 @@
         command = 0;
         goal_loc_x = goal_loc_y = 0;
         target_id = 0;
-        manual_move_orientation = 0;
         target_loc_x = target_loc_y = 0;
     }
 
@@ -65,7 +59,6 @@
         command = 0;
         goal_loc_x = goal_loc_y = 0;
         target_id = 0;
-        manual_move_orientation = 0;
         target_loc_x = target_loc_y = 0;
     }
 
@@ -75,7 +68,6 @@
         command = _command_move_to_loc;
         goal_loc_x = htol32(goal.x);
         goal_loc_y = htol32(goal.y);
-        manual_move_orientation = 0;
     }
 
     void setTargetUnit(UnitID target)
@@ -83,30 +75,14 @@
         message_id = _umesg_ai_command;
         command = _command_attack_unit;
         target_id = htol16(target);
-        manual_move_orientation = 0;
     }
 
-    void setStartManualMove(unsigned char orientation)
-    {
-        message_id = _umesg_ai_command;
-        command = _command_start_manual_move;
-        manual_move_orientation = orientation;
-    }
-
-    void setStopManualMove()
-    {
-        message_id = _umesg_ai_command;
-        command = _command_stop_manual_move;
-        manual_move_orientation = 0;
-    }
-
     void setManualFire(const iXY&amp; target)
     {
         message_id = _umesg_ai_command;
         command = _command_manual_fire;
         target_loc_x = htol32(target.x);
         target_loc_y = htol32(target.y);
-        manual_move_orientation = 0;
     }
 
     iXY getGoalLoc() const
@@ -197,41 +173,6 @@
 }
 __attribute__((packed));
 
-enum { _select_box_allie_visibility,
-       _select_box_flag_visiblity,
-       _select_box_is_allied
-     };
-
-class UMesgUpdateSelectBoxInfo : public UnitMessage
-{
-public:
-    Uint8 request_type;
-    Uint8 allie_flag_visiblity;
-    Uint8 flag_visiblity;
-    Uint8 allied_state;
-
-    void set(unsigned char request, bool state_value)
-    {
-        message_id = _umesg_update_select_box_info;
-        request_type = request;
-        switch( request ) {
-        case _select_box_allie_visibility :
-            allie_flag_visiblity = state_value;
-            break;
-
-        case _select_box_flag_visiblity :
-            flag_visiblity = state_value;
-            break;
-
-        case _select_box_is_allied :
-            allied_state = state_value;
-            break;
-
-        } // ** switch
-    }
-}
-__attribute__((packed));
-
 class UMesgSelfDestruct : public UnitMessage
 {
 public:

Modified: branches/newpath/src/NetPanzer/Classes/ViewCamera.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/ViewCamera.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/ViewCamera.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -86,13 +86,13 @@
 
 void ViewCamera::getViewStart(unsigned long view_size_x,
 			      unsigned long view_size_y,
-                              unsigned long *view_start_x,
-			      unsigned long *view_start_y)
+                              int *view_start_x,
+                              int *view_start_y)
 {
     iXY map_size;
     unsigned long view_offset_x;
     unsigned long view_offset_y;
-    long start_x, start_y;
+    int start_x, start_y;
 
     view_offset_x = view_size_x &gt;&gt; 1;
     view_offset_y = view_size_y &gt;&gt; 1;

Modified: branches/newpath/src/NetPanzer/Classes/ViewCamera.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/ViewCamera.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/ViewCamera.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -46,11 +46,11 @@
     }
 
     void getViewStart( unsigned long view_size_x, unsigned long view_size_y,
-                       unsigned long *view_start_x, unsigned long *view_start_y );
+                       int *view_start_x, int *view_start_y );
 
     inline void getViewWindow( iRect *view_win )
     {
-        unsigned long view_start_x, view_start_y;
+        int view_start_x, view_start_y;
         getViewStart( view_size.x, view_size.y, &amp;view_start_x, &amp;view_start_y );
         view_win-&gt;min.x = view_start_x;
         view_win-&gt;min.y = view_start_y;

Modified: branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -195,21 +195,15 @@
         unsigned long id_list_index;
         size_t id_list_size;
         UnitBase *unit_ptr;
-        iXY range_vector;
 
         id_list_size = working_list.unit_list.size();
         for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ )
         {
             unit_ptr = UnitInterface::getUnit(working_list.unit_list[ id_list_index ]);
-            if ( unit_ptr != 0 )
+            if ( unit_ptr &amp;&amp; unit_ptr-&gt;isWeaponInRange(loc) )
             {
-                range_vector = loc - unit_ptr-&gt;unit_state.location;
-                if ( range_vector.mag2() &lt; unit_ptr-&gt;unit_state.weapon_range )
-                {
-                    fielddraws = true;
-                    return  _cursor_enemy_unit;
-                    break;
-                }
+                fielddraws = true;
+                return  _cursor_enemy_unit;
             }
         }
     }
@@ -218,7 +212,7 @@
     {
         return _cursor_blocked_target;
     }
-    MapInterface::pointXYtoMapXY( loc, &amp;map_loc );
+    MapInterface::pointXYtoMapXY( loc, map_loc );
 
     if (MapInterface::getMovementValue(map_loc) &gt;= 0xFF)
     {
@@ -886,7 +880,7 @@
     if ( id_list_size == 0 )
         return;
 
-    MapInterface::pointXYtoMapXY( world_pos, &amp;map_pos );
+    MapInterface::pointXYtoMapXY( world_pos, map_pos );
     matrix.reset( map_pos );
 
     NetMessageEncoder encoder;
@@ -984,56 +978,6 @@
 }
 
 void
-WorldInputCmdProcessor::sendManualMoveCommand(unsigned char orientation,
-        bool start_stop)
-{
-    TerminalUnitCmdRequest msg;
-    size_t id_list_index;
-    size_t id_list_size;
-    UnitBase *unit_ptr;
-
-    if ( working_list.unit_list.size() &gt; 0 ) {
-        id_list_size = working_list.unit_list.size();
-
-        NetMessageEncoder encoder;
-
-        for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ )
-        {
-            unit_ptr = UnitInterface::getUnit( working_list.unit_list[ id_list_index ] );
-            if ( unit_ptr != 0 ) {
-                if ( unit_ptr-&gt;unit_state.select == true )
-                {
-                    msg.comm_request.setHeader(unit_ptr-&gt;id,
-                            _umesg_flag_unique);
-                    if ( start_stop == true )
-                    {
-                        msg.comm_request.setStartManualMove( orientation );
-                    }
-                    else
-                    {
-                        msg.comm_request.setStopManualMove();
-                    }
-
-                    if ( !encoder.encodeMessage(&amp;msg, sizeof(msg)) )
-                    {
-                        CLIENT-&gt;sendMessage(encoder.getEncodedMessage(),
-                                            encoder.getEncodedLen());
-                        encoder.resetEncoder();
-                        encoder.encodeMessage(&amp;msg, sizeof(msg));
-                    }
-                }
-            }
-        }
-
-        if ( ! encoder.isEmpty() )
-        {
-            CLIENT-&gt;sendMessage(encoder.getEncodedMessage(),
-                                encoder.getEncodedLen());
-        }
-    }
-}
-
-void
 WorldInputCmdProcessor::sendManualFireCommand(const iXY &amp;world_pos)
 {
     if ( !actionTimer.isTimeOut() )
@@ -1222,15 +1166,15 @@
 //    iXY mappos;
 
 //    WorldViewInterface::clientXYtoWorldXY(world_win, mpos, &amp;wpos);
-//    MapInterface::pointXYtoMapXY( wpos, &amp;mappos );
+//    MapInterface::pointXYtoMapXY( wpos, mappos );
 
 //    iXY mappos2(mappos.x+1, mappos.y+1);
 
 //    iXY wp1, wp2;
 //    iXY r1, r2;
 
-//    MapInterface::mapXYtoPointXY(mappos,  &amp;wp1);
-//    MapInterface::mapXYtoPointXY(mappos2, &amp;wp2);
+//    MapInterface::mapXYtoPointXY(mappos,  wp1);
+//    MapInterface::mapXYtoPointXY(mappos2, wp2);
 
 //    wp1.x -= 16;
 //    wp1.y -= 16;

Modified: branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -64,8 +64,6 @@
 
     void getManualControlStatus();
 
-    void sendManualMoveCommand(unsigned char orientation,
-                                bool start_stop);
     void sendManualFireCommand(const iXY &amp;world_pos);
     void sendMoveCommand(const iXY &amp;world_pos);
     void sendAttackCommand(const iXY &amp;world_pos);

Modified: branches/newpath/src/NetPanzer/Interfaces/GameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Interfaces/GameManager.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -321,7 +321,7 @@
 
     //** Change the location of the view camera to the spawn point **
     iXY world_loc;
-    MapInterface::mapXYtoPointXY( spawn_point, &amp;world_loc );
+    MapInterface::mapXYtoPointXY( spawn_point, world_loc );
     if ( PlayerInterface::getLocalPlayerIndex() == player )
     {
         WorldViewInterface::setCameraPosition( world_loc );

Modified: branches/newpath/src/NetPanzer/Interfaces/MapInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Interfaces/MapInterface.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -157,7 +157,7 @@
 
 }
 
-unsigned char MapInterface::getMovementValue( iXY map_loc )
+unsigned char MapInterface::getMovementValue( const iXY&amp; map_loc )
 {
     unsigned short tile_val;
     char move_val;
@@ -195,16 +195,8 @@
 
 }
 
-unsigned char MapInterface::getAverageColorPointXY( iXY &amp;point_loc )
+unsigned char MapInterface::getAverageColorMapXY( const iXY&amp; map_loc )
 {
-    WorldMap::MapElementType map_value =
-        main_map.getValue(point_loc.x/32, point_loc.y/32);
-
-    return( tile_set.getAverageTileColor( map_value ) );
-}
-
-unsigned char MapInterface::getAverageColorMapXY( iXY &amp;map_loc )
-{
     unsigned short map_value;
 
     map_value = main_map.getValue( map_loc.x, map_loc.y );

Modified: branches/newpath/src/NetPanzer/Interfaces/MapInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Interfaces/MapInterface.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -95,106 +95,41 @@
         return main_map.getValue(offset);
     }
 
-    static void offsetToPointXY(size_t offset, size_t* point_x, size_t *point_y )
+    static size_t mapXYtoOffset(const iXY&amp; map_loc)
     {
-        *point_y = ( offset  /  main_map.getWidth() );
-
-        *point_x = ( offset - ( (*point_y) * main_map.getWidth() ) ) * TILE_WIDTH
-                   + (TILE_WIDTH / 2);
-
-        *point_y = (*point_y) * TILE_HEIGHT + (TILE_HEIGHT / 2);
+        return map_loc.y * main_map.getWidth() + map_loc.x;
     }
 
-    static void offsetToMapXY(size_t offset, size_t&amp; x, size_t&amp; y)
+    static void offsetToMapXY(size_t offset, iXY&amp; map_loc)
     {
-        y = offset / main_map.getWidth();
-        x = offset - y * main_map.getWidth();
+        map_loc.y = offset/main_map.getWidth();
+        map_loc.x = offset%main_map.getWidth();
     }
 
-    static void offsetToMapXY(size_t offset, iXY *map_loc)
-    {
-        size_t map_x, map_y;
-        offsetToMapXY(offset, map_x, map_y);
-        map_loc-&gt;x = map_x;
-        map_loc-&gt;y = map_y;
-    }
+    static int mapXtoPointX(const int x) { return (x*TILE_WIDTH) + (TILE_WIDTH/2); }
+    static int mapYtoPointY(const int y) { return (y*TILE_HEIGHT)+ (TILE_HEIGHT/2); }
 
-    static void mapXYtoPointXY(unsigned short map_x, unsigned short map_y,
-                               size_t *point_x, size_t *point_y )
+    static void mapXYtoPointXY(const iXY&amp; map_loc, iXY&amp; loc)
     {
-        iXY loc = mapXYtoPointXY(iXY(map_x, map_y));
-        *point_x = loc.x;
-        *point_y = loc.y;
+        loc.x = mapXtoPointX(map_loc.x);
+        loc.y = mapXtoPointX(map_loc.y);
     }
 
-    static void mapXYtoPointXY(iXY map_loc, iXY *loc)
+    static void mapXYtoTopPointXY(const iXY &amp;map_loc, iXY&amp; loc)
     {
-        *loc = mapXYtoPointXY(map_loc);
+        loc.x = map_loc.x * TILE_WIDTH;
+        loc.y = map_loc.y * TILE_HEIGHT;
     }
 
-    static iXY mapXYtoPointXY(iXY map_loc)
-    {
-#ifdef DEBUG
-        assert(inside(map_loc));
-#endif
-        return iXY((map_loc.x * TILE_WIDTH) + (TILE_WIDTH / 2),
-                (map_loc.y * TILE_HEIGHT) + (TILE_HEIGHT / 2));
-    }
-
-    static void pointXYtoMapXY(size_t point_x, size_t point_y,
-            unsigned short *map_x, unsigned short *map_y )
-    {
-        iXY mapxy = pointXYtoMapXY(iXY(point_x, point_y));
-        *map_x = mapxy.x;
-        *map_y = mapxy.y;
-    }
-
-    static void pointXYtoMapXY(const iXY&amp; point, iXY *map_loc)
-    {
-        *map_loc = pointXYtoMapXY(point);
-    }
-
-    static iXY pointXYtoMapXY(const iXY&amp; point)
-    {
-#ifdef DEBUG
-        assert(point.x &gt;= 0 &amp;&amp; point.x &gt;= 0 
-                &amp;&amp; point.x &lt; (int) (getWidth() * TILE_WIDTH)
-                &amp;&amp; point.y &lt; (int) (getHeight() * TILE_HEIGHT));
-#endif
-        return iXY(point.x / TILE_WIDTH, point.y / TILE_HEIGHT);
-    }
-
     static int pointXtoMapX(const int x) { return x/TILE_WIDTH; }
     static int pointYtoMapY(const int y) { return y/TILE_HEIGHT; }
 
-    static size_t mapXYtoOffset(size_t map_x, size_t map_y)
+    static void pointXYtoMapXY(const iXY&amp; point, iXY&amp; map_loc)
     {
-        return mapXYtoOffset(iXY(map_x, map_y));
+        map_loc.x = pointXtoMapX(point.x);
+        map_loc.y = pointYtoMapY(point.y);
     }
 
-    static size_t mapXYtoOffset(const iXY&amp; map_loc)
-    {
-        return map_loc.y * main_map.getWidth() + map_loc.x;
-    }
-
-    static void markLocHack(const iXY&amp; loc)
-    {
-        main_map.setMapValue(loc.x, loc.y, 27);
-    }
-
-    static void unmarkLocHack(const iXY&amp; loc)
-    {
-        main_map.setMapValue(loc.x, loc.y, 28);
-    }
-
-    static void normalizePointXY(size_t point_x, size_t point_y, size_t *norm_x, size_t *norm_y)
-    {
-        unsigned short map_x, map_y;
-
-        pointXYtoMapXY( point_x, point_y, &amp;map_x, &amp;map_y );
-        mapXYtoPointXY( map_x, map_y, norm_x, norm_y );
-    }
-
     static WorldMap* getMap()
     {
         return( &amp;main_map );
@@ -222,12 +157,10 @@
         return( main_map.isMapLoaded() );
     }
 
-    static unsigned char getMovementValue( iXY map_loc );
+    static unsigned char getMovementValue( const iXY&amp; map_loc );
 
-    static unsigned char getAverageColorPointXY( iXY &amp;point_loc );
+    static unsigned char getAverageColorMapXY( const iXY&amp; map_loc );
 
-    static unsigned char getAverageColorMapXY( iXY &amp;map_loc );
-
     static iXY getFreeSpawnPoint()
     {
         return spawn_list.getFreeSpawnPoint();

Modified: branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -210,7 +210,7 @@
                         path_request.path-&gt;popFirst( &amp;abs_new_goal );
                     }
 
-                    MapInterface::offsetToMapXY( abs_new_goal, &amp;new_goal);
+                    MapInterface::offsetToMapXY( abs_new_goal, new_goal);
                     path_request.goal = new_goal;
                 }
 
@@ -260,7 +260,7 @@
                     path_request.path-&gt;popFirst( &amp;abs_new_goal );
                 }
 
-                MapInterface::offsetToMapXY( abs_new_goal, &amp;new_goal);
+                MapInterface::offsetToMapXY( abs_new_goal, new_goal);
                 path_request.goal = new_goal;
 
                 pathing_fsm_state = _pathing_fsm_state_generate_path_part_a;
@@ -290,7 +290,7 @@
                     path_request.path-&gt;popLast( &amp;abs_new_goal );
                 }
 
-                MapInterface::offsetToMapXY( abs_new_goal, &amp;new_goal);
+                MapInterface::offsetToMapXY( abs_new_goal, new_goal);
                 path_request.goal = new_goal;
                 path_request.start = working_goal;
 

Modified: branches/newpath/src/NetPanzer/Objectives/Objective.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/Objective.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Objectives/Objective.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -42,7 +42,7 @@
     capture_area = area;
     occupying_player = 0;
 
-    MapInterface::pointXYtoMapXY( location, &amp;outpost_map_loc );
+    MapInterface::pointXYtoMapXY( location, outpost_map_loc );
     selection_box.max = location + iXY( 64, 32 );
     selection_box.min = location + iXY( -224, -128 );
     this-&gt;area.min = iXY( -400, -144 );

Modified: branches/newpath/src/NetPanzer/Objectives/ObjectiveInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Objectives/ObjectiveInterface.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -148,8 +148,8 @@
             num_objectives = 0;
         }
 
-        size_t loc_x, loc_y;
-        size_t world_x, world_y;
+        iXY loc;
+        iXY world;
         std::string name;
 
         for (ObjectiveID objective_index = 0; objective_index &lt; objective_count; objective_index++ )
@@ -159,11 +159,11 @@
             name = readToken(in, &quot;Name:&quot;);
             std::string location = readToken(in, &quot;Location:&quot;);
             std::stringstream ss(location);
-            ss &gt;&gt; loc_x &gt;&gt; loc_y;
+            ss &gt;&gt; loc.x &gt;&gt; loc.y;
             
-            MapInterface::mapXYtoPointXY( loc_x, loc_y, &amp;world_x, &amp;world_y );
+            MapInterface::mapXYtoPointXY( loc, world );
 
-            objective_obj = new Objective(objective_index, iXY(world_x, world_y),
+            objective_obj = new Objective(objective_index, world,
                     BoundBox( -48, -32, 48, 32 )
                     );
             

Modified: branches/newpath/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -43,17 +43,14 @@
 void BonusUnitPowerUp::onHit( UnitID unit_id )
 {
     PlacementMatrix placement_matrix;
-    iXY map_pos;
 
     sound-&gt;playPowerUpSound();
 
-    UnitBase* unit = UnitInterface::getUnit(unit_id);
+    PlayerID own_player = UnitInterface::getUnit(unit_id)-&gt;player-&gt;getID();
 
-    MapInterface::pointXYtoMapXY( unit-&gt;unit_state.location, &amp;map_pos );
+    placement_matrix.reset( map_loc );
 
-    placement_matrix.reset( map_pos );
 
-
     for( int i = 0; i &lt; 9; i++ )
     {
         UnitBase *new_unit;
@@ -63,7 +60,7 @@
 
         new_unit = UnitInterface::createUnit(bonus_unit_type,
                                              spawn_loc,
-                                             unit-&gt;player-&gt;getID() );
+                                             own_player );
 
         if ( new_unit != 0 )
         {
@@ -75,12 +72,12 @@
     }
 
     PowerUpHitMesg hit_mesg;
-    hit_mesg.set( ID, unit-&gt;player-&gt;getID() );
+    hit_mesg.set( ID, own_player );
     SERVER-&gt;broadcastMessage( &amp;hit_mesg, sizeof( PowerUpHitMesg ));
 
     life_cycle_state = _power_up_lifecycle_state_inactive;
 
-    if(unit-&gt;player == PlayerInterface::getLocalPlayer())
+    if( PlayerInterface::isLocalPlayer(own_player) )
     {
         ConsoleInterface::postMessage(Color::unitAqua, false, 0, &quot;YOU GOT A BONUS UNITS POWERUP&quot; );
     }

Modified: branches/newpath/src/NetPanzer/PowerUps/PowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/PowerUps/PowerUp.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -37,7 +37,7 @@
     this-&gt;ID = ID;
     this-&gt;type = type;
 
-    MapInterface::mapXYtoPointXY( map_loc, &amp;(this-&gt;world_loc) );
+    MapInterface::mapXYtoPointXY( map_loc, this-&gt;world_loc );
     
     this-&gt;life_cycle_state = _power_up_lifecycle_state_active;
     
@@ -55,7 +55,7 @@
     this-&gt;ID = -1;
     this-&gt;type = type;
 
-    MapInterface::mapXYtoPointXY( map_loc, &amp;(this-&gt;world_loc) );
+    MapInterface::mapXYtoPointXY( map_loc, this-&gt;world_loc );
     
     this-&gt;life_cycle_state = _power_up_lifecycle_state_active;
 

Modified: branches/newpath/src/NetPanzer/Units/UnitBase.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBase.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitBase.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -32,7 +32,6 @@
     PlayerState* player;
     UnitID       id;
     UnitState    unit_state;
-    bool         in_sync_flag;
 
     UnitBase(PlayerState* newPlayer, UnitID newId)
         : player(newPlayer), id(newId)
@@ -43,10 +42,16 @@
     virtual void processMessage(const UnitMessage* ) = 0;
     virtual void evalCommandOpcode(const UnitOpcode* ) = 0;
     virtual void updateState() = 0;
-    virtual void syncUnit() = 0;
     virtual void offloadGraphics(SpriteSorter&amp; ) = 0;
     virtual void soundSelected() = 0;
 
+    bool isWeaponInRange(const iXY&amp; loc) const
+    {
+        int x = loc.x - unit_state.location.x;
+        int y = loc.y - unit_state.location.y;
+        return (x*x + y*y) &lt; unit_state.weapon_range;
+    }
+
 private:
     friend class UnitInterface;
     void setID(UnitID id)

Modified: branches/newpath/src/NetPanzer/Units/UnitBlackBoard.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitBlackBoard.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -34,19 +34,3 @@
 {
     unit_loc_map.clear();
 }
-
-
-void UnitBlackBoard::updateUnitLocs( void )
-{
-    unsigned long i,k,x_limit,y_limit;
-
-    x_limit = unit_loc_map.x_size;
-    y_limit = unit_loc_map.y_size;
-
-    for( i = 0; i &lt; y_limit; i++ )
-        for ( k = 0; k &lt; x_limit; k++ ) {
-            if ( unit_loc_map.getBit( k, i ) == true )
-                MapInterface::markLocHack( iXY( k, i ) );
-        }
-
-}

Modified: branches/newpath/src/NetPanzer/Units/UnitBlackBoard.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitBlackBoard.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -44,8 +44,6 @@
 
     static void resetBlackBoard();
 
-    static void updateUnitLocs( void );
-
     static inline bool unitOccupiesLoc( iXY &amp;unit_map_loc )
     {
         return( unit_loc_map.getBit( unit_map_loc.x, unit_map_loc.y ) );

Modified: branches/newpath/src/NetPanzer/Units/UnitInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitInterface.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -61,6 +61,7 @@
 
 Timer UnitInterface::message_timer;
 Timer UnitInterface::no_guarantee_message_timer;
+NTimer UnitInterface::logic_timer;
 
 unsigned long   UnitInterface::sync_units_iterator;
 bool	        UnitInterface::sync_units_complete_flag;
@@ -84,6 +85,19 @@
     unit_bucket_array.initialize(MapInterface::getSize(), TileInterface::getTileSize() );
 
     lastUnitID = 0;
+
+    /* Timer logic:
+        The timer will start at the next exact second.
+        As the logic will run 16 times per seccond, that is 62.5 ms each, but
+        this uses integer only.
+        So we do first step in 63 ms, second 62, thirth 63, 62,63,62,63...
+        This trick is done by or'ing 1 with the timeout each step.
+    */
+    logic_timer.reset();
+    logic_timer.setTimeOut(63);
+    Uint32 t = logic_timer.getStartTime();
+    logic_timer.reset(t+(1000-(t%1000))); // timer starts next exact second.
+
     message_timer.changeRate( 8 );
     no_guarantee_message_timer.changeRate( 15 );
 
@@ -209,34 +223,41 @@
 
 void UnitInterface::updateUnitStatus()
 {
-    for(Units::iterator i = units.begin(); i != units.end(); /*nothing*/ ) {
-        UnitBase* unit = i-&gt;second;
-	    
-        if (unit-&gt;unit_state.lifecycle_state == _UNIT_LIFECYCLE_INACTIVE) {
-            Units::iterator next = i;
-            ++next;
-            removeUnit(i);
-            i = next;
-            continue;
-        }
-	    
-        unsigned long pre_update_bucket_index;
-        unsigned long post_update_bucket_index;
+    // XXX consider getting the time now and reuse each loop.
+    while ( logic_timer.isTimeOut() )
+    {
+        for(Units::iterator i = units.begin(); i != units.end(); /*nothing*/ ) {
+            UnitBase* unit = i-&gt;second;
 
-        pre_update_bucket_index 
-            = unit_bucket_array.worldLocToBucketIndex(
-                    unit-&gt;unit_state.location );
-        unit-&gt;updateState();
+            if (unit-&gt;unit_state.lifecycle_state == _UNIT_LIFECYCLE_INACTIVE) {
+                Units::iterator next = i;
+                ++next;
+                removeUnit(i);
+                i = next;
+                continue;
+            }
 
-        post_update_bucket_index 
-            = unit_bucket_array.worldLocToBucketIndex(
-                    unit-&gt;unit_state.location );
+            unsigned long pre_update_bucket_index;
+            unsigned long post_update_bucket_index;
 
-        if ( post_update_bucket_index != pre_update_bucket_index ) {
-            unit_bucket_array.moveUnit(unit-&gt;id,
-                    pre_update_bucket_index, post_update_bucket_index );
+            pre_update_bucket_index
+                = unit_bucket_array.worldLocToBucketIndex(
+                        unit-&gt;unit_state.location );
+            unit-&gt;updateState();
+
+            post_update_bucket_index
+                = unit_bucket_array.worldLocToBucketIndex(
+                        unit-&gt;unit_state.location );
+
+            if ( post_update_bucket_index != pre_update_bucket_index ) {
+                unit_bucket_array.moveUnit(unit-&gt;id,
+                        pre_update_bucket_index, post_update_bucket_index );
+            }
+            ++i;
         }
-        ++i;
+
+        logic_timer.reset(logic_timer.getStartTime()+logic_timer.getTimeOut());
+        logic_timer.setTimeOut(logic_timer.getTimeOut()|1); // flip each time
     }
 
     if ( NetworkState::status == _network_state_server ) {
@@ -658,7 +679,7 @@
         UnitBase* unit = i-&gt;second;
         UnitState* unit_state = &amp; unit-&gt;unit_state;
             
-        MapInterface::pointXYtoMapXY( unit_state-&gt;location, &amp;unit_map_loc );
+        MapInterface::pointXYtoMapXY( unit_state-&gt;location, unit_map_loc );
         if( map_loc == unit_map_loc ) {
             *queary_unit_id = unit-&gt;id;
             return true;
@@ -728,33 +749,8 @@
     }
 }
 
-
 // ******************************************************************
 
-void UnitInterface::unitSyncMessage(const NetMessage *net_message)
-{
-    const UnitIniSyncMessage* sync_message 
-        = (const UnitIniSyncMessage *) net_message;
-
-    try {
-        std::map&lt;UnitID, UnitBase*&gt;::iterator uit = units.find(sync_message-&gt;getUnitID());
-        if ( uit != units.end() ) {
-            LOGGER.warning(&quot;UnitInterface::unitSyncMessage() Received an existing unit [%d]&quot;,
-                            sync_message-&gt;getUnitID());
-            return;
-        }
-        UnitBase* unit = newUnit(sync_message-&gt;unit_type,
-                iXY(sync_message-&gt;getLocX(), sync_message-&gt;getLocY()),
-                sync_message-&gt;getPlayerID(), sync_message-&gt;getUnitID());
-        unit-&gt;in_sync_flag = false;
-        addNewUnit(unit);
-    } catch(std::exception&amp; e) {
-        LOGGER.warning(&quot;UnitInterface::unitSyncMessage() Couldn't sync unit '%s'&quot;, e.what());
-    }
-}
-
-// ******************************************************************
-
 void UnitInterface::unitOpcodeMessage(const NetMessage *net_message, size_t size)
 {
     UnitOpcodeDecoder decoder;
@@ -825,10 +821,6 @@
 void UnitInterface::processNetMessage(const NetMessage* net_message, size_t size)
 {
     switch(net_message-&gt;message_id)  {
-        case _net_message_id_ini_sync_mesg:
-            unitSyncMessage(net_message);
-            break;
-
         case _net_message_id_opcode_mesg:
             unitOpcodeMessage(net_message, size);
             break;

Modified: branches/newpath/src/NetPanzer/Units/UnitInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitInterface.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -24,6 +24,7 @@
 #include &quot;Classes/UnitMessage.hpp&quot;
 #include &quot;Classes/PlayerState.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
+#include &quot;Util/NTimer.hpp&quot;
 #include &quot;Classes/PlacementMatrix.hpp&quot;
 
 #include &quot;Classes/Network/UnitNetMessage.hpp&quot;
@@ -153,6 +154,8 @@
 protected:
     friend class Vehicle;
     
+    static NTimer logic_timer;
+
     // Network Message Handler Variables
     static Timer message_timer;
     static Timer no_guarantee_message_timer;
@@ -164,7 +167,6 @@
         opcode_encoder.encode(opcode);
     }
 
-    static void unitSyncMessage(const NetMessage *net_message );
     static void unitOpcodeMessage(const NetMessage *net_message, size_t size);
     static void unitDestroyMessage(const NetMessage *net_message );
     static void unitCreateMessage(const NetMessage *net_message );

Modified: branches/newpath/src/NetPanzer/Units/UnitOpcodes.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitOpcodes.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitOpcodes.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -21,8 +21,6 @@
 #include &quot;Units/UnitBase.hpp&quot;
 #include &lt;queue&gt;
 
-enum { _unit_opcode_flag_sync = 0x01 };
-
 #ifdef MSVC
 #pragma pack(1)
 #endif
@@ -31,9 +29,8 @@
 #define _UNIT_OPCODE_TURRET_TRACK_POINT 2
 #define _UNIT_OPCODE_TURRET_TRACK_TARGET 3
 #define _UNIT_OPCODE_FIRE_WEAPON 4
-#define _UNIT_OPCODE_SYNC_UNIT 5
-#define _UNIT_OPCODE_UPDATE_STATE 6
-#define _UNIT_OPCODE_DESTRUCT 7
+#define _UNIT_OPCODE_UPDATE_STATE 5
+#define _UNIT_OPCODE_DESTRUCT 6
 
 // do not use this directly, cast to 1 of the UnitOpcode classes...
 struct UnitOpcodeStruct
@@ -58,8 +55,6 @@
 private:
     Uint16 unit_id;
 public:
-    Uint8 flags;
-
     void setUnitID(UnitID id)
     {
         unit_id = htol16(id);
@@ -85,9 +80,6 @@
         case _UNIT_OPCODE_FIRE_WEAPON:
             return(sizeof(UnitOpcode)+sizeof(Uint16)*2);
             break;
-        case _UNIT_OPCODE_SYNC_UNIT:
-            return(sizeof(UnitOpcode));
-            break;
         case _UNIT_OPCODE_UPDATE_STATE:
             return(sizeof(UnitOpcode)+sizeof(Sint16));
             break;
@@ -112,7 +104,6 @@
 
     MoveOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_MOVE;
 
         square = 0;
@@ -143,7 +134,6 @@
 
     TurretTrackPointOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
 
         target_x = target_y = 0;
@@ -172,7 +162,6 @@
 
     TurretTrackTargetOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_TURRET_TRACK_TARGET;
 
         targetUnitID = 0;
@@ -200,7 +189,6 @@
 
     FireWeaponOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_FIRE_WEAPON;
     }
 
@@ -217,18 +205,6 @@
 
 } __attribute__((packed));
 
-
-class SyncUnitOpcode : public UnitOpcode
-{
-public:
-    SyncUnitOpcode( )
-    {
-        flags = 0;
-        opcode = _UNIT_OPCODE_SYNC_UNIT;
-    }
-} __attribute__((packed));
-
-
 class UpdateStateUnitOpcode : public UnitOpcode
 {
 private:
@@ -236,7 +212,6 @@
 public:
     UpdateStateUnitOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_UPDATE_STATE;
     }
 
@@ -257,7 +232,6 @@
 public:
     DestructUnitOpcode( )
     {
-        flags = 0;
         opcode = _UNIT_OPCODE_DESTRUCT;
     }
 } __attribute__((packed));

Modified: branches/newpath/src/NetPanzer/Units/UnitState.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitState.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitState.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -59,65 +59,3 @@
 
     return( damage_percentage );
 }
-
-NetworkUnitState UnitState::getNetworkUnitState() const
-{
-    NetworkUnitState state;
-
-    state.unit_type = unit_type;
-    state.location_x = htol32(location.x);
-    state.location_y = htol32(location.y);
-    state.bbox_min_x = htol32(bbox.min.x);
-    state.bbox_min_y = htol32(bbox.min.y);
-    state.bbox_max_x = htol32(bbox.max.x);
-    state.bbox_max_y = htol32(bbox.max.y);
-
-    state.body_angle = body_angle.getNetworkAngleInt();
-    state.turret_angle = turret_angle.getNetworkAngleInt();
-    state.orientation = htol16(orientation);
-    state.speed_rate = htol16(speed_rate);
-    state.speed_factor = htol16(speed_factor);
-    
-    state.reload_time = htol16(reload_time);
-    state.max_hit_points = htol16(max_hit_points);
-    state.hit_points = htol16(hit_points);
-    state.damage_factor = htol16(damage_factor);
-    state.weapon_range = htol32(weapon_range);
-    state.defend_range = htol32(defend_range);
-    
-    state.threat_level = threat_level;
-    state.lifecycle_state = lifecycle_state;
-
-    return state;
-}
-
-void UnitState::setFromNetworkUnitState(const NetworkUnitState&amp; state)
-{
-    select = false;
-
-    unit_type = state.unit_type;
-    location.x = ltoh32(state.location_x);
-    location.y = ltoh32(state.location_y);
-    bbox.min.x = ltoh32(state.bbox_min_x);
-    bbox.min.y = ltoh32(state.bbox_min_y);
-    bbox.max.x = ltoh32(state.bbox_max_x);
-    bbox.max.y = ltoh32(state.bbox_max_y);
-
-    body_angle.setFromNetworkAngleInt(state.body_angle);
-    turret_angle.setFromNetworkAngleInt(state.turret_angle);
-
-    orientation = ltoh16(state.orientation);
-    speed_rate = ltoh16(state.speed_rate);
-    speed_factor = ltoh16(state.speed_factor);
-    
-    reload_time = ltoh16(state.reload_time);
-    max_hit_points = ltoh16(state.max_hit_points);
-    hit_points = ltoh16(state.hit_points);
-    damage_factor = ltoh16(state.damage_factor);
-    weapon_range = ltoh32(state.weapon_range);
-    defend_range = ltoh32(state.defend_range);
-
-    threat_level = state.threat_level;
-    lifecycle_state = state.lifecycle_state;
-}
-

Modified: branches/newpath/src/NetPanzer/Units/UnitState.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitState.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/UnitState.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -22,7 +22,7 @@
 
 #include &quot;ArrayUtil/BoundBox.hpp&quot;
 #include &quot;Types/Angle.hpp&quot;
-
+#include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;UnitLifecycles.hpp&quot;
 
 enum { _threat_level_all_clear,
@@ -30,78 +30,46 @@
        _threat_level_defending
      };
 
-#ifdef MSVC
-#pragma pack(1)
-#endif
-
-class NetworkUnitState
+class UnitState
 {
 public:
-    NetworkUnitState()
-    { }
+    unsigned char   unit_type;
 
-private:
-    Uint8     unit_type;
+    /// true if the unit is currently selected
+    bool            select;
 
-    Sint32     location_x;
-    Sint32     location_y;
-    Sint32     bbox_min_x;
-    Sint32     bbox_min_y;
-    Sint32     bbox_max_x;
-    Sint32     bbox_max_y;
-    
-    NetworkAngleInt body_angle;
-    NetworkAngleInt turret_angle;
+    // world pixel location of the unit
+    iXY             location;
 
-    Uint16    orientation;
-    Uint16    speed_rate;
-    Uint16    speed_factor;
+    // map xy location
+    iXY             map_location;
 
-    Uint16    reload_time;
-    Sint16     max_hit_points;
-    Sint16     hit_points;
-    Uint16    damage_factor;
-    Uint32    weapon_range;
-    Uint32    defend_range;
+    // world pixel location of top left tile corner
+    iXY             map_px_location;
 
-    Uint8 threat_level;
-    Uint8 lifecycle_state;
+    // 1/256 of a tile
+    iXY             subtile_location;
 
-    friend class UnitState;
-} __attribute__((packed));
+    BoundBox        bbox;
 
-#ifdef MSVC
-#pragma pack()
-#endif
+    AngleInt        body_angle;
+    AngleInt        turret_angle;
 
-class UnitState
-{
-public:
-    unsigned char  unit_type;
+    unsigned short  orientation;
+    unsigned short  speed_rate;
+    unsigned short  speed_factor;
+    short           tilespeed;
 
-    /// true if the unit is currently selected
-    bool           select;
-    /// position of the unit
-    iXY            location;
-    BoundBox       bbox;
+    unsigned short  reload_time;
+    short	    max_hit_points;
+    short           hit_points;
+    unsigned short  damage_factor;
+    unsigned long   weapon_range;
+    unsigned long   defend_range;
 
-    AngleInt       body_angle;
-    AngleInt       turret_angle;
+    unsigned char   threat_level;
+    unsigned char   lifecycle_state;
 
-    unsigned short orientation;
-    unsigned short speed_rate;
-    unsigned short speed_factor;
-
-    unsigned short reload_time;
-    short	   max_hit_points;
-    short          hit_points;
-    unsigned short damage_factor;
-    unsigned long  weapon_range;
-    unsigned long  defend_range;
-
-    unsigned char  threat_level;
-    unsigned char  lifecycle_state;
-
     UnitState( );
 
     bool bounds(const iXY&amp; loc) const
@@ -112,8 +80,54 @@
     int percentDamageInt();
     float percentDamageFloat();
 
-    NetworkUnitState getNetworkUnitState() const;
-    void setFromNetworkUnitState(const NetworkUnitState&amp; state);
+    void setInitialLocation(const iXY&amp; map_loc)
+    {
+        subtile_location.x = 128;
+        subtile_location.y = 128;
+        map_location = map_loc;
+        MapInterface::mapXYtoTopPointXY(map_loc, location);
+        location.x += 128&gt;&gt;3;
+        location.y += 128&gt;&gt;3;
+    }
+
+    void subtileMove(const int x, const int y)
+    {
+        subtile_location.x += x;
+        subtile_location.y += y;
+
+        location.x &amp;= ~0x1f; // clear the tile bits
+        location.y &amp;= ~0x1f; // clear the tile bits
+
+        if ( subtile_location.x &gt;= 256 )
+        {
+            subtile_location.x &amp;= 0xff;
+            ++map_location.x;
+            location.x += 32; // XXX tile size
+        }
+        else if ( subtile_location.x &lt; 0 )
+        {
+            subtile_location.x &amp;= 0xff;
+            --map_location.x;
+            location.x -= 32; // XXX tile size
+        }
+
+        if ( subtile_location.y &gt;= 256 )
+        {
+            subtile_location.y &amp;= 0xff;
+            ++map_location.y;
+            location.y += 32; // XXX tile size
+        }
+        else if ( subtile_location.y &lt; 0 )
+        {
+            subtile_location.y &amp;= 0xff;
+            --map_location.y;
+            location.y -= 32; // XXX tile size
+        }
+
+        location.x += subtile_location.x &gt;&gt; 3;
+        location.y += subtile_location.y &gt;&gt; 3;
+    }
+
 };
 
 #endif

Modified: branches/newpath/src/NetPanzer/Units/Vehicle.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/Vehicle.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -68,8 +68,12 @@
 
 */
 
-#define MOVEWAIT_TIME 0.9f
+// the number is the count out of 16, so
+// 13/16 = 0.8125 seconds
+// 14/16 = 0.875 seconds
 
+#define MOVEWAIT_TIME 13
+
 enum{ _rotate_and_move, _rotate_stop_move };
 
 Vehicle::Vehicle(PlayerState* player, unsigned char utype, UnitID id, iXY initial_loc)
@@ -81,23 +85,18 @@
     if(!MapInterface::inside(initial_loc))
         throw std::runtime_error(&quot;Invalid position&quot;);
 
-    iXY loc = MapInterface::mapXYtoPointXY(initial_loc);
-    unit_state.location = loc;
+    unit_state.setInitialLocation(initial_loc);
+
     UnitBlackBoard::markUnitLoc( initial_loc );
-    fsm_timer.changeRate( 10 );
-    unit_state_timer.changeRate( 10 );
     setAiFsmDefendHold();
     pending_AI_comm = false;
     unit_state.lifecycle_state = _UNIT_LIFECYCLE_ACTIVE;
     memset( fsm_active_list, 0, sizeof( bool ) * 7 );
 
-    in_sync_flag = true;
-
     body_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
     turret_anim_shadow.setDrawModeBlend(&amp;Palette::colorTableDarkenALot);
 
     path_generated = false;
-    critical_ai_section = false;
     ai_fsm_transition_complete = false;
 
     reload_counter = 0;
@@ -111,11 +110,7 @@
     fsmTurretRotate_rotation = 0;
     fsmTurretRotate_goal_angle = 0;
 
-    interpolation_speed = 0;
-    fsmMove_first_stamp = false;
     fsmMove_offset_x = fsmMove_offset_y = 0;
-    fsmMove_moves_counter = 0;
-    fsmMove_moves_per_square = 0;
 
     move_opcode_sent = false;
     fsmMoveMapSquare_movement_type = 0;
@@ -140,7 +135,7 @@
     body_anim_shadow.attachSprite( &amp;turret_anim, zero );
     body_anim_shadow.attachSprite( &amp;select_info_box, zero );
 
-    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+    aiFsmMoveToLoc_wait_count = 0;
 }
 
 void Vehicle::setUnitProperties( unsigned char utype )
@@ -155,6 +150,7 @@
     unit_state.defend_range = profile-&gt;defend_range;
     unit_state.speed_factor = profile-&gt;speed_factor;
     unit_state.speed_rate = profile-&gt;speed_rate;
+    unit_state.tilespeed = (unit_state.speed_factor * unit_state.speed_rate) / 2;
     unit_state.reload_time = profile-&gt;reload_time;
     unit_state.weapon_range = profile-&gt;attack_range;
     unit_state.unit_type = utype;
@@ -252,13 +248,25 @@
 
 }
 
+/*
+ * Values:
+ * Orientation     Angle
+ *
+ *  3  2  1        14  9  5
+ *   \ | /           \ | /
+ * 4 - T - 0      18 - T - 0
+ *   / | \           / | \
+ *  5  6  7        23 27 32
+ *
+ * 0xFFFF if no orientation or change
+ */
+
 unsigned short Vehicle::mapXYtoOrientation( unsigned long square, long *goal_angle )
 {
-    iXY current_loc, next_loc;
+    iXY&amp; current_loc = unit_state.map_location;
+    iXY next_loc;
+    MapInterface::offsetToMapXY( square, next_loc );
 
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
-    MapInterface::offsetToMapXY( square, &amp;next_loc );
-
     // so many magic numbers
     if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y == current_loc.y) )
     {
@@ -342,12 +350,10 @@
 void Vehicle::locationOffset( unsigned long square, iXY &amp;offset )
 {
     iXY square_map_loc;
-    iXY unit_map_loc;
 
-    MapInterface::offsetToMapXY( square, &amp;square_map_loc );
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;unit_map_loc );
+    MapInterface::offsetToMapXY( square, square_map_loc );
 
-    offset = unit_map_loc - square_map_loc ;
+    offset = unit_state.map_location - square_map_loc ;
 }
 
 void Vehicle::setFsmBodyRotate( long goal_angle, unsigned short rotation )
@@ -406,68 +412,40 @@
 
 void Vehicle::setFsmMove( unsigned short orientation )
 {
-    fsm_timer.changeRate( unit_state.speed_rate );
     orientationToOffset( orientation, &amp;fsmMove_offset_x, &amp;fsmMove_offset_y );
-    fsmMove_moves_counter = 0;
-    fsmMove_moves_per_square = 32 / unit_state.speed_factor;
-    /*
-    fsmMove_moves_per_square = 32;
-    interpolation_speed = unit_state.speed_rate * unit_state.speed_factor;
-    if ( NetworkState::status == _network_state_client )
-     { interpolation_speed += 2; }
-    fsmMove_first_stamp = true;
-    */
+
+    fsmMove_to_move.x = abs(256 * fsmMove_offset_x);
+    fsmMove_to_move.y = abs(256 * fsmMove_offset_y);
+    fsmMove_moved.zero();
+
 }
 
 bool Vehicle::fsmMove()
 {
-    /*
-    long move_offset;
+    int to_move_x = unit_state.tilespeed * fsmMove_offset_x;
+    int to_move_y = unit_state.tilespeed * fsmMove_offset_y;
 
-    if( fsmMove_first_stamp == true )
-       {
-        start_move_stamp = now();
-        fsmMove_first_stamp = false;
-       }
+    fsmMove_moved.x += abs(to_move_x);
+    fsmMove_moved.y += abs(to_move_y);
 
-    end_move_stamp = now();
-
-    move_offset = (end_move_stamp - start_move_stamp) * interpolation_speed;
-
-    if( (move_offset + fsmMove_moves_counter) &gt; fsmMove_moves_per_square )
-     {
-      move_offset = fsmMove_moves_per_square - fsmMove_moves_counter;
-     }
-    */
-
-    if ( fsmMove_moves_counter &lt; fsmMove_moves_per_square )
+    if ( fsmMove_moved &gt;= fsmMove_to_move )
     {
-        /*
-        fsmMove_moves_counter += move_offset;
+        int adj_x = fsmMove_moved.x - fsmMove_to_move.x;
+        int adj_y = fsmMove_moved.y - fsmMove_to_move.y;
 
-        unit_state.location.x = unit_state.location.x + ( move_offset * fsmMove_offset_x );
+        to_move_x += adj_x * fsmMove_offset_x;
+        to_move_y += adj_y * fsmMove_offset_y;
 
-        unit_state.location.y = unit_state.location.y + ( move_offset * fsmMove_offset_y );
-        */
-
-        fsmMove_moves_counter++;
-
-        unit_state.location.x = unit_state.location.x + ( unit_state.speed_factor * fsmMove_offset_x );
-
-        unit_state.location.y = unit_state.location.y + ( unit_state.speed_factor * fsmMove_offset_y );
-
-        ParticleInterface::addMoveDirtPuff(unit_state);
-        //start_move_stamp = now();
+        fsmMove_moved.x -= adj_x;
+        fsmMove_moved.y -= adj_y;
     }
 
-    if( fsmMove_moves_counter &gt;= fsmMove_moves_per_square)
-    {
-        //fsmMove_first_stamp = true;
-        fsm_timer.changeRate( 10 );
-        return( true );
-    }
+    unit_state.subtileMove( unit_state.tilespeed * fsmMove_offset_x
+                           ,unit_state.tilespeed * fsmMove_offset_y);
 
-    return( false );
+    ParticleInterface::addMoveDirtPuff(unit_state);
+
+    return fsmMove_moved == fsmMove_to_move;
 }
 
 void Vehicle::setFsmMoveMapSquare( unsigned long square )
@@ -488,7 +466,6 @@
         fsmMoveMapSquare_movement_type = _rotate_stop_move;
 
     fsm_active_list[ _control_move_map_square ] = true;
-    critical_ai_section = true;
 
     if ( NetworkState::status == _network_state_server )
     {
@@ -531,7 +508,6 @@
                 if ( fsmMove() )
                 {
                     fsm_active_list[ _control_move_map_square ] = false;
-                    critical_ai_section = false;
 
                     if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                     {
@@ -551,7 +527,6 @@
             if ( fsmMove() )
             {
                 fsm_active_list[ _control_move_map_square ] = false;
-                critical_ai_section = false;
 
                 if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                 {
@@ -614,7 +589,6 @@
     if ( fsm_active_list[ _control_turret_track_point ] == true )
     {
         TurretTrackPointOpcode track_point_opcode;
-        track_point_opcode.flags = _unit_opcode_flag_sync;
         track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
         track_point_opcode.setUnitID(id);
         track_point_opcode.setTarget(fsmTurretTrackPoint_target);
@@ -683,7 +657,6 @@
     {
         TurretTrackTargetOpcode track_target_opcode;
         track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
-        track_target_opcode.flags = _unit_opcode_flag_sync;
         track_target_opcode.setUnitID(id);
         track_target_opcode.setTargetUnitID(fsmTurretTrackTarget_target_id);
         track_target_opcode.activate = true;
@@ -745,13 +718,9 @@
 
 void Vehicle::fsmGunneryLocation()
 {
-    iXY range_vector;
-
-    range_vector = fsmGunneryLocation_target - unit_state.location;
-
-    if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
-            (fsmTurretTrackPoint_on_target == true) &amp;&amp;
-            (reload_counter &gt;= unit_state.reload_time)
+    if ( isWeaponInRange(fsmGunneryLocation_target)
+         &amp;&amp; (fsmTurretTrackPoint_on_target == true)
+         &amp;&amp; (reload_counter &gt;= unit_state.reload_time)
        )
     {
         fireWeapon( fsmGunneryLocation_target );
@@ -787,7 +756,6 @@
 {
     UnitBase *target_unit_ptr;
     UnitState *target_unit_state;
-    iXY range_vector;
 
     target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
     if ( target_unit_ptr == 0 )
@@ -804,11 +772,9 @@
         }
         else
         {
-            range_vector = target_unit_state-&gt;location - unit_state.location;
-
-            if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
-                    (fsmTurretTrackTarget_on_target == true) &amp;&amp;
-                    (reload_counter == unit_state.reload_time )
+            if ( isWeaponInRange(target_unit_state-&gt;location)
+                 &amp;&amp; (fsmTurretTrackTarget_on_target == true)
+                 &amp;&amp; (reload_counter == unit_state.reload_time )
                )
             {
                 fireWeapon( target_unit_state-&gt;location );
@@ -828,279 +794,163 @@
 
 }
 
-bool Vehicle::ruleMoveToLoc_GoalReached()
-{
-    iXY map_loc;
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;map_loc );
-    if ( map_loc == aiFsmMoveToLoc_goal )
-        return true;
+/*
+  when new the current_loc is marked
 
-    return false;
-}
 
+  if in goal: prev_loc = current_loc, mark it;
+  new in goal: don't mark anything, it is already marked.
 
+  here didn't move it is useless to mark it again?
+  in next_move: if has to move: prev_loc = current_loc, mark it;
+  new next_move: don't mark it, it is already marked.
+
+  in wait_clear_loc: if empty, mark next_loc!!
+  Here has both loc marked, prev and next;
+
+  in move_wait: if move finished, unmark prev
+
+
+ */
+
 void Vehicle::aiFsmMoveToLoc()
 {
-    bool end_cycle = false;
-
-    do
+    if ( external_ai_event == _external_event_pending_unit_destruct  )
     {
-        switch ( aiFsmMoveToLoc_state )
+        // External Event: This unit is about to be deleted
+        // Action : Exit fsm gracefully
+        aiFsmMoveToLoc_OnExitCleanUp();
+
+        UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+        if ( aiFsmMoveToLoc_next_marked )
         {
+            UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
+        }
 
-            // *************************************************************
-            case _aiFsmMoveToLoc_path_generate :
-            {
-                // QueryPath: Has a path been generated for unit ?
-                path_generated = PathScheduler::queryPath(id);
+        external_ai_event = _external_event_null;
+        ai_command_state = _ai_command_idle;
+        return;
+    }
 
+    if ( pending_AI_comm &amp;&amp; !aiFsmMoveToLoc_next_marked )
+    {
+        // External Event: A new AI command is pending
+        // Action: Allow command transition to occur
+        ai_fsm_transition_complete = true;
+        aiFsmMoveToLoc_OnExitCleanUp();
+        return;
+    }
 
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
+    switch ( aiFsmMoveToLoc_state )
+    {
+        // *************************************************************
+        case _aiFsmMoveToLoc_path_generate :
+            if ( ! PathScheduler::queryPath(id) )
+            {
+                // Path still not generated
+                break;
+            }
+            aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+            // fall through, no break
 
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+        // *************************************************************
 
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                    return;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                    return;
-                }
-                else if ( path_generated == true )
-                {
-                    // Rule QueryPath: is true move to next state
-                    //LOG( (&quot;Path Successfully Generated&quot;) );
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-                else
-                {
-                    end_cycle = true;
-                    return;
-                }
+        case _aiFsmMoveToLoc_check_goal :
+            //  GoalReached: Has the goal been reached ?
+            if ( aiFsmMoveToLoc_prev_loc == aiFsmMoveToLoc_goal )
+            {
+                aiFsmMoveToLoc_OnExitCleanUp();
+                setAiFsmDefendHold();
+                break;
             }
-            break;
 
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_check_goal :
+            if ( ! path.popFirst(&amp;aiFsmMoveToLoc_next_square) )
             {
-                //  GoalReached: Has the goal been reached ?
-                if ( ruleMoveToLoc_GoalReached() == true )
-                {
-                    // Rule GoalReached : is true
-                    // Action : Exit fsm
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
+                //  Rule: GoalReached is false AND Unit is at the end of path
+                //  Action : Request path generation to goal
+                PathRequest path_request;
 
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    setAiFsmDefendHold();
+                //LOG( (&quot;Incomplete Path -- Regenerating Path&quot;) );
+                path_request.set(id, unit_state.map_location, aiFsmMoveToLoc_goal, 0,  &amp;path, _path_request_full );
+                PathScheduler::requestPath( path_request );
+                aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
+                break;
+            }
 
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    if ( aiFsmMoveToLoc_path_not_finished == false )
-                    {
-                        //  Rule: GoalReached is false AND Unit is at the end of path
-                        //  Action : Request path generation to goal
-                        iXY start;
-                        PathRequest path_request;
+            MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, aiFsmMoveToLoc_next_loc );
+            aiFsmMoveToLoc_wait_count = 0;
+            aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
 
-                        //LOG( (&quot;Incomplete Path -- Regenerating Path&quot;) );
-                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-                        path_request.set(id, start, aiFsmMoveToLoc_goal, 0,  &amp;path, _path_request_full );
-                        PathScheduler::requestPath( path_request );
-                        aiFsmMoveToLoc_path_not_finished = true;
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-                    }
-                    else
-                    {
-                        // Rule GoalReached: is false
-                        // Action: Get next move;
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
-                    }
-                }
-            }
-            break;
+            // fall through, no break
 
-            // *************************************************************
+        // *************************************************************
 
-            case _aiFsmMoveToLoc_next_move :
+        case _aiFsmMoveToLoc_wait_clear_loc :
+        {
+            if ( ! UnitBlackBoard::unitOccupiesLoc(aiFsmMoveToLoc_next_loc) )
             {
-                // CurrentPathComplete: is Unit at the end of the current path
-                aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
-                MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
+                // Rule: NextSquareOccupied is false
+                // Action: Begin move to next square
+                UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
+                aiFsmMoveToLoc_next_marked = true;
+                setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
 
-                if ( !aiFsmMoveToLoc_path_not_finished )
-                {
-                    // Rule: CurrentPathComplete is true
-                    // Action : check if unit is at the goal
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-                else
-                {
-                    // Rule: CurrentPathComplete is false
-                    // Action: Check if next location is empty
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
-
-                    //aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                    aiFsmMoveToLoc_wait_timer.reset();
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
-                }
+                aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
+                aiFsmMoveToLoc_wait_count = 0;
             }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_wait_clear_loc :
+            else
             {
-
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                if ( ++aiFsmMoveToLoc_wait_count &gt;= MOVEWAIT_TIME)
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                    return;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                    return;
-                } // NextSquareOccupied: does the next square contain a abstruction
-                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
-                {
-                    // Rule: NextSquareOccupied is true
-                    // Action: Check Wait Timer
-
-                    if ( aiFsmMoveToLoc_wait_timer.count() )
+                    // Rule: NextSquareOccupied is true AND WaitTimer is finished
+                    // Action: Preform path update
+                    if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
                     {
-                        // Rule: NextSquareOccupied is true AND WaitTimer is finished
-                        // Action: Preform path update
-                        if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
-                        {
 
-                            UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
-                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
+                        UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
+                        UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
 
-                            PathRequest path_request;
-                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
-                            PathScheduler::requestPath( path_request );
-                            aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                        }
-                        else
-                        {
+                        PathRequest path_request;
+                        path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
+                        PathScheduler::requestPath( path_request );
+                        aiFsmMoveToLoc_wait_count = 0;
+                    }
+                    else
+                    {
 //                            LOGGER.warning(&quot;Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
 //                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
 //                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
-                            PathRequest path_request;
-                            path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
-                            PathScheduler::requestPath( path_request );
-                            // XXX the more times timeout the longer will take next time --&gt; bad idea
-                            aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                        }
-
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
+                        PathRequest path_request;
+                        path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
+                        PathScheduler::requestPath( path_request );
+                        // XXX the more times timeout the longer will take next time --&gt; bad idea
+                        aiFsmMoveToLoc_wait_count = 0;
                     }
-                    // can't move and has to wait, finish the loop.
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    // Rule: NextSquareOccupied is false
-                    // Action: Begin move to next square
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
-                    setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
 
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
-                    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
                 }
-
+                break;
             }
-            break;
 
-            // *************************************************************
+        }
+        // fall through, no break
 
-            case _aiFsmMoveToLoc_move_wait :
-            {
-                // MoveFinished : has the low level fsm finshed
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    // Rule: MoveFinished is true
-                    // Action: Check for a pending transition
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
-                    end_cycle = true;
-                }
-                else
-                {
-                    end_cycle = true;
-                    return;
-                } // ** else
+        // *************************************************************
 
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_check_fsm_transition :
+        case _aiFsmMoveToLoc_move_wait :
+        {
+            // MoveFinished : has the low level fsm finshed
+            if ( fsm_active_list[ _control_move_map_square ] == false )
             {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                    return;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                }
-
+                UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+                aiFsmMoveToLoc_prev_loc = aiFsmMoveToLoc_next_loc;
+                aiFsmMoveToLoc_next_marked = false;
+                aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
             }
-            break;
+        }
+        break;
 
-        } // ** switch
-
-    } while (end_cycle == false);
+    } // ** switch
 }
 
 void Vehicle::aiFsmMoveToLoc_OnExitCleanUp()
@@ -1114,7 +964,6 @@
     bool end_cycle = false;
 
     UnitState *target_unit_state = 0;
-    iXY range_vector;
 
     UnitBase* target_unit_ptr
         = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
@@ -1162,9 +1011,7 @@
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
 
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+                    UnitBlackBoard::unmarkUnitLoc( unit_state.map_location );
 
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
@@ -1197,16 +1044,12 @@
 
             case _aiFsmAttackUnit_range_check :
             {
-                // RangeVector: the absolute distance between unit and target
-                range_vector = target_unit_state-&gt;location - unit_state.location;
-
-                if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                if ( isWeaponInRange(target_unit_state-&gt;location) )
                 {
                     // Rule: RangeVector &lt; WeaponRange, unit is in range
                     // Action: Remain in position
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    aiFsmAttackUnit_prev_loc = unit_state.map_location;
+                    UnitBlackBoard::markUnitLoc( unit_state.map_location );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
                     end_cycle = true;
                     return;
@@ -1215,11 +1058,8 @@
                 {
                     if ( aiFsmAttackUnit_path_not_finished == false )
                     {
-                        iXY start;
-                        MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-
                         PathRequest path_request;
-                        path_request.set(id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+                        path_request.set(id, unit_state.map_location, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
                         PathScheduler::requestPath( path_request );
 
                         aiFsmAttackUnit_path_not_finished = true;
@@ -1238,8 +1078,6 @@
 
             case _aiFsmAttackUnit_idle :
             {
-                range_vector = target_unit_state-&gt;location - unit_state.location;
-
                 if ( external_ai_event == _external_event_pending_unit_destruct )
                 {
                     // External Event: This unit is about to be deleted
@@ -1260,7 +1098,7 @@
                     end_cycle = true;
                     return;
                 }
-                else if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                else if ( isWeaponInRange(target_unit_state-&gt;location) )
                 {
                     // Rule: RangeVector &lt; WeaponRange, unit is in range
                     // Action: Remain in position
@@ -1282,7 +1120,7 @@
             {
                 // CurrentPathComplete: is Unit at the end of the current path
                 aiFsmAttackUnit_path_not_finished = path.popFirst( &amp;aiFsmAttackUnit_next_square );
-                MapInterface::offsetToMapXY( aiFsmAttackUnit_next_square, &amp;aiFsmAttackUnit_next_loc );
+                MapInterface::offsetToMapXY( aiFsmAttackUnit_next_square, aiFsmAttackUnit_next_loc );
 
                 if ( !aiFsmAttackUnit_path_not_finished )
                 {
@@ -1294,10 +1132,9 @@
                 {
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
-                    aiFsmAttackUnit_wait_timer.changePeriod( 0.8f );
+                    aiFsmAttackUnit_prev_loc = unit_state.map_location;
+                    UnitBlackBoard::markUnitLoc( unit_state.map_location );
+                    aiFsmAttackUnit_wait_counter = 0;
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_wait_clear_loc;
                 }
             }
@@ -1329,7 +1166,7 @@
                 }
                 else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
                 {
-                    if ( aiFsmAttackUnit_wait_timer.count() )
+                    if ( ++aiFsmAttackUnit_wait_counter &gt;= MOVEWAIT_TIME )
                     {
                         if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
                         {
@@ -1416,15 +1253,13 @@
 
             case _aiFsmAttackUnit_check_path_deviation :
             {
-                iXY deviation_vector;
                 iXY goal_point_loc;
 
-                MapInterface::mapXYtoPointXY( aiFsmAttackUnit_target_goal_loc, &amp;goal_point_loc );
-                deviation_vector = target_unit_state-&gt;location - goal_point_loc;
+                MapInterface::mapXYtoPointXY( aiFsmAttackUnit_target_goal_loc, goal_point_loc );
 
-                if ( deviation_vector.mag2() &gt; unit_state.weapon_range )
+                if ( !isWeaponInRange(goal_point_loc) )
                 {
-                    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
+                    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, aiFsmAttackUnit_target_goal_loc );
 
                     PathRequest path_request;
                     path_request.set( id, aiFsmAttackUnit_next_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
@@ -1458,7 +1293,7 @@
 {
     ai_command_state = _ai_command_defend_hold;
     aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-    aiFsmDefendHold_search_timer.changePeriod( .5 );
+    aiFsmDefendHold_search_counter = 0;
 }
 
 void Vehicle::aiFsmDefendHold()
@@ -1493,7 +1328,7 @@
                     end_cycle = true;
                     return;
                 }
-                else if ( aiFsmDefendHold_search_timer.count() )
+                else if ( ++aiFsmDefendHold_search_counter &gt;= 8 ) // XXX 0.5 secconds
                 {
                     if (UnitInterface::queryClosestEnemyUnit(
                                 &amp;target_unit_ptr, unit_state.location,
@@ -1521,7 +1356,7 @@
                         return;
                     }
 
-                } // ** aiFsmDefendHold_search_timer.count()
+                }
                 else
                 {
                     end_cycle = true;
@@ -1594,100 +1429,6 @@
 
 }
 
-
-
-
-
-void Vehicle::aiFsmManualMove()
-{
-    bool end_cycle = false;
-    signed char offset_x = 0, offset_y = 0;
-    size_t next_square;
-
-    do
-    {
-        switch( aiFsmManualMove_state )
-        {
-            case _aiFsmManualMove_next_move :
-            {
-                aiFsmManualMove_prev_loc = aiFsmManualMove_next_loc;
-                orientationToOffset( aiFsmManualMove_move_orientation, &amp;offset_x, &amp;offset_y );
-                aiFsmManualMove_next_loc.x += offset_x;
-                aiFsmManualMove_next_loc.y += offset_y;
-                next_square = MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
-
-                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                    return;
-                }
-                else if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
-                    setFsmMoveMapSquare( next_square );
-                    aiFsmManualMove_state = _aiFsmManualMove_move_wait;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_move_wait :
-            {
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_prev_loc );
-                    aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    end_cycle = true;
-                    return;
-                } // ** else
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                    return;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                    return;
-                }
-                else
-                {
-                    aiFsmManualMove_state = _aiFsmManualMove_next_move;
-                }
-            }
-            break;
-
-        } // ** switch
-    } while ( end_cycle == false );
-
-}
-
 void Vehicle::fireWeapon( iXY &amp;target_loc )
 {
     reload_counter = 0;
@@ -1739,22 +1480,20 @@
 //-----------------------------------------------------------------
 void Vehicle::updateFsmState()
 {
-    if ( fsm_timer.count() ) {
-        if ( fsm_active_list[ _control_move_map_square ] == true )
-            fsmMoveMapSquare();
+    if ( fsm_active_list[ _control_move_map_square ] == true )
+        fsmMoveMapSquare();
 
-        if ( fsm_active_list[ _control_turret_track_point ] == true )
-            fsmTurretTrackPoint();
+    if ( fsm_active_list[ _control_turret_track_point ] == true )
+        fsmTurretTrackPoint();
 
-        if ( fsm_active_list[ _control_turret_track_target ] == true )
-            fsmTurretTrackTarget();
+    if ( fsm_active_list[ _control_turret_track_target ] == true )
+        fsmTurretTrackTarget();
 
-        if ( fsm_active_list[ _control_gunnery_location ] == true )
-            fsmGunneryLocation();
+    if ( fsm_active_list[ _control_gunnery_location ] == true )
+        fsmGunneryLocation();
 
-        if ( fsm_active_list[ _control_gunnery_target ] == true )
-            fsmGunneryTarget();
-    }
+    if ( fsm_active_list[ _control_gunnery_target ] == true )
+        fsmGunneryTarget();
 }
 
 
@@ -1778,17 +1517,14 @@
             aiFsmAttackUnit();
             break;
 
-        case _ai_command_manual_move:
-            aiFsmManualMove();
-            break;
     }
 }
 
 
 void Vehicle::checkPendingAICommStatus()
 {
-    if ( (pending_AI_comm == true) &amp;&amp;
-            (ai_fsm_transition_complete == true) )
+    if ( pending_AI_comm == true
+        &amp;&amp; ai_fsm_transition_complete == true )
     {
         pending_AI_comm = false;
         ai_fsm_transition_complete = false;
@@ -1805,13 +1541,6 @@
                     setCommandAttackUnit( &amp;pending_AI_comm_mesg );
                     break;
 
-                case _command_start_manual_move :
-                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                    break;
-
-                case _command_stop_manual_move :
-                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                    break;
             } // ** switch
 
         } // ** unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE
@@ -1822,35 +1551,32 @@
 
 void Vehicle::setCommandMoveToLoc(const UMesgAICommand* message)
 {
-    iXY start;
-
     if ( fsm_active_list[ _control_gunnery_location ] == true )
     {
         clearFsmGunneryLocation();
     }
 
     aiFsmMoveToLoc_goal = message-&gt;getGoalLoc();
+    aiFsmMoveToLoc_prev_loc = unit_state.map_location;
+    aiFsmMoveToLoc_next_marked = false;
     ai_command_state = _ai_command_move_to_loc;
     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-    aiFsmMoveToLoc_path_not_finished = true;
-    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
+    aiFsmMoveToLoc_wait_count = 0;
 
     opcode_move_timer.changePeriod( 0.10f );
     move_opcode_sent = false;
     //move_opcode_sent = true;
 
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-
     //LOG( (&quot;UnitID %d, %d : Start %d, %d : Goal %d, %d&quot;, id.getPlayer(), id.getIndex(),
     //                                                    start.x, start.y,
     //                                                    aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
 
     PathRequest path_request;
-    path_request.set( id, start, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
+    path_request.set( id, unit_state.map_location, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
     PathScheduler::requestPath( path_request );
 
     iXY target;
-    MapInterface::mapXYtoPointXY( aiFsmMoveToLoc_goal, &amp;target);
+    MapInterface::mapXYtoPointXY( aiFsmMoveToLoc_goal, target);
     setFsmTurretTrackPoint( target );
 }
 
@@ -1874,11 +1600,10 @@
     aiFsmAttackUnit_path_not_finished = true;
     aiFsmAttackUnit_target_destroyed = false;
 
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
-    MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
+    aiFsmAttackUnit_target_goal_loc = target_unit_state-&gt;map_location;
 
     PathRequest path_request;
-    path_request.set( id, start, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+    path_request.set( id, unit_state.map_location, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
     PathScheduler::requestPath( path_request );
 
     opcode_move_timer.changePeriod( 0.10f );
@@ -1888,21 +1613,6 @@
     setFsmGunneryTarget( aiFsmAttackUnit_target_ID );
 }
 
-void Vehicle::setCommandManualMove(const UMesgAICommand* message)
-{
-    if ( message-&gt;command == _command_start_manual_move )
-    {
-        aiFsmManualMove_move_orientation = message-&gt;manual_move_orientation;
-        MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmManualMove_next_loc );
-        aiFsmManualMove_state = _aiFsmManualMove_next_move;
-        ai_command_state = _ai_command_manual_move;
-    }
-    else if ( message-&gt;command == _command_stop_manual_move )
-    {
-        ai_command_state = _ai_command_idle;
-    }
-}
-
 void Vehicle::setCommandManualFire(const UMesgAICommand* message)
 {
     setFsmGunneryLocation(message-&gt;getTargetLoc());
@@ -1955,50 +1665,16 @@
                 unit_state.unit_type);
         UnitInterface::sendMessage(&amp;lifecycle_update);
 
-        // ** Note: Temp
-        iXY current_map_loc;
-        MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
-        UnitBlackBoard::unmarkUnitLoc(current_map_loc);
+        UnitBlackBoard::unmarkUnitLoc(unit_state.map_location);
     }
 }
 
-void Vehicle::messageSelectBoxUpdate(const UnitMessage* message)
-{
-    const UMesgUpdateSelectBoxInfo *select_box_update
-        = (const UMesgUpdateSelectBoxInfo *) message;
-
-    switch (select_box_update-&gt;request_type)
-    {
-        case _select_box_allie_visibility:
-        {
-            select_info_box.setAllieIcon(select_box_update-&gt;allie_flag_visiblity );
-            break;
-        }
-        break;
-
-        case _select_box_flag_visiblity:
-        {
-            select_info_box.setFlagIcon( select_box_update-&gt;flag_visiblity );
-            break;
-        }
-
-        case _select_box_is_allied:
-        {
-            select_info_box.setAllieState( select_box_update-&gt;allied_state );
-            break;
-        }
-    }
-}
-
 void Vehicle::messageSelfDestruct(const UnitMessage* )
 {
     unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
     external_ai_event = _external_event_pending_unit_destruct;
 
-    // ** Note: Temp
-    iXY current_map_loc;
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+    UnitBlackBoard::unmarkUnitLoc( unit_state.map_location );
 }
 
 void Vehicle::processMessage(const UnitMessage* message)
@@ -2016,10 +1692,6 @@
             messageWeaponHit(message);
             break;
 
-        case _umesg_update_select_box_info:
-            messageSelectBoxUpdate(message);
-            break;
-
         case _umesg_self_destruct:
             messageSelfDestruct(message);
             break;
@@ -2033,25 +1705,18 @@
 
 void Vehicle::unitOpcodeMove(const UnitOpcode* opcode)
 {
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
     const MoveOpcode* move_opcode = (const MoveOpcode *) opcode;
 
     iXY sync_loc;
-    iXY current_loc;
 
-    MapInterface::offsetToMapXY(move_opcode-&gt;getSquare(), &amp;sync_loc );
+    MapInterface::offsetToMapXY(move_opcode-&gt;getSquare(), sync_loc );
     sync_loc.x = sync_loc.x + move_opcode-&gt;loc_x_offset;
     sync_loc.y = sync_loc.y + move_opcode-&gt;loc_y_offset;
 
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
-
-    if ( current_loc != sync_loc )
+    if ( unit_state.map_location != sync_loc )
     {
-        MapInterface::mapXYtoPointXY( sync_loc, &amp;(unit_state.location) );
+        // XXX needs to change, but it was already bad before
+        unit_state.setInitialLocation(sync_loc);
     }
 
     setFsmMoveMapSquare(move_opcode-&gt;getSquare());
@@ -2059,11 +1724,6 @@
 
 void Vehicle::unitOpcodeTrackPoint(const UnitOpcode* opcode )
 {
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
     const TurretTrackPointOpcode* track_point_opcode
         = (const TurretTrackPointOpcode *) opcode;
 
@@ -2081,11 +1741,6 @@
 
 void Vehicle::unitOpcodeTrackTarget(const UnitOpcode* opcode )
 {
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
     const TurretTrackTargetOpcode* track_target_opcode
         = (const TurretTrackTargetOpcode *) opcode;
 
@@ -2104,21 +1759,11 @@
 {
     iXY target_loc;
 
-    if ( ( (in_sync_flag == false) &amp;&amp; !(opcode-&gt;flags &amp; _unit_opcode_flag_sync) ) ||
-            ( (in_sync_flag == true) &amp;&amp; (opcode-&gt;flags &amp; _unit_opcode_flag_sync) )
-       )
-        return;
-
     const FireWeaponOpcode *fire_weapon = (const FireWeaponOpcode *) opcode;
     target_loc = fire_weapon-&gt;getTarget();
     fireWeapon( target_loc );
 }
 
-void Vehicle::unitOpcodeSync(const UnitOpcode* )
-{
-    in_sync_flag = true;
-}
-
 void Vehicle::unitOpcodeUpdateState(const UnitOpcode* opcode )
 {
     const UpdateStateUnitOpcode *update_state_opcode
@@ -2135,19 +1780,6 @@
     unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
 }
 
-void Vehicle::syncUnit()
-{
-    syncFsmTurretTrackPoint();
-    syncFsmTurretTrackTarget();
-
-    SyncUnitOpcode sync_opcode;
-
-    sync_opcode.opcode = _UNIT_OPCODE_SYNC_UNIT;
-    sync_opcode.setUnitID(id);
-    UnitInterface::sendOpcode( &amp;sync_opcode );
-}
-
-
 void Vehicle::processMoveOpcodeQueue()
 {
     if (!move_opcode_queue.empty())
@@ -2194,10 +1826,6 @@
                 unitOpcodeFireWeapon(opcode);
                 break;
 
-            case _UNIT_OPCODE_SYNC_UNIT:
-                unitOpcodeSync(opcode);
-                break;
-
             case _UNIT_OPCODE_UPDATE_STATE:
                 unitOpcodeUpdateState(opcode);
                 break;
@@ -2233,8 +1861,8 @@
 
     if ( NetworkState::status == _network_state_server )
     {
-        if( unit_state_timer.count() )
-            updateUnitStateProperties();
+        // XXX next line was executed 10 times per seccond
+        updateUnitStateProperties();
 
         updateAIState();
         checkPendingAICommStatus();

Modified: branches/newpath/src/NetPanzer/Units/Vehicle.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.hpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Units/Vehicle.hpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -28,9 +28,7 @@
 #include &quot;Classes/Sprite.hpp&quot;
 #include &quot;Classes/SelectionBoxSprite.hpp&quot;
 
-enum { _control_idle,
-       _control_move,
-       _control_move_map_square,
+enum { _control_move_map_square,
        _control_turret_track_point,
        _control_turret_track_target,
        _control_gunnery_location,
@@ -39,15 +37,12 @@
 enum { _ai_command_idle,
        _ai_command_move_to_loc,
        _ai_command_attack_unit,
-       _ai_command_manual_move,
        _ai_command_defend_hold };
 
 enum { _aiFsmMoveToLoc_path_generate,
        _aiFsmMoveToLoc_check_goal,
-       _aiFsmMoveToLoc_next_move,
-       _aiFsmMoveToLoc_move_wait,
        _aiFsmMoveToLoc_wait_clear_loc,
-       _aiFsmMoveToLoc_check_fsm_transition };
+       _aiFsmMoveToLoc_move_wait };
 
 enum { _aiFsmAttackUnit_path_generate,
        _aiFsmAttackUnit_range_check,
@@ -61,10 +56,6 @@
 enum { _aiFsmDefendHold_search_for_enemy,
        _aiFsmDefendHold_attack_enemy };
 
-enum { _aiFsmManualMove_next_move,
-       _aiFsmManualMove_move_wait,
-       _aiFsmManualMove_check_fsm_transition };
-
 enum { _external_event_null,
        _external_event_pending_unit_destruct };
 
@@ -85,13 +76,10 @@
     std::string fireSound;
     unsigned short weaponType;
 
-    Timer unit_state_timer;
-    Timer fsm_timer;
     bool fsm_active_list[ 7 ];
 
     PathList path;
     bool path_generated;
-    bool critical_ai_section;
     bool ai_fsm_transition_complete;
 
     unsigned short reload_counter;
@@ -110,22 +98,18 @@
     // ** FSMs and AI FSMs
     unsigned short fsmBodyRotate_rotation;
     long           fsmBodyRotate_goal_angle;
-    void    setFsmBodyRotate( long goal_angle, unsigned short rotation );
+    void setFsmBodyRotate( long goal_angle, unsigned short rotation );
     bool fsmBodyRotate();
 
     unsigned short fsmTurretRotate_rotation;
     long           fsmTurretRotate_goal_angle;
-    void    setFsmTurretRotate( long goal_angle, unsigned short rotation );
+    void setFsmTurretRotate( long goal_angle, unsigned short rotation );
     bool fsmTurretRotate();
 
-    float interpolation_speed;
-    TimeStamp start_move_stamp;
-    TimeStamp end_move_stamp;
-    bool     fsmMove_first_stamp;
     signed char fsmMove_offset_x;
     signed char fsmMove_offset_y;
-    unsigned char fsmMove_moves_counter;
-    unsigned char fsmMove_moves_per_square;
+    iXY         fsmMove_to_move;
+    iXY         fsmMove_moved;
     void setFsmMove( unsigned short orientation );
     bool fsmMove();
 
@@ -163,42 +147,34 @@
 
     void aiFsmIdle();
 
-    unsigned char aiFsmDefendHold_state;
-    Timer	  aiFsmDefendHold_search_timer;
-    UnitID  aiFsmDefendHold_target_ID;
+    unsigned char   aiFsmDefendHold_state;
+    int             aiFsmDefendHold_search_counter;
+    UnitID          aiFsmDefendHold_target_ID;
     void setAiFsmDefendHold();
     void aiFsmDefendHold();
 
-    iXY aiFsmMoveToLoc_goal;
-    unsigned char aiFsmMoveToLoc_state;
-    unsigned long aiFsmMoveToLoc_next_square;
-    iXY aiFsmMoveToLoc_next_loc;
-    iXY aiFsmMoveToLoc_prev_loc;
-    Timer	   aiFsmMoveToLoc_wait_timer;
-    bool  aiFsmMoveToLoc_path_not_finished;
-    bool ruleMoveToLoc_GoalReached();
+    iXY             aiFsmMoveToLoc_goal;
+    unsigned char   aiFsmMoveToLoc_state;
+    unsigned long   aiFsmMoveToLoc_next_square;
+    iXY             aiFsmMoveToLoc_next_loc;
+    iXY             aiFsmMoveToLoc_prev_loc;
+    int             aiFsmMoveToLoc_wait_count;
+    bool            aiFsmMoveToLoc_next_marked;
     void aiFsmMoveToLoc_OnExitCleanUp();
     void aiFsmMoveToLoc();
 
-    UnitID   aiFsmAttackUnit_target_ID;
-    iXY aiFsmAttackUnit_target_goal_loc;
-    unsigned char aiFsmAttackUnit_state;
-    unsigned long aiFsmAttackUnit_next_square;
-    iXY aiFsmAttackUnit_next_loc;
-    iXY aiFsmAttackUnit_prev_loc;
-    Timer	   aiFsmAttackUnit_wait_timer;
-    bool  aiFsmAttackUnit_path_not_finished;
-    bool  aiFsmAttackUnit_target_destroyed;
+    UnitID          aiFsmAttackUnit_target_ID;
+    iXY             aiFsmAttackUnit_target_goal_loc;
+    unsigned char   aiFsmAttackUnit_state;
+    unsigned long   aiFsmAttackUnit_next_square;
+    iXY             aiFsmAttackUnit_next_loc;
+    iXY             aiFsmAttackUnit_prev_loc;
+    int             aiFsmAttackUnit_wait_counter;
+    bool            aiFsmAttackUnit_path_not_finished;
+    bool            aiFsmAttackUnit_target_destroyed;
     void aiFsmAttackUnit_OnExitCleanUp();
     void aiFsmAttackUnit();
 
-
-    unsigned char aiFsmManualMove_move_orientation;
-    unsigned char aiFsmManualMove_state;
-    iXY aiFsmManualMove_next_loc;
-    iXY aiFsmManualMove_prev_loc;
-    void aiFsmManualMove();
-
     void fireWeapon( iXY &amp;target_loc );
     virtual unsigned short launchProjectile();
     virtual void soundSelected();
@@ -214,7 +190,6 @@
     void unitOpcodeTrackPoint(const UnitOpcode* opcode );
     void unitOpcodeTrackTarget(const UnitOpcode* opcode );
     void unitOpcodeFireWeapon(const UnitOpcode* opcode );
-    void unitOpcodeSync(const UnitOpcode* opcode );
     void unitOpcodeUpdateState(const UnitOpcode* opcode );
     void unitOpcodeDestruct(const UnitOpcode* opcode );
 
@@ -230,12 +205,10 @@
 
     void setCommandMoveToLoc(const UMesgAICommand* message);
     void setCommandAttackUnit(const UMesgAICommand* message);
-    void setCommandManualMove(const UMesgAICommand* message);
     void setCommandManualFire(const UMesgAICommand* message);
 
     void messageAICommand(const UnitMessage* message);
     void messageWeaponHit(const UnitMessage* message);
-    void messageSelectBoxUpdate(const UnitMessage* message);
     void messageSelfDestruct(const UnitMessage* message);
     
     void setUnitProperties( unsigned char utype );
@@ -249,8 +222,6 @@
 
     virtual void evalCommandOpcode(const UnitOpcode* opcode);
 
-    virtual void syncUnit();
-
     virtual void offloadGraphics( SpriteSorter &amp;sorter );
 
     float smolderWait;

Modified: branches/newpath/src/NetPanzer/Views/Components/MiniMap.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Views/Components/MiniMap.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -207,7 +207,7 @@
         {
             //Only draw our unit collection location
             iXY objdest, src;
-            MapInterface::mapXYtoPointXY(obj-&gt;unit_collection_loc, &amp;objdest);
+            MapInterface::mapXYtoPointXY(obj-&gt;unit_collection_loc, objdest);
             objdest.x = int(float(objdest.x/32) / xratio)+position.x;
             objdest.y = int(float(objdest.y/32) / yratio)+position.y;
             

Modified: branches/newpath/src/NetPanzer/Views/Game/GameView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp	2011-12-15 12:58:19 UTC (rev 1308)
+++ branches/newpath/src/NetPanzer/Views/Game/GameView.cpp	2011-12-21 16:52:46 UTC (rev 1310)
@@ -216,25 +216,23 @@
 GameView::drawMap(Surface &amp;window)
 {
     TileSet * ts = TileInterface::getTileSet();
-    unsigned long world_x;
-    unsigned long world_y;
-    unsigned short map_x;
-    unsigned short map_y;
+    iXY world;
+    iXY map;
     
     WorldViewInterface::getMainCamera()-&gt;getViewStart(window.getWidth(), window.getHeight(),
-                              &amp;world_x, &amp;world_y);
-    MapInterface::pointXYtoMapXY( world_x, world_y, &amp;map_x, &amp;map_y );
+                              &amp;world.x, &amp;world.y);
+    MapInterface::pointXYtoMapXY( world, map );
         
     unsigned short tile_size = ts-&gt;getTileXsize();
     
-    long partial_y = world_y % tile_size;
+    long partial_y = world.y % tile_size;
     int y = 0;
     if ( partial_y )
     {
         y -= partial_y;
     }
     
-    long partial_x = world_x % tile_size;
+    long partial_x = world.x % tile_size;
     int start_x = 0;
     if ( partial_x )
     {
@@ -243,18 +241,40 @@
     
     unsigned int tile = 0;
     
-    WorldMap * map = MapInterface::getMap();
+    WorldMap * worldmap = MapInterface::getMap();
     
     unsigned short tmx;
     
+    char move_val;
+
     for ( ; y &lt; (int)window.getHeight(); y += tile_size )
     {
-        tmx = map_x;
+        tmx = map.x;
         for ( int x = start_x; x &lt; (int)window.getWidth(); x += tile_size )
         {
-            tile = map-&gt;getValue(tmx++, map_y);
+            tile = worldmap-&gt;getValue(tmx++, map.y);
             blitTile(window, tile, x, y);
+            move_val = ts-&gt;getTileMovementValue( tile );
+            switch (move_val)
+            {
+                case 2:
+                    window.drawLine(x, y, x+31, y+31, Color::white);
+                    window.drawLine(x, y+31, x+31, y, Color::white);
+                    break;
+                case 3:
+                    window.drawLine(x, y, x+31, y+31, Color::yellow);
+                    window.drawLine(x, y+31, x+31, y, Color::yellow);
+                    break;
+                case 4:
+                case 5:
+                    window.drawHLine(x,y,x+31,Color::red);
+                    window.drawHLine(x,y+31,x+31,Color::red);
+                    window.drawVLine(x,y,y+31,Color::red);
+                    window.drawVLine(x+31,y,y+31,Color::red);
+                    window.drawLine(x, y, x+31, y+31, Color::red);
+                    window.drawLine(x, y+31, x+31, y, Color::red);
+            }
         }
-        map_y ++;
+        map.y ++;
     }
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000335.html">[Netpanzer-cvs] r1309 - in trunk/netpanzer: scripts	src/NetPanzer/Classes src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Views/Game support/icon
</A></li>
	<LI>Next message: <A HREF="000337.html">[Netpanzer-cvs] r1311 - in trunk/netpanzer: scripts	src/NetPanzer/Classes src/NetPanzer/Classes/Network	src/NetPanzer/Interfaces src/NetPanzer/Scripts support/icon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#336">[ date ]</a>
              <a href="thread.html#336">[ thread ]</a>
              <a href="subject.html#336">[ subject ]</a>
              <a href="author.html#336">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
