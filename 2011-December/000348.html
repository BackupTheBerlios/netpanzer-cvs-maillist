<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1322 - in branches/newpath/src/NetPanzer: Classes	Classes/AI Interfaces Objectives Units Views/Game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2011-December/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1322%20-%20in%20branches/newpath/src/NetPanzer%3A%20Classes%0A%09Classes/AI%20Interfaces%20Objectives%20Units%20Views/Game&In-Reply-To=%3C20111225105816.C02B7480F21%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000347.html">
   <LINK REL="Next"  HREF="000349.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1322 - in branches/newpath/src/NetPanzer: Classes	Classes/AI Interfaces Objectives Units Views/Game</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1322%20-%20in%20branches/newpath/src/NetPanzer%3A%20Classes%0A%09Classes/AI%20Interfaces%20Objectives%20Units%20Views/Game&In-Reply-To=%3C20111225105816.C02B7480F21%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1322 - in branches/newpath/src/NetPanzer: Classes	Classes/AI Interfaces Objectives Units Views/Game">kromxp at mail.berlios.de
       </A><BR>
    <I>Sun Dec 25 11:58:16 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="000347.html">[Netpanzer-cvs] r1321 - trunk/netpanzer/src/NetPanzer/Objectives
</A></li>
        <LI>Next message: <A HREF="000349.html">[Netpanzer-cvs] r1323 - trunk/netpanzer/src/NetPanzer/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#348">[ date ]</a>
              <a href="thread.html#348">[ thread ]</a>
              <a href="subject.html#348">[ subject ]</a>
              <a href="author.html#348">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2011-12-25 11:58:16 +0100 (Sun, 25 Dec 2011)
New Revision: 1322

Modified:
   branches/newpath/src/NetPanzer/Classes/AI/PathList.hpp
   branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp
   branches/newpath/src/NetPanzer/Objectives/Objective.cpp
   branches/newpath/src/NetPanzer/Units/UnitInterface.cpp
   branches/newpath/src/NetPanzer/Units/UnitState.hpp
   branches/newpath/src/NetPanzer/Units/Vehicle.cpp
   branches/newpath/src/NetPanzer/Units/Vehicle.hpp
   branches/newpath/src/NetPanzer/Views/Game/GameView.cpp
   branches/newpath/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
Log:
units move in any direction, some bugs fixed. Bad Neuburg seems playable, but this still uses differnt path for each unit


Modified: branches/newpath/src/NetPanzer/Classes/AI/PathList.hpp
===================================================================
--- branches/newpath/src/NetPanzer/Classes/AI/PathList.hpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Classes/AI/PathList.hpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -22,6 +22,8 @@
 
 #include &lt;string.h&gt;
 
+#include &quot;Util/Log.hpp&quot;
+
 class PathList
 {
 protected:
@@ -95,10 +97,10 @@
         if ( first == last )
             return( false );
 
+        *tile = list[ last ];
+
         last = (last + 1) % size;
 
-        *tile = list[ last ];
-
         return( true );
     }
 
@@ -144,6 +146,21 @@
             PathList::size = rhs.size;
         }
     }
+
+    void logPath(int id)
+    {
+        int save_first = first;
+        unsigned long val = 0;
+        int step = 0;
+        while ( popFirst(&amp;val) )
+        {
+            LOGGER.warning(&quot;Path for %5u[%3u]: %10lu&quot;, id, step, val);
+            ++step;
+        }
+
+        first = save_first;
+    }
+
 };
 
 #endif // ** _PATHLIST_HPP

Modified: branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -21,6 +21,7 @@
 #endif
 
 #include &lt;sstream&gt;
+#include &lt;algorithm&gt;
 #include &quot;WorldInputCmdProcessor.hpp&quot;
 
 #include &quot;Interfaces/MouseInterface.hpp&quot;
@@ -1217,6 +1218,27 @@
 void
 WorldInputCmdProcessor::centerSelectedUnits()
 {
+    iXY min(0x7fffffff, 0x7ffffff);
+    iXY max;
+
+    for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
+        UnitBase* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
+
+        if(unit_ptr == 0)
+            continue;
+
+        min.x = std::min(min.x, unit_ptr-&gt;unit_state.location.x);
+        min.y = std::min(min.y, unit_ptr-&gt;unit_state.location.y);
+        max.x = std::max(max.x, unit_ptr-&gt;unit_state.location.x);
+        max.y = std::max(max.y, unit_ptr-&gt;unit_state.location.y);
+
+    }
+
+    WorldViewInterface::setCameraPosition( min+((max-min)/2) );
+
+
+    // the nice center algorithm unused for now
+
     /** When you want to center the camera on a group of units you have the
      * problem of where to center the camera. The following nice idea+patch is
      * from Christian Hausknecht &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">christian.hausknecht at gmx.de</A>&gt;.
@@ -1227,100 +1249,100 @@
      * group (if that group is in a very long queue passing the map).
      */
 
-    UnitBase *maxyunit = 0;
-    UnitBase *maxxunit = 0;
-    UnitBase *minyunit = 0;
-    UnitBase *minxunit = 0;
+//    UnitBase *maxyunit = 0;
+//    UnitBase *maxxunit = 0;
+//    UnitBase *minyunit = 0;
+//    UnitBase *minxunit = 0;
 
     // Direction initialize
-    int direction[8];
-    for(int i=0;i&lt;8;++i)
-        direction[i]=0;
+//    int direction[8];
+//    for(int i=0;i&lt;8;++i)
+//        direction[i]=0;
 
     // Vote direction
-    bool firstunit = true;
-    for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
-        UnitBase* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
+//    bool firstunit = true;
+//    for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
+//        UnitBase* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
 
-        if(unit_ptr == 0)
-            continue;
+//        if(unit_ptr == 0)
+//            continue;
 
-            // increment one direction
-        direction[unit_ptr-&gt;unit_state.orientation]+=1;
-            // initialize some pointers, get them from first unit
-        if(firstunit) {
-            maxyunit = unit_ptr;
-            maxxunit = unit_ptr;
-            minyunit = unit_ptr;
-            minxunit = unit_ptr;
-            firstunit = false;
-        } // choose extremest in each direction
-        else {
-            if(maxyunit-&gt;unit_state.location.y &lt; unit_ptr-&gt;unit_state.location.y)
-                maxyunit=unit_ptr;
-            if(maxxunit-&gt;unit_state.location.x &lt; unit_ptr-&gt;unit_state.location.x)
-                maxxunit=unit_ptr;
-            if(minyunit-&gt;unit_state.location.y &gt; unit_ptr-&gt;unit_state.location.y)
-                minyunit=unit_ptr;
-            if(minxunit-&gt;unit_state.location.x &gt; unit_ptr-&gt;unit_state.location.x)
-                minxunit=unit_ptr;
-        }
-    }
+//            // increment one direction
+//        direction[unit_ptr-&gt;unit_state.orientation]+=1;
+//            // initialize some pointers, get them from first unit
+//        if(firstunit) {
+//            maxyunit = unit_ptr;
+//            maxxunit = unit_ptr;
+//            minyunit = unit_ptr;
+//            minxunit = unit_ptr;
+//            firstunit = false;
+//        } // choose extremest in each direction
+//        else {
+//            if(maxyunit-&gt;unit_state.location.y &lt; unit_ptr-&gt;unit_state.location.y)
+//                maxyunit=unit_ptr;
+//            if(maxxunit-&gt;unit_state.location.x &lt; unit_ptr-&gt;unit_state.location.x)
+//                maxxunit=unit_ptr;
+//            if(minyunit-&gt;unit_state.location.y &gt; unit_ptr-&gt;unit_state.location.y)
+//                minyunit=unit_ptr;
+//            if(minxunit-&gt;unit_state.location.x &gt; unit_ptr-&gt;unit_state.location.x)
+//                minxunit=unit_ptr;
+//        }
+//    }
 
-    // Index of chosen direction (which is most used by all units of a group)
-    int preferred_direction = 0;
-    int max = -1;
-    for(int i=0;i&lt;8;++i) {
-        if(direction[i] &gt; max) {
-            max=direction[i];
-            preferred_direction = i;
-        }
-    }
+//    // Index of chosen direction (which is most used by all units of a group)
+//    int preferred_direction = 0;
+//    int max = -1;
+//    for(int i=0;i&lt;8;++i) {
+//        if(direction[i] &gt; max) {
+//            max=direction[i];
+//            preferred_direction = i;
+//        }
+//    }
 
-    // Chose Best unit correspondig to chosen direction
-    UnitBase* unit = 0;
-    switch(preferred_direction) {
-      case 0:
-          unit = maxxunit;
-          break;
-      case 1:
-          if(direction[0]&gt;direction[2])
-              unit = maxxunit;
-          else
-              unit = minyunit;
-          break;
-      case 2:
-          unit = minyunit;
-          break;
-      case 3:
-          if(direction[4]&gt;direction[2])
-              unit = minxunit;
-          else
-              unit = minyunit;
-          break;
-      case 4:
-          unit = minxunit;
-          break;
-      case 5:
-          if(direction[4]&gt;direction[6])
-              unit = minxunit;
-          else
-              unit = maxyunit;
-          break;
-      case 6:
-          unit = maxyunit;
-          break;
-      case 7:
-          if(direction[6]&gt;direction[0])
-              unit = maxyunit;
-          else
-              unit = maxxunit;
-          break;
-      default:
-          assert(false);
-          break;
-    }
+//    // Chose Best unit correspondig to chosen direction
+//    UnitBase* unit = 0;
+//    switch(preferred_direction) {
+//      case 0:
+//          unit = maxxunit;
+//          break;
+//      case 1:
+//          if(direction[0]&gt;direction[2])
+//              unit = maxxunit;
+//          else
+//              unit = minyunit;
+//          break;
+//      case 2:
+//          unit = minyunit;
+//          break;
+//      case 3:
+//          if(direction[4]&gt;direction[2])
+//              unit = minxunit;
+//          else
+//              unit = minyunit;
+//          break;
+//      case 4:
+//          unit = minxunit;
+//          break;
+//      case 5:
+//          if(direction[4]&gt;direction[6])
+//              unit = minxunit;
+//          else
+//              unit = maxyunit;
+//          break;
+//      case 6:
+//          unit = maxyunit;
+//          break;
+//      case 7:
+//          if(direction[6]&gt;direction[0])
+//              unit = maxyunit;
+//          else
+//              unit = maxxunit;
+//          break;
+//      default:
+//          assert(false);
+//          break;
+//    }
 
-    if(unit != 0)
-        WorldViewInterface::setCameraPosition(unit-&gt;unit_state.location);
+//    if(unit != 0)
+//        WorldViewInterface::setCameraPosition(unit-&gt;unit_state.location);
 }

Modified: branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Interfaces/PathScheduler.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -128,6 +128,7 @@
         }
     } else
         if ( path_request.request_type == _path_request_update ) {
+
             path_generation_status = _path_generator_status_busy;
             pathing_fsm = _pathing_fsm_update_path;
             pathing_fsm_state = _pathing_fsm_state_initialize;
@@ -252,10 +253,13 @@
         case _pathing_fsm_state_initialize_part_a : {
                 unsigned long abs_new_goal = 0;
                 iXY new_goal;
-
                 working_start = path_request.start;
                 working_goal  = path_request.goal;
 
+                // XXX next 2 temp for test
+                path_splice_length = path_request.path-&gt;listCount()/2;
+                if ( path_splice_length &lt; 15 ) path_splice_length = 15;
+
                 for ( unsigned long i = 0; i &lt; path_splice_length; i++ ) {
                     path_request.path-&gt;popFirst( &amp;abs_new_goal );
                 }
@@ -272,9 +276,19 @@
                 int path_result_code;
 
                 if ( astar.generatePath( &amp;path_request, _path_merge_front, false, &amp;path_result_code ) ) {
-                    pathing_fsm_state = _pathing_fsm_state_initialize_part_b;
 
+                    // XXX temporal for test
+//                    pathing_fsm_state = _pathing_fsm_state_initialize_part_b;
+
+//                    PathingState::update_gen_count++;
+
+                    path_request.goal = working_goal;
+                    path_request.start = working_start;
+                    path_generation_status = _path_generator_status_waiting;
+                    pathing_fsm_state = _pathing_fsm_state_complete;
+
                     PathingState::update_gen_count++;
+
                 } else {
                     end_cycle = true;
                 }
@@ -285,7 +299,6 @@
         case _pathing_fsm_state_initialize_part_b : {
                 unsigned long abs_new_goal = 0;
                 iXY new_goal;
-
                 for ( unsigned long i = 0; i &lt; path_splice_length; i++ ) {
                     path_request.path-&gt;popLast( &amp;abs_new_goal );
                 }
@@ -300,7 +313,6 @@
 
         case _pathing_fsm_state_generate_path_part_b : {
                 int path_result_code;
-
                 if ( astar.generatePath( &amp;path_request, _path_merge_rear, false, &amp;path_result_code ) ) {
                     path_request.goal = working_goal;
                     path_request.start = working_start;
@@ -315,7 +327,7 @@
             break;
 
         case _pathing_fsm_state_complete : {
-                end_cycle = true;
+            end_cycle = true;
             }
             break;
 

Modified: branches/newpath/src/NetPanzer/Objectives/Objective.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Objectives/Objective.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Objectives/Objective.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -46,7 +46,7 @@
     selection_box.max = location + iXY( 64, 32 );
     selection_box.min = location + iXY( -224, -128 );
     this-&gt;area.min = iXY( -400, -144 );
-    this-&gt;area.max = iXY(  400,  240 );
+    this-&gt;area.max = iXY(  304,  240 );
     outpost_type = 0;
 
     unit_generation_type = 0;
@@ -78,6 +78,7 @@
                                       name, new_owner-&gt;getName().c_str() );
     }
     
+    unit_collection_loc = outpost_map_loc + iXY( 13, 13 );
     unit_generation_on_flag = false;
 }
 
@@ -141,23 +142,11 @@
         return; // cannot capture more bases.
     }
 
-    if ( occupying_player )
-    {
-        occupying_player-&gt;decObjectivesHeld();
-    }
+    changeOwner(player);
 
-    occupying_player = player;
-    player-&gt;incObjectivesHeld();
-    unit_collection_loc = outpost_map_loc + iXY( 13, 13 );
-
     ObjectiveOccupationUpdate msg;
     msg.set(id, player-&gt;getID());
     SERVER-&gt;broadcastMessage(&amp;msg, sizeof(msg));
-
-    ConsoleInterface::postMessage(Color::cyan, false, 0,
-                                  &quot;'%s' has been occupied by '%s'&quot;,
-                                  name, player-&gt;getName().c_str() );
-
 }
 
 void

Modified: branches/newpath/src/NetPanzer/Units/UnitInterface.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Units/UnitInterface.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Units/UnitInterface.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -673,14 +673,14 @@
 
 bool UnitInterface::queryUnitAtMapLoc(iXY map_loc, UnitID *queary_unit_id)
 {
-    iXY unit_map_loc;
+//    iXY unit_map_loc;
 
     for(Units::iterator i = units.begin(); i != units.end(); ++i) {
         UnitBase* unit = i-&gt;second;
         UnitState* unit_state = &amp; unit-&gt;unit_state;
             
-        MapInterface::pointXYtoMapXY( unit_state-&gt;location, unit_map_loc );
-        if( map_loc == unit_map_loc ) {
+//        MapInterface::pointXYtoMapXY( unit_state-&gt;location, unit_map_loc );
+        if( map_loc == unit_state-&gt;map_location ) {
             *queary_unit_id = unit-&gt;id;
             return true;
         }

Modified: branches/newpath/src/NetPanzer/Units/UnitState.hpp
===================================================================
--- branches/newpath/src/NetPanzer/Units/UnitState.hpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Units/UnitState.hpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -82,10 +82,13 @@
 
     void setInitialLocation(const iXY&amp; map_loc)
     {
-        subtile_location.x = 128;
-        subtile_location.y = 128;
         map_location = map_loc;
+
+        subtile_location.x = (map_loc.x &lt;&lt; 8 ) + 128;
+        subtile_location.y = (map_loc.y &lt;&lt; 8 ) + 128;
+
         MapInterface::mapXYtoTopPointXY(map_loc, location);
+
         location.x += 128&gt;&gt;3;
         location.y += 128&gt;&gt;3;
     }
@@ -93,39 +96,19 @@
     void subtileMove(const int x, const int y)
     {
         subtile_location.x += x;
+        location.x = subtile_location.x &gt;&gt; 3;
+        map_location.x = location.x &gt;&gt; 5;
+
         subtile_location.y += y;
+        location.y = subtile_location.y &gt;&gt; 3;
+        map_location.y = location.y &gt;&gt; 5;
 
-        location.x &amp;= ~0x1f; // clear the tile bits
-        location.y &amp;= ~0x1f; // clear the tile bits
 
-        if ( subtile_location.x &gt;= 256 )
-        {
-            subtile_location.x &amp;= 0xff;
-            ++map_location.x;
-            location.x += 32; // XXX tile size
-        }
-        else if ( subtile_location.x &lt; 0 )
-        {
-            subtile_location.x &amp;= 0xff;
-            --map_location.x;
-            location.x -= 32; // XXX tile size
-        }
+//        MapInterface::mapXYtoTopPointXY(map_location, location);
 
-        if ( subtile_location.y &gt;= 256 )
-        {
-            subtile_location.y &amp;= 0xff;
-            ++map_location.y;
-            location.y += 32; // XXX tile size
-        }
-        else if ( subtile_location.y &lt; 0 )
-        {
-            subtile_location.y &amp;= 0xff;
-            --map_location.y;
-            location.y -= 32; // XXX tile size
-        }
+//        location.x += (subtile_location.x &amp; 0xff) &gt;&gt; 3;
+//        location.y += (subtile_location.y &amp; 0xff) &gt;&gt; 3;
 
-        location.x += subtile_location.x &gt;&gt; 3;
-        location.y += subtile_location.y &gt;&gt; 3;
     }
 
 };

Modified: branches/newpath/src/NetPanzer/Units/Vehicle.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Units/Vehicle.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Units/Vehicle.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -21,6 +21,7 @@
 
 #include &lt;string.h&gt;
 #include &quot;Util/Log.hpp&quot;
+#include &quot;Util/Math.hpp&quot;
 #include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Units/Vehicle.hpp&quot;
 #include &quot;Units/UnitGlobals.hpp&quot;
@@ -71,6 +72,7 @@
 // the number is the count out of 16, so
 // 13/16 = 0.8125 seconds
 // 14/16 = 0.875 seconds
+// 20 = little more than 1 seccond
 
 #define MOVEWAIT_TIME 13
 
@@ -88,6 +90,8 @@
     unit_state.setInitialLocation(initial_loc);
 
     UnitBlackBoard::markUnitLoc( initial_loc );
+//    if ( id == 1 )
+//        LOGGER.warning(&quot;INK: %5u,%-5u&quot;, initial_loc.x, initial_loc.y );
     setAiFsmDefendHold();
     pending_AI_comm = false;
     unit_state.lifecycle_state = _UNIT_LIFECYCLE_ACTIVE;
@@ -112,10 +116,10 @@
 
     fsmMove_offset_x = fsmMove_offset_y = 0;
 
-    move_opcode_sent = false;
     fsmMoveMapSquare_movement_type = 0;
 
     aiFsmDefendHold_state = 0;
+    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_idle;
 
     // from unit profiles
     setUnitProperties(utype);
@@ -128,8 +132,14 @@
 
     select_info_box.setBoxState( false );
     select_info_box.setFlag( player-&gt;getFlag() );
-    select_info_box.setName( player-&gt;getName() );
 
+    char num[50];
+    memset(num,0,sizeof*(num));
+    sprintf(num,&quot;%u&quot;, id);
+
+//    select_info_box.setName( player-&gt;getName() );
+    select_info_box.setName(num);
+
     body_anim_shadow.attachSprite( &amp;body_anim, zero );
     body_anim_shadow.attachSprite( &amp;turret_anim_shadow, zero );
     body_anim_shadow.attachSprite( &amp;turret_anim, zero );
@@ -149,7 +159,8 @@
     unit_state.defend_range = profile-&gt;defend_range;
     unit_state.speed_factor = profile-&gt;speed_factor;
     unit_state.speed_rate = profile-&gt;speed_rate;
-    unit_state.tilespeed = (unit_state.speed_factor * unit_state.speed_rate) / 2;
+//    unit_state.tilespeed = (unit_state.speed_factor * unit_state.speed_rate) / 2;
+    setMaxSpeed( (unit_state.speed_factor * unit_state.speed_rate) / 2 );
     unit_state.reload_time = profile-&gt;reload_time;
     unit_state.weapon_range = profile-&gt;attack_range;
     unit_state.unit_type = utype;
@@ -185,6 +196,19 @@
 }
 
 
+void Vehicle::setMaxSpeed(unsigned int speed)
+{
+    unit_state.tilespeed = (unit_state.speed_factor * unit_state.speed_rate) / 2;
+    angle_speeds[0].x = unit_state.tilespeed;
+    angle_speeds[0].y = 0;
+
+    for ( int n = 1; n &lt;= 35; n++ )
+    {
+        angle_speeds[n].x = round( (angle_speeds[0].x * Math::getCos(n*10)) - (angle_speeds[0].y * Math::getSin(n*10)) );
+        angle_speeds[n].y = -round( (angle_speeds[0].x * Math::getSin(n*10)) + (angle_speeds[0].y * Math::getCos(n*10)) );
+    }
+}
+
 void Vehicle::updateUnitStateProperties()
 {
     if ( reload_counter &lt; unit_state.reload_time )
@@ -363,9 +387,37 @@
 
 bool Vehicle::fsmBodyRotate()
 {
-    if( unit_state.body_angle.angle_int != fsmBodyRotate_goal_angle )
+//    LOGGER.debug(&quot;[ROT] dest=%6u,%-6u pos=%6u,%-6u cur_ang=%2u[%5d,%-5d]&quot;,
+//                 fsmMove_destination.x, fsmMove_destination.y,
+//                 unit_state.subtile_location.x,unit_state.subtile_location.y,
+//                 unit_state.body_angle.angle_int,
+//                 angle_speeds[unit_state.body_angle.angle_int].x,
+//                 angle_speeds[unit_state.body_angle.angle_int].y
+//                 );
+
+    long goal_angle;
+    long delta;
+    unsigned short rotation;
+    iXY direction_vector;
+
+    direction_vector = fsmMove_destination - unit_state.subtile_location;
+    Angle target_angle;
+    target_angle.set( direction_vector );
+
+    goal_angle = target_angle.DegreesInt( 10 );
+    rotation = shortestRotation( unit_state.body_angle, goal_angle, &amp;delta );
+    if ( delta &lt;= 5 ) // was 9
+        fsmMoveMapSquare_movement_type = _rotate_and_move;
+    else
+        fsmMoveMapSquare_movement_type = _rotate_stop_move;
+//    setFsmTurretRotate( goal_angle, rotation );
+
+//    int to_move_x = angle_speeds[unit_state.body_angle.angle_int].x;
+//    int to_move_y = angle_speeds[unit_state.body_angle.angle_int].y;
+
+    if( unit_state.body_angle.angle_int != goal_angle )
     {
-        if ( fsmBodyRotate_rotation == _rotate_pos )
+        if ( rotation == _rotate_pos )
         {
             ++unit_state.body_angle;
         }
@@ -379,7 +431,7 @@
         return( true );   // goal direction achieved
     }
 
-    return( false );
+    return delta &lt;= 5;
 }
 
 void Vehicle::setFsmTurretRotate( long goal_angle, unsigned short rotation )
@@ -411,40 +463,48 @@
 
 void Vehicle::setFsmMove( unsigned short orientation )
 {
-    orientationToOffset( orientation, &amp;fsmMove_offset_x, &amp;fsmMove_offset_y );
 
-    fsmMove_to_move.x = abs(256 * fsmMove_offset_x);
-    fsmMove_to_move.y = abs(256 * fsmMove_offset_y);
-    fsmMove_moved.zero();
 
 }
 
 bool Vehicle::fsmMove()
 {
-    int to_move_x = unit_state.tilespeed * fsmMove_offset_x;
-    int to_move_y = unit_state.tilespeed * fsmMove_offset_y;
+//    int to_move_x = unit_state.tilespeed * fsmMove_offset_x;
+//    int to_move_y = unit_state.tilespeed * fsmMove_offset_y;
 
-    fsmMove_moved.x += abs(to_move_x);
-    fsmMove_moved.y += abs(to_move_y);
+    int to_move_x = angle_speeds[unit_state.body_angle.angle_int].x;
+    int to_move_y = angle_speeds[unit_state.body_angle.angle_int].y;
 
-    if ( fsmMove_moved &gt;= fsmMove_to_move )
-    {
-        int adj_x = fsmMove_moved.x - fsmMove_to_move.x;
-        int adj_y = fsmMove_moved.y - fsmMove_to_move.y;
+    int to_move_distance_sq = (to_move_x * to_move_x) + (to_move_y * to_move_y);
 
-        to_move_x += adj_x * fsmMove_offset_x;
-        to_move_y += adj_y * fsmMove_offset_y;
+    int remain_x = fsmMove_destination.x - unit_state.subtile_location.x;
+    int remain_y = fsmMove_destination.y - unit_state.subtile_location.y;
 
-        fsmMove_moved.x -= adj_x;
-        fsmMove_moved.y -= adj_y;
+    int remain_distance_sq = (remain_x * remain_x) + (remain_y * remain_y);
+
+    if ( remain_distance_sq &lt;= to_move_distance_sq )
+    {
+        unit_state.subtileMove(remain_x, remain_y);
+        aiFsmMoveToLoc_about_to_arrive = true;
+        return true;
     }
 
-    unit_state.subtileMove( unit_state.tilespeed * fsmMove_offset_x
-                           ,unit_state.tilespeed * fsmMove_offset_y);
+    unit_state.subtileMove(to_move_x, to_move_y);
 
+    // if we arrive in 2 steps (now and the next) say we are about to arrive.
+    // 2*2 is next 2 moves;
+    // 3*3 is next 3 moves
+    // 4*4 is next 4 moves
+    aiFsmMoveToLoc_about_to_arrive = remain_distance_sq &lt;= (to_move_distance_sq*(2*2))
+            || (
+                (fsmMove_destination.x&gt;&gt;8) == unit_state.map_location.x
+                &amp;&amp;(fsmMove_destination.y&gt;&gt;8) == unit_state.map_location.y
+                );
+
+
     ParticleInterface::addMoveDirtPuff(unit_state);
 
-    return fsmMove_moved == fsmMove_to_move;
+    return false;
 }
 
 void Vehicle::setFsmMoveMapSquare( unsigned long square )
@@ -457,14 +517,24 @@
     rotation = shortestRotation( unit_state.body_angle, goal_angle, &amp;delta );
 
     setFsmBodyRotate( goal_angle, rotation );
-    setFsmMove( unit_state.orientation );
+    // setFsmMove( unit_state.orientation );
 
-    if ( delta &lt;= 9 )
+    orientationToOffset( unit_state.orientation, &amp;fsmMove_offset_x, &amp;fsmMove_offset_y );
+
+    MapInterface::offsetToMapXY(square, fsmMove_destination);
+    fsmMove_destination.x &lt;&lt;= 8;
+    fsmMove_destination.x += 128;
+
+    fsmMove_destination.y &lt;&lt;= 8;
+    fsmMove_destination.y += 128;
+
+    if ( delta &lt;= 5 ) // was 9
         fsmMoveMapSquare_movement_type = _rotate_and_move;
     else
         fsmMoveMapSquare_movement_type = _rotate_stop_move;
 
     fsm_active_list[ _control_move_map_square ] = true;
+    aiFsmMoveToLoc_about_to_arrive = false;
 
     if ( NetworkState::status == _network_state_server )
     {
@@ -476,10 +546,7 @@
         locationOffset( square, loc_offset );
         move_opcode.loc_x_offset = (signed char) loc_offset.x;
         move_opcode.loc_y_offset = (signed char) loc_offset.y;
-        if ( move_opcode_sent == true )
-        {
-            UnitInterface::sendOpcode(&amp;move_opcode);
-        }
+        UnitInterface::sendOpcode(&amp;move_opcode);
     }
 
 }
@@ -489,33 +556,15 @@
 
 bool Vehicle::fsmMoveMapSquare()
 {
-    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-    {
-        if ( opcode_move_timer.count() )
-        {
-            UnitInterface::sendOpcode(&amp;move_opcode);
-            move_opcode_sent = true;
-        }
-    }
-
     switch( fsmMoveMapSquare_movement_type )
     {
         case  _rotate_stop_move :
         {
             if ( fsmBodyRotate() )
             {
-                if ( fsmMove() )
-                {
-                    fsm_active_list[ _control_move_map_square ] = false;
-
-                    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-                    {
-                        UnitInterface::sendOpcode(&amp;move_opcode);
-                        move_opcode_sent = true;
-                    }
-
-                    return( true );
-                }
+                bool result = !fsmMove();
+                fsm_active_list[ _control_move_map_square ] = result;
+                return result;
             }
         }
         break;
@@ -523,23 +572,15 @@
         case _rotate_and_move :
         {
             fsmBodyRotate();
-            if ( fsmMove() )
-            {
-                fsm_active_list[ _control_move_map_square ] = false;
 
-                if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-                {
-                    UnitInterface::sendOpcode(&amp;move_opcode);
-                    move_opcode_sent = true;
-                }
-
-                return( true );
-            }
+            bool result = !fsmMove();
+            fsm_active_list[ _control_move_map_square ] = result;
+            return result;
         }
         break;
     } // ** switch
 
-    return( false );
+    return false;
 }
 
 
@@ -842,6 +883,7 @@
 
     switch ( aiFsmMoveToLoc_state )
     {
+        case _aiFsmMoveToLoc_idle: break;
         // *************************************************************
         case _aiFsmMoveToLoc_path_generate :
             if ( ! PathScheduler::queryPath(id) )
@@ -850,6 +892,8 @@
                 break;
             }
             aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+//if ( id==9)
+//    path.logPath(id);
             // fall through, no break
 
         // *************************************************************
@@ -869,6 +913,12 @@
                 //  Action : Request path generation to goal
                 PathRequest path_request;
 
+
+//                if ( id == 9)
+                LOGGER.warning(&quot;Path end requst new %5u from %6u,%-6u to %6u,%-6u&quot;, id,
+                               unit_state.map_location.x, unit_state.map_location.y,
+                               aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
+
                 //LOG( (&quot;Incomplete Path -- Regenerating Path&quot;) );
                 path_request.set(id, unit_state.map_location, aiFsmMoveToLoc_goal, 0,  &amp;path, _path_request_full );
                 PathScheduler::requestPath( path_request );
@@ -877,6 +927,13 @@
             }
 
             MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, aiFsmMoveToLoc_next_loc );
+//            if ( id == 9 )
+//            {
+//                LOGGER.warning(&quot;NEX[%5u]: %5u,%-5u current is: %5u,%-5u&quot;, id,
+//                               aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y,
+//                               unit_state.map_location.x, unit_state.map_location.y
+//                               );
+//            }
             aiFsmMoveToLoc_wait_count = 0;
             aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
 
@@ -890,15 +947,54 @@
             {
                 // Rule: NextSquareOccupied is false
                 // Action: Begin move to next square
+//if ( id == 9 )
+//                    LOGGER.warning(&quot;LCK[%5u]: %5u,%-5u&quot;, id, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y );
                 UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
                 aiFsmMoveToLoc_next_marked = true;
+//                LOGGER.debug(&quot;Seeting unit %u to square %u = %u,%u&quot;, id,
+//                             aiFsmMoveToLoc_next_square,
+//                             aiFsmMoveToLoc_next_loc.x,
+//                             aiFsmMoveToLoc_next_loc.y);
                 setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
 
-                aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
+//                if ( path.listCount() == 1 &amp;&amp; MapInterface::mapXYtoOffset(aiFsmMoveToLoc_goal) != path.peekLast() )
+//                {
+//                    LOGGER.warning(&quot;Pre     Update Path %5u from %6u,%-6u to %6u,%-6u&quot;, id,
+//                                   aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
+//                                   aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
+//                    PathRequest path_request;
+//                    path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
+//    //                        path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
+//                    PathScheduler::requestPath( path_request );
+//                }
+
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
             }
             else
             {
-                if ( ++aiFsmMoveToLoc_wait_count &gt;= MOVEWAIT_TIME)
+                UnitID other_id = 0xffff;
+                UnitInterface::queryUnitAtMapLoc(aiFsmMoveToLoc_next_loc, &amp;other_id);
+                Vehicle *other = other_id == 0xffff ? 0 : (Vehicle*)UnitInterface::getUnit(other_id);
+
+//                if ( other_id == 0xffff)
+//                {
+//                    LOGGER.warning(&quot;[%5u]Other unit reserved the square&quot;, id);
+//                }
+
+//                if ( other == this )
+//                {
+//                    LOGGER.warning(&quot;I colide with myself: %5u my loc: %5u,%-5u next %5u,%-5u&quot;, id,
+//                                   unit_state.map_location.x, unit_state.map_location.y,
+//                                   aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y
+//                                   );
+//                    setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
+//                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
+////                    aiFsmMoveToLoc_next_marked = true;
+//                    goto skipbreak;
+//                }
+
+                if ( (other &amp;&amp; other-&gt;aiFsmMoveToLoc_state == _aiFsmMoveToLoc_idle) || ++aiFsmMoveToLoc_wait_count &gt;= MOVEWAIT_TIME)
+//                if ( other-&gt;aiFsmMoveToLoc_state == _aiFsmMoveToLoc_idle )
                 {
                     // Rule: NextSquareOccupied is true AND WaitTimer is finished
                     // Action: Preform path update
@@ -907,6 +1003,10 @@
 
                         UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
                         UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
+//if ( id == 9)
+                        LOGGER.warning(&quot;Request New Path to %5u from %6u,%-6u to %6u,%-6u&quot;, id,
+                                       aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
+                                       aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
 
                         PathRequest path_request;
                         path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
@@ -914,11 +1014,13 @@
                     }
                     else
                     {
-//                            LOGGER.warning(&quot;Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
-//                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
-//                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
+//if ( id == 9)
+                        LOGGER.warning(&quot;Request Update Path %c %5u from %6u,%-6u to %6u,%-6u&quot;, (other&amp;&amp;other-&gt;aiFsmMoveToLoc_state == _aiFsmMoveToLoc_idle)?'*':'-', id,
+                                       aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
+                                       aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
                         PathRequest path_request;
                         path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
+//                        path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
                         PathScheduler::requestPath( path_request );
                     }
 
@@ -926,7 +1028,6 @@
                 }
                 break;
             }
-
         }
         // fall through, no break
 
@@ -935,9 +1036,11 @@
         case _aiFsmMoveToLoc_move_wait :
         {
             // MoveFinished : has the low level fsm finshed
-            if ( fsm_active_list[ _control_move_map_square ] == false )
+            if ( aiFsmMoveToLoc_about_to_arrive )
             {
                 UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+//if ( id == 9 )
+//                    LOGGER.warning(&quot;UNK[%5u]: %5u,%-5u&quot;, id, aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y );
                 aiFsmMoveToLoc_prev_loc = aiFsmMoveToLoc_next_loc;
                 aiFsmMoveToLoc_next_marked = false;
                 aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
@@ -950,6 +1053,7 @@
 
 void Vehicle::aiFsmMoveToLoc_OnExitCleanUp()
 {
+    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_idle;
     PathScheduler::killRequest(id);
     clearFsmTurretTrackPoint();
 }
@@ -1199,7 +1303,7 @@
 
             case _aiFsmAttackUnit_move_wait :
             {
-                if ( fsm_active_list[ _control_move_map_square ] == false )
+                if ( aiFsmMoveToLoc_about_to_arrive )
                 {
                     UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
@@ -1454,7 +1558,7 @@
 {
     if ( unit_state.threat_level == _threat_level_under_attack )
     {
-        if( threat_level_under_attack_timer.count() )
+        if( ++threat_level_under_attack_counter &gt;= 30*16 ) // 30 secconds
         {
             unit_state.threat_level = _threat_level_all_clear;
         }
@@ -1557,10 +1661,6 @@
     ai_command_state = _ai_command_move_to_loc;
     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
 
-    opcode_move_timer.changePeriod( 0.10f );
-    move_opcode_sent = false;
-    //move_opcode_sent = true;
-
     //LOG( (&quot;UnitID %d, %d : Start %d, %d : Goal %d, %d&quot;, id.getPlayer(), id.getIndex(),
     //                                                    start.x, start.y,
     //                                                    aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
@@ -1600,10 +1700,6 @@
     path_request.set( id, unit_state.map_location, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
     PathScheduler::requestPath( path_request );
 
-    opcode_move_timer.changePeriod( 0.10f );
-    move_opcode_sent = false;
-    //move_opcode_sent = true;
-
     setFsmGunneryTarget( aiFsmAttackUnit_target_ID );
 }
 
@@ -1640,8 +1736,7 @@
 
     unit_state.hit_points -= weapon_hit-&gt;getDamageFactor();
     unit_state.threat_level = _threat_level_under_attack;
-    threat_level_under_attack_timer.changePeriod(
-            gameconfig-&gt;attacknotificationtime);
+    threat_level_under_attack_counter = 0;
 
     UpdateStateUnitOpcode update_state_opcode;
 
@@ -1766,7 +1861,7 @@
     unit_state.hit_points = update_state_opcode-&gt;getHitPoints();
 
     unit_state.threat_level = _threat_level_under_attack;
-    threat_level_under_attack_timer.changePeriod( 30 );
+    threat_level_under_attack_counter = 0;
 }
 
 void Vehicle::unitOpcodeDestruct(const UnitOpcode* )
@@ -1786,7 +1881,7 @@
                 {
                     move_opcode_queue.pop();
                 }
-                //ConsoleInterface::postMessage( &quot;Move Opcode Queue Adjusted&quot; );
+                LOGGER.debug(&quot;Move Opcode Queue Adjusted&quot; );
             }
             UnitOpcodeStruct opcodedata = move_opcode_queue.front();
             move_opcode_queue.pop();

Modified: branches/newpath/src/NetPanzer/Units/Vehicle.hpp
===================================================================
--- branches/newpath/src/NetPanzer/Units/Vehicle.hpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Units/Vehicle.hpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -20,7 +20,6 @@
 #include &lt;string&gt;
 
 #include &quot;Units/UnitBase.hpp&quot;
-#include &quot;Util/Timer.hpp&quot;
 #include &quot;Classes/UnitMessageTypes.hpp&quot;
 #include &quot;Units/UnitOpcodes.hpp&quot;
 #include &quot;Classes/AI/PathList.hpp&quot;
@@ -57,7 +56,8 @@
        _ai_command_attack_unit,
        _ai_command_defend_hold };
 
-enum { _aiFsmMoveToLoc_path_generate,
+enum { _aiFsmMoveToLoc_idle,
+       _aiFsmMoveToLoc_path_generate,
        _aiFsmMoveToLoc_check_goal,
        _aiFsmMoveToLoc_wait_clear_loc,
        _aiFsmMoveToLoc_move_wait };
@@ -126,14 +126,11 @@
 
     signed char fsmMove_offset_x;
     signed char fsmMove_offset_y;
-    iXY         fsmMove_to_move;
-    iXY         fsmMove_moved;
+    iXY         fsmMove_destination;
     void setFsmMove( unsigned short orientation );
     bool fsmMove();
 
     MoveOpcode move_opcode;
-    Timer opcode_move_timer;
-    bool move_opcode_sent;
     unsigned char fsmMoveMapSquare_movement_type;
     void setFsmMoveMapSquare( unsigned long square );
     bool fsmMoveMapSquare();
@@ -171,6 +168,7 @@
     void setAiFsmDefendHold();
     void aiFsmDefendHold();
 
+    bool            aiFsmMoveToLoc_about_to_arrive;
     iXY             aiFsmMoveToLoc_goal;
     unsigned char   aiFsmMoveToLoc_state;
     unsigned long   aiFsmMoveToLoc_next_square;
@@ -197,7 +195,7 @@
     virtual unsigned short launchProjectile();
     virtual void soundSelected();
 
-    TimerFrameBase threat_level_under_attack_timer;
+    int             threat_level_under_attack_counter;
     void accessThreatLevels();
 
     void updateFsmState();
@@ -231,6 +229,9 @@
     
     void setUnitProperties( unsigned char utype );
 
+    void setMaxSpeed( unsigned int speed );
+    iXY angle_speeds[36];
+
 public:
     Vehicle(PlayerState* player, unsigned char utype, UnitID id, iXY initial_loc);
 

Modified: branches/newpath/src/NetPanzer/Views/Game/GameView.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Views/Game/GameView.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Views/Game/GameView.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -48,6 +48,8 @@
 #include &quot;Views/Components/InfoBar.hpp&quot;
 #include &quot;Views/Components/MiniMap.hpp&quot;
 
+#include &quot;Units/UnitBlackBoard.hpp&quot;
+
 int GameView::gDrawSolidBackground = 0;
 
 // GameView
@@ -274,6 +276,15 @@
                     window.drawLine(x, y, x+31, y+31, Color::red);
                     window.drawLine(x, y+31, x+31, y, Color::red);
             }
+
+            iXY maploc(tmx-1, map.y);
+            if ( UnitBlackBoard::unitOccupiesLoc( maploc) )
+            {
+                window.drawHLine(x+5,y+5,x+26,Color::yellow);
+                window.drawHLine(x+5,y+26,x+26,Color::yellow);
+                window.drawVLine(x+5,y+5,y+26,Color::yellow);
+                window.drawVLine(x+26,y+5,y+26,Color::yellow);
+            }
         }
         map.y ++;
     }

Modified: branches/newpath/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
===================================================================
--- branches/newpath/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2011-12-24 16:38:24 UTC (rev 1321)
+++ branches/newpath/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2011-12-25 10:58:16 UTC (rev 1322)
@@ -624,6 +624,17 @@
             }
             dest.bltString(pos.x, pos.y, outpostNameBuf, Color::white);
         }
+
+        iRect ar = obj-&gt;area.getAbsRect(obj-&gt;location);
+
+//        ar.translate(ar.min - gameViewRect.min);
+
+        iRect ar2;
+
+        ar2.min = ar.min - gameViewRect.min;
+        ar2.max = ar2.min + ar.getSize();
+
+        dest.drawRect(ar2, Color::yellow);
     }
 
 } // end VehicleSelectionView::drawMiniProductionStatus


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000347.html">[Netpanzer-cvs] r1321 - trunk/netpanzer/src/NetPanzer/Objectives
</A></li>
	<LI>Next message: <A HREF="000349.html">[Netpanzer-cvs] r1323 - trunk/netpanzer/src/NetPanzer/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#348">[ date ]</a>
              <a href="thread.html#348">[ thread ]</a>
              <a href="subject.html#348">[ subject ]</a>
              <a href="author.html#348">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
