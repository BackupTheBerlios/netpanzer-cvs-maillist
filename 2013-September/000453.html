<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1432 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject	projects/netpanzer-svn-windows/nbproject/private src/Lib/2D	src/Lib/2D/Components src/Lib/Types	src/NetPanzer/Scenes/MainMenu src/NetPanzer/Views/Game	src/NetPanzer/Views/MainMenu/Multi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2013-September/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1432%20-%20in%20trunk/netpanzer%3A%0A%09projects/netpanzer-svn-windows/nbproject%0A%09projects/netpanzer-svn-windows/nbproject/private%20src/Lib/2D%0A%09src/Lib/2D/Components%20src/Lib/Types%0A%09src/NetPanzer/Scenes/MainMenu%20src/NetPanzer/Views/Game%0A%09src/NetPanzer/Views/MainMenu/Multi&In-Reply-To=%3C20130908235805.473D355B0C%40scm.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000452.html">
   <LINK REL="Next"  HREF="000454.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1432 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject	projects/netpanzer-svn-windows/nbproject/private src/Lib/2D	src/Lib/2D/Components src/Lib/Types	src/NetPanzer/Scenes/MainMenu src/NetPanzer/Views/Game	src/NetPanzer/Views/MainMenu/Multi</H1>
    <B>kromxp at scm.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1432%20-%20in%20trunk/netpanzer%3A%0A%09projects/netpanzer-svn-windows/nbproject%0A%09projects/netpanzer-svn-windows/nbproject/private%20src/Lib/2D%0A%09src/Lib/2D/Components%20src/Lib/Types%0A%09src/NetPanzer/Scenes/MainMenu%20src/NetPanzer/Views/Game%0A%09src/NetPanzer/Views/MainMenu/Multi&In-Reply-To=%3C20130908235805.473D355B0C%40scm.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1432 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject	projects/netpanzer-svn-windows/nbproject/private src/Lib/2D	src/Lib/2D/Components src/Lib/Types	src/NetPanzer/Scenes/MainMenu src/NetPanzer/Views/Game	src/NetPanzer/Views/MainMenu/Multi">kromxp at scm.berlios.de
       </A><BR>
    <I>Mon Sep  9 01:58:05 CEST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="000452.html">[Netpanzer-cvs] r1430 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject	projects/netpanzer-svn-windows/nbproject/private src/Lib/2D	src/Lib/2D/Components src/Lib/ArrayUtil src/Lib/GameInput	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Scenes src/NetPanzer/Scenes/Common	src/NetPanzer/Scenes/MainMenu src/NetPanzer/Views/Components	src/NetPanzer/Views/MainMenu
</A></li>
        <LI>Next message: <A HREF="000454.html">[Netpanzer-cvs] r1433 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject/private	src/Lib/2D/Components src/NetPanzer/Scenes/MainMenu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#453">[ date ]</a>
              <a href="thread.html#453">[ thread ]</a>
              <a href="subject.html#453">[ subject ]</a>
              <a href="author.html#453">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2013-09-09 01:58:04 +0200 (Mon, 09 Sep 2013)
New Revision: 1432

Added:
   trunk/netpanzer/src/Lib/2D/Components/Table.cpp
   trunk/netpanzer/src/Lib/2D/Components/Table.hpp
Modified:
   trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/configurations.xml
   trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/configurations.xml
   trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/private.xml
   trunk/netpanzer/src/Lib/2D/Components/Button.cpp
   trunk/netpanzer/src/Lib/2D/Components/ScrollableList.cpp
   trunk/netpanzer/src/Lib/2D/Components/ScrollableList.hpp
   trunk/netpanzer/src/Lib/2D/Components/VScrollBar.cpp
   trunk/netpanzer/src/Lib/2D/Components/VScrollBar.hpp
   trunk/netpanzer/src/Lib/2D/Surface.cpp
   trunk/netpanzer/src/Lib/2D/Surface.hpp
   trunk/netpanzer/src/Lib/Types/UString.hpp
   trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.cpp
   trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.hpp
   trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp
   trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/ServerListView.cpp
Log:
Added a Table component, still needs row selection

Modified: trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/configurations.xml
===================================================================
--- trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/configurations.xml	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/configurations.xml	2013-09-08 23:58:04 UTC (rev 1432)
@@ -22,6 +22,8 @@
               &lt;in&gt;Separator.hpp&lt;/in&gt;
               &lt;in&gt;Slider.cpp&lt;/in&gt;
               &lt;in&gt;Slider.hpp&lt;/in&gt;
+              &lt;in&gt;Table.cpp&lt;/in&gt;
+              &lt;in&gt;Table.hpp&lt;/in&gt;
               &lt;in&gt;VScrollBar.cpp&lt;/in&gt;
               &lt;in&gt;VScrollBar.hpp&lt;/in&gt;
             &lt;/df&gt;
@@ -929,6 +931,16 @@
             tool=&quot;3&quot;
             flavor2=&quot;0&quot;&gt;
       &lt;/item&gt;
+      &lt;item path=&quot;../../src/Lib/2D/Components/Table.cpp&quot;
+            ex=&quot;false&quot;
+            tool=&quot;1&quot;
+            flavor2=&quot;0&quot;&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;../../src/Lib/2D/Components/Table.hpp&quot;
+            ex=&quot;false&quot;
+            tool=&quot;3&quot;
+            flavor2=&quot;0&quot;&gt;
+      &lt;/item&gt;
       &lt;item path=&quot;../../src/Lib/2D/Components/VScrollBar.cpp&quot;
             ex=&quot;false&quot;
             tool=&quot;1&quot;
@@ -7460,6 +7472,16 @@
             tool=&quot;3&quot;
             flavor2=&quot;0&quot;&gt;
       &lt;/item&gt;
+      &lt;item path=&quot;../../src/Lib/2D/Components/Table.cpp&quot;
+            ex=&quot;false&quot;
+            tool=&quot;1&quot;
+            flavor2=&quot;0&quot;&gt;
+      &lt;/item&gt;
+      &lt;item path=&quot;../../src/Lib/2D/Components/Table.hpp&quot;
+            ex=&quot;false&quot;
+            tool=&quot;3&quot;
+            flavor2=&quot;0&quot;&gt;
+      &lt;/item&gt;
       &lt;item path=&quot;../../src/Lib/2D/Components/VScrollBar.cpp&quot;
             ex=&quot;false&quot;
             tool=&quot;1&quot;

Modified: trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/configurations.xml
===================================================================
--- trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/configurations.xml	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/configurations.xml	2013-09-08 23:58:04 UTC (rev 1432)
@@ -288,6 +288,8 @@
               &lt;in&gt;Separator.hpp&lt;/in&gt;
               &lt;in&gt;Slider.cpp&lt;/in&gt;
               &lt;in&gt;Slider.hpp&lt;/in&gt;
+              &lt;in&gt;Table.cpp&lt;/in&gt;
+              &lt;in&gt;Table.hpp&lt;/in&gt;
               &lt;in&gt;VScrollBar.cpp&lt;/in&gt;
               &lt;in&gt;VScrollBar.hpp&lt;/in&gt;
             &lt;/df&gt;

Modified: trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/private.xml
===================================================================
--- trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/private.xml	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/projects/netpanzer-svn-windows/nbproject/private/private.xml	2013-09-08 23:58:04 UTC (rev 1432)
@@ -5,13 +5,19 @@
     &lt;/code-assistance-data&gt;
     &lt;data xmlns=&quot;<A HREF="http://www.netbeans.org/ns/make-project-private/1">http://www.netbeans.org/ns/make-project-private/1</A>&quot;&gt;
         &lt;activeConfTypeElem&gt;0&lt;/activeConfTypeElem&gt;
-        &lt;activeConfIndexElem&gt;1&lt;/activeConfIndexElem&gt;
+        &lt;activeConfIndexElem&gt;0&lt;/activeConfIndexElem&gt;
     &lt;/data&gt;
     &lt;editor-bookmarks xmlns=&quot;<A HREF="http://www.netbeans.org/ns/editor-bookmarks/2">http://www.netbeans.org/ns/editor-bookmarks/2</A>&quot; lastBookmarkId=&quot;0&quot;/&gt;
     &lt;open-files xmlns=&quot;<A HREF="http://www.netbeans.org/ns/projectui-open-files/2">http://www.netbeans.org/ns/projectui-open-files/2</A>&quot;&gt;
         &lt;group&gt;
-            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/NetPanzer/Views/MainMenu/Multi/ServerListView.hpp&lt;/file&gt;
-            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/NetPanzer/Views/MainMenu/Multi/ServerListView.cpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/NetPanzer/Scenes/MainMenu/IntroLayer.cpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/Table.hpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/ScrollableList.hpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/VScrollBar.hpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/VScrollBar.cpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/Table.cpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/NetPanzer/Scenes/MainMenu/IntroLayer.hpp&lt;/file&gt;
+            &lt;file&gt;file:/C:/prog/netpanzer-svn/src/Lib/2D/Components/ScrollableList.cpp&lt;/file&gt;
         &lt;/group&gt;
     &lt;/open-files&gt;
     &lt;preferences xmlns=&quot;<A HREF="http://www.netbeans.org/ns/auxiliary-configuration-preferences/1">http://www.netbeans.org/ns/auxiliary-configuration-preferences/1</A>&quot;&gt;

Modified: trunk/netpanzer/src/Lib/2D/Components/Button.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/Button.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Components/Button.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -24,6 +24,7 @@
 #include &quot;Actions/Action.hpp&quot;
 #include &quot;2D/ComponentEvents.hpp&quot;
 #include &quot;Util/NTimer.hpp&quot;
+#include &quot;2D/TextRenderingSystem.hpp&quot;
 
 Button::Button()
 {
@@ -168,7 +169,7 @@
 
 void Button::setTextButtonSize(int xsize)
 {
-    Component::setSize(xsize+(extraBorder*2), Surface::getFontHeight() + 4 + (extraBorder*2));
+    Component::setSize(xsize+(extraBorder*2), TextRenderingSystem::line_height() + 4 + (extraBorder*2));
     painted_bstate = BMAX_STATE;
 }
 

Modified: trunk/netpanzer/src/Lib/2D/Components/ScrollableList.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/ScrollableList.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Components/ScrollableList.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -49,7 +49,6 @@
 {
     firstVisibleLineIterator = lines.end();
     totalLinesHeight = 0;
-    totalDisplayStart = 0;
     rendedTotalDisplayStart = 0; // or -1?
     maxLines = 1000;
     visibleWidth = 0;
@@ -122,16 +121,17 @@
 void ScrollableList::setLocation(const int x, const int y)
 {
     Component::setLocation(x, y);
-    const int x_start = (rect.getEndX() - BSIZE) + 1;
-    scrollbar-&gt;setLocation(x_start, y);
+    const int x_start = rect.getEndX() - scrollbar-&gt;getWidth();
+    scrollbar-&gt;setLocation(x_start+1, y);
 }
 
 void ScrollableList::setSize(const int x, const int y)
 {
     Component::setSize(x, y);
-    scrollbar-&gt;setSize(BSIZE, y);
-//    scrollbar-&gt;setVisibleHeight(y); // @todo shall remove this or keep?
-    visibleWidth = x - BSIZE;
+    scrollbar-&gt;setVisibleHeight(y);
+    visibleWidth = x - scrollbar-&gt;getWidth();
+    const int x_start = rect.getEndX() - scrollbar-&gt;getWidth();
+    scrollbar-&gt;setLocation(x_start+1, scrollbar-&gt;getLocationY());
 }
 
 void ScrollableList::draw(Surface&amp; s) const
@@ -170,7 +170,6 @@
     {
         case Events::ScrollChange:
 //            LOGGER.warning(&quot;Scroll pos changed: %d&quot;, scrollSlider-&gt;getValue());
-            totalDisplayStart = scrollbar-&gt;getValue();
             dirty = true;
             break;
     }
@@ -180,32 +179,35 @@
     // @todo optimize the rendering, it is possible that doesn't need to re-render all
     if ( dirty )
     {
+        dirty = false;
+
         visibleRenders.deleteAll();
         if ( lines.size() )
         {
-            if ( rendedTotalDisplayStart &lt; totalDisplayStart )
+            const int scrollpos = scrollbar-&gt;getValue();
+            if ( rendedTotalDisplayStart &lt; scrollpos )
             {
                 // note: in theory all data is correct and iterator++ cannot fail.
-                while ( (rendedTotalDisplayStart + firstVisibleLineIterator-&gt;height - 1) &lt; totalDisplayStart )
+                while ( (rendedTotalDisplayStart + firstVisibleLineIterator-&gt;height - 1) &lt; scrollpos )
                 {
                     rendedTotalDisplayStart += firstVisibleLineIterator-&gt;height;
                     firstVisibleLineIterator++;
                 }
             }
-            else if ( rendedTotalDisplayStart &gt; totalDisplayStart )
+            else if ( rendedTotalDisplayStart &gt; scrollpos )
             {
                 // note: in theory all data is correct and iterator++ cannot fail.
                 do
                 {
                     firstVisibleLineIterator--;
                     rendedTotalDisplayStart -= firstVisibleLineIterator-&gt;height;
-                } while ( rendedTotalDisplayStart &gt; totalDisplayStart );
+                } while ( rendedTotalDisplayStart &gt; scrollpos );
             }
             
             TextRenderer * tr;
             std::list&lt;ListElement&gt;::iterator i = firstVisibleLineIterator;
             int cur_h = rendedTotalDisplayStart;
-            const int end_h = totalDisplayStart + getHeight();
+            const int end_h = scrollpos + getHeight();
             
             do
             {
@@ -215,11 +217,9 @@
                 i++;
             } while ( i != lines.end() &amp;&amp; (cur_h &lt; end_h) );
             
-            drawRenderOffset = totalDisplayStart - rendedTotalDisplayStart;
+            drawRenderOffset = scrollpos - rendedTotalDisplayStart;
             
-            dirty = false;
         }
-        
     }
 }
 
@@ -265,19 +265,20 @@
     {
         if ( scrollbar-&gt;contains(mx, my) )
         {
-            if ( hoveringScrollbar )
+            if ( ! hoveringScrollbar )
             {
                 hoveringScrollbar = true;
                 scrollbar-&gt;onHoverStart();
-                scrollbar-&gt;onPointerMove(rel_x, rel_y);
             }
+            
+            scrollbar-&gt;onPointerMove(rel_x, rel_y);
         }
         else
         {
             if ( hoveringScrollbar )
             {
                 hoveringScrollbar = false;
-                scrollbar-&gt;onHoverStart();
+                scrollbar-&gt;onHoverStop();
             }
         }
     }

Modified: trunk/netpanzer/src/Lib/2D/Components/ScrollableList.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/ScrollableList.hpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Components/ScrollableList.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -36,8 +36,18 @@
     ScrollableList(const int width, const int height);
     ~ScrollableList();
     
+    /**
+     * Sets the maximum number of lines that the ScrollableList may contain.
+     * @param n The maximum number of lines
+     */
     void setMaxLines(const unsigned n);
-    
+
+    /**
+     * Adds a line of text to the list
+     * @param str The text
+     * @param firstLineOffset The x offset of the first character, defaults to 0
+     * @param color The drawing color of the text
+     */
     void addLine(const UString&amp; str, const int firstLineOffset = 0, const uint8_t color = Color::gray224);
     
     void setLocation(const int x, const int y);
@@ -55,6 +65,7 @@
     
     void onPointerMove(int rel_x, int rel_y);
     
+    /** Holds one element of the list, a line of text and its related data */
     struct ListElement
     {
         ListElement( const UString&amp; str, const int height, const int firstLineOffset, uint8_t color)
@@ -75,11 +86,8 @@
     /** sum of all the rendered lines heigh, one line might be broken in several */
     int totalLinesHeight;
     
-    /** Offset where the line list should start */
-    int totalDisplayStart;
-    
     /** Offset of the first TextRenderer */
-    int rendedTotalDisplayStart;
+    int rendedTotalDisplayStart; // @todo find a better name for this variable
     
     /** max number of lines in the list */
     unsigned maxLines;
@@ -96,10 +104,16 @@
     /** shall redraw the text lines? */
     bool dirty;
 
+    /** The scroll bar */
     VScrollBar * scrollbar;
+    
+    /** flag if the mouse is over the scrollbar */
     bool hoveringScrollbar;
+    
+    /** flag if the mouse is pressing the scrollbar */
     bool selectingScrollbar;
-            
+    
+    /** Scrollbar will send the change event here */
     ComponentEvents myEvents;
 };
 

Added: trunk/netpanzer/src/Lib/2D/Components/Table.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/Table.cpp	                        (rev 0)
+++ trunk/netpanzer/src/Lib/2D/Components/Table.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -0,0 +1,342 @@
+/*
+Copyright (C) 2013 Netpanzer Team. (www.netpanzer.org), Aaron Perez
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
+ * 
+ * Created on September 7, 2013, 12:54 PM
+ */
+
+#include &quot;Table.hpp&quot;
+#include &quot;VScrollBar.hpp&quot;
+#include &quot;Actions/Action.hpp&quot;
+#include &quot;2D/TextRenderingSystem.hpp&quot;
+#include &quot;2D/Color.hpp&quot;
+#include &quot;GameInput/InputManager.hpp&quot;
+
+#define REPEAT_INITIAL (500)
+#define REPEAT_TIME (50)
+
+struct Events
+{
+    enum
+    {
+        ScrollChange = 1
+    };
+};
+
+Table::DataSource::DataSource()
+{
+    table = 0;
+}
+
+Table::DataSource::~DataSource()
+{
+    if ( table )
+    {
+        table-&gt;setDataSource(0);
+    }
+}
+
+void Table::DataSource::setTable(Table* table)
+{
+    if ( table != this-&gt;table )
+    {
+        if ( this-&gt;table )
+        {
+            this-&gt;table-&gt;setDataSource(0);
+        }
+        
+        this-&gt;table = table;
+        
+        if ( this-&gt;table )
+        {
+            this-&gt;table-&gt;setDataSource(this);
+        }
+    }
+}
+
+Table::Table(const unsigned numColumns, const int intercolumnWidth)
+{
+    this-&gt;numColumns = numColumns;
+    this-&gt;intercolumnWidth = intercolumnWidth;
+    dirty = true;
+
+    scrollbar = new VScrollBar();
+    hoveringScrollbar = false;
+    selectingScrollbar = false;
+    firstRowTotalPosition = 0;
+    firstRowOffset = 0;
+    firstRowHeight = 0;
+    lastRowHeight = 0;
+
+    scrollbar-&gt;setComponentEvents(&amp;myEvents);
+    scrollbar-&gt;setChangeEvent(Events::ScrollChange);
+    scrollbar-&gt;setAutoRepeat(REPEAT_INITIAL, REPEAT_TIME);
+}
+
+Table::~Table()
+{
+    columnDef.deleteAll();
+    painters.deleteAll();
+    delete scrollbar;
+}
+
+void Table::setLocation(const int x, const int y)
+{
+    Component::setLocation(x, y);
+    const int x_start = rect.getEndX() - scrollbar-&gt;getWidth();
+    // @todo use headerHeight
+    scrollbar-&gt;setLocation(x_start+1, y + TextRenderingSystem::line_height());
+}
+
+void Table::setSize(const int x, const int y)
+{
+    Component::setSize( x, y );
+    // @todo use header height
+    scrollbar-&gt;setVisibleHeight(y - TextRenderingSystem::line_height());
+    const int x_start = rect.getEndX() - scrollbar-&gt;getWidth();
+    scrollbar-&gt;setLocation(x_start+1, scrollbar-&gt;getLocationY());
+}
+
+void Table::addColumn(const UString&amp; text, const unsigned width)
+{
+    const unsigned num = columnDef.size();
+    if ( num &lt; numColumns )
+    {
+        columnDef.push_back(new ColumnDef(text, width));
+        if ( columnDef.size() == numColumns )
+        {
+            // @todo may need to do some recalculation
+        }
+    }
+        
+}
+
+void Table::draw(Surface&amp; dest) const
+{
+    dest.fillRect(rect, Color::orange);
+    int y = drawHeader(dest);
+    scrollbar-&gt;draw(dest);
+    
+    if ( ! painters.empty() )
+    {
+        iRect cellArea(0,firstRowOffset,0,firstRowHeight);
+        
+        int x = getLocationX();
+        
+        const RowPainter *p = painters[0];
+        
+        // draw first row, maybe cell are half drawn due to scrolling
+        for ( int c = 0, ce = columnDef.size(); c &lt; ce; c++ )
+        {
+            const int w = std::min(columnDef[c]-&gt;width, getWidth() - scrollbar-&gt;getWidth() - (x-getLocationX()));
+            cellArea.setWidth(w);
+            p-&gt;paintCell(dest, x, y, cellArea, c);
+            x += columnDef[c]-&gt;width + intercolumnWidth;
+        }
+        
+        y += firstRowHeight;
+        cellArea.setLocationY(0);
+        cellArea.setHeight(rowHeight);
+        
+        for ( int n = 1, ne = painters.size()-1; n &lt; ne; n++ )
+        {
+            x = getLocationX();
+            p = painters[n];
+            for ( int c = 0, ce = columnDef.size(); c &lt; ce; c++ )
+            {
+                const int w = std::min(columnDef[c]-&gt;width, getWidth() - scrollbar-&gt;getWidth() - (x-getLocationX()));
+                cellArea.setWidth(w);
+                p-&gt;paintCell(dest, x, y, cellArea, c);
+                x += columnDef[c]-&gt;width + intercolumnWidth;
+            }
+            
+            y += rowHeight;
+        }
+
+        // draw last row if needed
+        if ( painters.size() &gt;  1 )
+        {
+            x = getLocationX();
+            cellArea.setHeight(lastRowHeight);
+            p = painters.back();
+            for ( int c = 0, ce = columnDef.size(); c &lt; ce; c++ )
+            {
+                const int w = std::min(columnDef[c]-&gt;width, getWidth() - scrollbar-&gt;getWidth() - (x-getLocationX()));
+                cellArea.setWidth(w);
+                p-&gt;paintCell(dest, x, y, cellArea, c);
+                x += columnDef[c]-&gt;width + intercolumnWidth;
+            }
+        }
+    }
+}
+
+void Table::logic()
+{
+    scrollbar-&gt;logic();
+    if ( dirty )
+    {
+        const int rowcount = ds-&gt;getRowCount();
+        scrollbar-&gt;setTotalHeight(rowcount * rowHeight);
+        if ( rowcount )
+        {
+            const int scrollpos = scrollbar-&gt;getValue();
+            const int firstRow = scrollpos / rowHeight;
+            const int froffset = scrollpos % rowHeight;
+            
+            // @todo save the header height somewhere, or the visible height
+            const int endy = scrollpos + (getHeight() - TextRenderingSystem::line_height());
+            
+            int y = scrollpos - froffset;
+            
+            // @todo optimize this, don't delete all
+            painters.deleteAll();
+            for ( int n = firstRow, ne = rowcount; n &lt; ne; n++ )
+            {
+                RowPainter * p = ds-&gt;newRowPainter();
+                ds-&gt;configureRowPainter(p, n);
+                painters.push_back(p);
+                y += rowHeight;
+                if ( y &gt;= endy )
+                    break;
+            }
+            
+            lastRowHeight = rowHeight;
+            if ( y &gt; endy )
+            {
+                lastRowHeight -= y - endy;
+            }
+            
+            firstRowHeight = rowHeight - froffset;
+            firstRowOffset = froffset;
+
+        }
+        else
+        {
+            firstRowTotalPosition = 0;
+            painters.deleteAll();
+        }
+    }
+}
+
+int Table::drawHeader(Surface&amp; dest) const
+{
+    const int lineh = TextRenderingSystem::line_height();
+    iRect textRect;
+    iRect columnRect(rect);
+    
+    textRect.setHeight(lineh);
+    columnRect.setHeight(lineh);
+    
+    for ( unsigned n = 0; n &lt; columnDef.size(); n++ )
+    {
+        const int w = std::min(columnDef[n]-&gt;width, getWidth() - (columnRect.getLocationX()-getLocationX()));
+        columnRect.setWidth( w );
+        textRect.setWidth( w );
+        dest.fillRect(columnRect, Color::darkGreen);
+        columnDef[n]-&gt;textRender.drawPart(dest, columnRect.getLocationX(), columnRect.getLocationY(), textRect, Color::white);
+        
+        columnRect.translate(columnDef[n]-&gt;width + intercolumnWidth, 0);
+        
+        if ( columnRect.getLocationX() &gt;= rect.getEndX() )
+            break;
+    }
+    
+    return columnRect.getLocationY() + lineh;
+}
+
+void Table::setDataSource(const DataSource* ds)
+{
+    if ( ds != this-&gt;ds )
+    {
+        this-&gt;ds = ds;
+        if ( ds )
+        {
+            rowHeight = ds-&gt;getRowHeight();
+            scrollbar-&gt;setStepSize(rowHeight);
+        }
+        dirty = true;
+    }
+}
+
+void Table::onDataChanged()
+{
+    dirty = true;
+}
+
+void Table::onSelectStart()
+{
+    if ( hoveringScrollbar )
+    {
+        scrollbar-&gt;onSelectStart();
+        selectingScrollbar = true;
+    }
+}
+
+void Table::onSelectStop()
+{
+    if ( selectingScrollbar )
+    {
+        scrollbar-&gt;onSelectStop();
+        selectingScrollbar = false;
+        onPointerMove( 0, 0);
+    }
+}
+
+void Table::onHoverStart()
+{
+    // unused
+}
+
+void Table::onHoverStop()
+{
+    if ( (! selectingScrollbar) &amp;&amp; hoveringScrollbar )
+    {
+        scrollbar-&gt;onHoverStop();
+        hoveringScrollbar = false;
+    }
+}
+
+void Table::onPointerMove(int rel_x, int rel_y)
+{
+    const int mx = GameInput::InputManager::getMouseX();
+    const int my = GameInput::InputManager::getMouseY();
+    
+    if ( ! selectingScrollbar )
+    {
+        if ( scrollbar-&gt;contains(mx, my) )
+        {
+            if ( ! hoveringScrollbar )
+            {
+                hoveringScrollbar = true;
+                scrollbar-&gt;onHoverStart();
+            }
+            
+            scrollbar-&gt;onPointerMove(rel_x, rel_y);
+        }
+        else
+        {
+            if ( hoveringScrollbar )
+            {
+                hoveringScrollbar = false;
+                scrollbar-&gt;onHoverStop();
+            }
+        }
+    }
+    else
+    {
+        scrollbar-&gt;onPointerMove(rel_x, rel_y);
+    }
+}

Added: trunk/netpanzer/src/Lib/2D/Components/Table.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/Table.hpp	                        (rev 0)
+++ trunk/netpanzer/src/Lib/2D/Components/Table.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -0,0 +1,214 @@
+/*
+Copyright (C) 2013 Netpanzer Team. (www.netpanzer.org), Aaron Perez
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
+ *
+ * Created on September 7, 2013, 12:54 PM
+ */
+
+#ifndef TABLE_HPP
+#define	TABLE_HPP
+
+#include &quot;Views/Components/Component.hpp&quot;
+#include &quot;2D/TextRenderer.hpp&quot;
+#include &quot;Types/UString.hpp&quot;
+#include &quot;ArrayUtil/PtrArray.hpp&quot;
+
+class VScrollBar;
+
+class Table : public Component
+{
+public:
+    /**
+     * Interface for painting rows. DataSource shall return subclasses of
+     * RowPainter to draw the table data
+     */
+    class RowPainter
+    {
+        public:
+            RowPainter() {}
+            virtual ~RowPainter() {}
+            
+            /**
+             * Paints the 'rect' especified area of the especified column cell
+             * on the destination surface at the specified location.
+             * @param dest Surface where the cell will be drawn.
+             * @param x X destination of the painting
+             * @param y Y destinatino of the painting
+             * @param rect subarea to paint of the cell
+             * @param column Column number to paint
+             */
+            virtual void paintCell(Surface&amp; dest, const int x, const int y, const iRect&amp; rect, const unsigned column) const = 0;
+    };
+    
+    
+    /**
+     * DataSource interface for tables
+     */
+    class DataSource
+    {
+        public:
+            DataSource();
+            virtual ~DataSource();
+            
+            /**
+             * &lt;p&gt;Sets the display Table to use and also sets the DataSource in the
+             * Table to &lt;b&gt;this&lt;/b&gt;.&lt;/p&gt;
+             * &lt;p&gt;&lt;b&gt;Note: don't set two DataSources to the same table at the
+             * same time&lt;/b&gt;&lt;/p&gt;
+             * @param table The Table
+             */
+            void setTable(Table * table);
+            
+            /**
+             * Implementations shall return the number of rows in this DataSource.
+             * @return Number of rows in this DataSource
+             */
+            virtual unsigned getRowCount() const = 0;
+            
+            /**
+             * Implementations shall return the height needed for painting a
+             * row. Note that the Table only reads this value on
+             * &lt;b&gt;setDataSource&lt;/b&gt;.
+             * @return Height
+             */
+            virtual unsigned getRowHeight() const = 0;
+            
+            /**
+             * @return RowPainter for this DataSource
+             */
+            virtual RowPainter * newRowPainter() const = 0;
+            
+            /**
+             * Configures the row painter to show
+             * @param painter The RowPainter to configure
+             * @param row The row number with the data to paint
+             */
+            virtual void configureRowPainter(RowPainter * painter, const unsigned row) const = 0;
+            
+        protected:
+            /**
+             * Subclasses may use this to notify the table that the data has 
+             * been modified. Use it when the whole data is different.
+             */
+            void notifyDataChanged() { if ( table ) table-&gt;onDataChanged(); }
+            
+            
+        private:
+            friend class Table;
+            Table * table;
+    };
+    
+    /**
+     * Creates a default table
+     * @param numColumns Maximum number of columns the table may have
+     * @param intercolumnWidth Separation space in pixels between columns, defaults to 1
+     */
+    Table(const unsigned numColumns, const int intercolumnWidth = 1);
+    ~Table();
+    
+    void draw(Surface&amp; dest) const;
+    
+    /**
+     * Adds a new column definition to the table
+     * @param text Text to show in the column header
+     * @param width Width of the column
+     */
+    void addColumn(const UString&amp; text, const unsigned width);
+    
+    void setSize(const int x, const int y);
+    void setLocation(const int x, const int y);
+    
+private:
+    friend class Table::DataSource;
+    
+    /**
+     * Draws the table header and returns the new Y position to continue drawing
+     * @param dest Surface to draw on
+     * @return new Y position to continue drawing
+     */
+    int drawHeader(Surface&amp; dest) const;
+
+    /**
+     * Sets the data source. &lt;b&gt;Only used by DataSource itself&lt;/b&gt;
+     * @param ds The DataSource
+     */
+    void setDataSource( const DataSource * ds);
+    
+    void onDataChanged();
+    void onSelectStart();
+    void onSelectStop();
+    void onHoverStart();
+    void onHoverStop();
+    void onPointerMove(int rel_x, int rel_y);
+    
+    void logic();
+    
+    /** Structure for holding data of a column definition */
+    struct ColumnDef
+    {
+        ColumnDef(const UString&amp; text, const int width) : textRender(text), width(width) {}
+        TextRenderer textRender;
+        unsigned width;
+    };
+    
+    /** Maximum number of columns the table may have */
+    unsigned numColumns;
+    
+    /** Separation space in pixels between columns */
+    int intercolumnWidth;
+    
+    /** Location of the first row on the whole scrollable view */
+    int firstRowTotalPosition; // @todo find a better name for this
+    
+    /** cached first row draw offset */
+    int firstRowOffset;
+    
+    /** cached first row drawing height */
+    int firstRowHeight;
+    
+    /** cached last row height */
+    int lastRowHeight;
+    
+    /** Height of one row, updated from the DataSource */
+    int rowHeight;
+    
+    /** Flag to notify the logic() code it needs to do some recalculation */
+    bool dirty;
+    
+    /** DataSource for this table */
+    const DataSource * ds;
+
+    /** List of defined columns */
+    PtrArray&lt;ColumnDef&gt; columnDef;
+    
+    /** List of visible RowPainters */
+    PtrArray&lt;RowPainter&gt; painters;
+    
+    /** The scroll bar */
+    VScrollBar * scrollbar;
+    
+    /** flag if the mouse is over the scrollbar */
+    bool hoveringScrollbar;
+    
+    /** flag if the mouse is pressing the scrollbar */
+    bool selectingScrollbar;
+    
+    /** Scrollbar will send the change event here */
+    ComponentEvents myEvents;
+};
+
+#endif	/* TABLE_HPP */
+

Modified: trunk/netpanzer/src/Lib/2D/Components/VScrollBar.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/VScrollBar.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Components/VScrollBar.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -23,6 +23,8 @@
 #include &quot;GameInput/InputManager.hpp&quot;
 #include &lt;algorithm&gt;
 
+#include &quot;Util/Log.hpp&quot;
+
 #define BSIZE (15)
 #define REPEAT_INITIAL (500)
 #define REPEAT_TIME (50)
@@ -56,6 +58,9 @@
     repeat_initial = 0;
     repeat_other = 0;
     
+    scrollArea.setWidth(BSIZE);
+    movableBar.setWidth(BSIZE);
+    
     Surface pics;
     pics.loadBMP(&quot;pics/buttons/scrollbutton.bmp&quot;);
     
@@ -82,6 +87,8 @@
     downButton-&gt;setStateOffset(Button::BPRESSED, 1, 1);
     downButton-&gt;setComponentEvents(&amp;myEvents);
     downButton-&gt;setClickEvent(Events::GoDown);
+    
+    rect.setWidth(BSIZE);
 }
 
 VScrollBar::~VScrollBar()
@@ -117,7 +124,7 @@
     if ( movableBar.getHeight() )
     {
         const int starth = (movableAreaHeight * value) / virtualTotalHeight;
-        movableBar.setLocationY( scrollArea.getLocationY() + std::min( movableAreaHeight-1, starth) );
+        movableBar.setLocationY( scrollArea.getLocationY() + std::min( movableAreaHeight, starth) );
     }
 }
 
@@ -136,7 +143,10 @@
 {
     if ( h != visibleHeight )
     {
+        Component::setSize(BSIZE, h);
         visibleHeight = h;
+        scrollArea.setHeight(h - (BSIZE * 2) );
+        downButton-&gt;setLocation(downButton-&gt;getLocationX(), scrollArea.getEndY() + 1);
         virtualTotalHeight = std::max(0, totalHeight - h);
         updateMovableBarSize();
         setValue(value);
@@ -157,12 +167,8 @@
 
 void VScrollBar::setSize(const int x, const int y)
 {
-    Component::setSize(x, y);
-    scrollArea.setWidth(x);
-    downButton-&gt;setLocation(downButton-&gt;getLocationX(), scrollArea.getEndY() + 1);
-    movableBar.setWidth(x);
-    updateMovableBarSize();
-    setValue(value);
+//    Component::setSize(BSIZE, y);
+    setVisibleHeight(y);
 }
 
 void VScrollBar::updateMovableBarSize()
@@ -227,9 +233,9 @@
 
 void VScrollBar::onHoverStart()
 {
-    const int mx = GameInput::InputManager::getMouseX();
-    const int my = GameInput::InputManager::getMouseY();
-    overScrollable = movableBar.contains(mx, my);
+//    const int mx = GameInput::InputManager::getMouseX();
+//    const int my = GameInput::InputManager::getMouseY();
+//    overScrollable = movableBar.contains(mx, my);
 }
 
 void VScrollBar::onHoverStop()
@@ -295,6 +301,8 @@
 
     if ( ! selectingComponent )
     {
+        overScrollable = mouseScrolling || movableBar.contains(mx, my);
+        
         Component * c = 0;
 
         if ( upButton-&gt;contains(mx, my) )
@@ -319,8 +327,6 @@
         }
         else
         {
-            overScrollable = mouseScrolling || movableBar.contains(mx, my);
-            
             if ( mouseScrolling )
             {
                 const int between = movableAreaHeight / virtualTotalHeight;

Modified: trunk/netpanzer/src/Lib/2D/Components/VScrollBar.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Components/VScrollBar.hpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Components/VScrollBar.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -34,6 +34,7 @@
     
     void setLocation(const int x, const int y);
     void setSize(const int x, const int y);
+    void setVisibleHeight( const int h );
     
     int getValue() const { return value; }
     void setValue(const int v);
@@ -62,10 +63,8 @@
     void onPointerMove(int rel_x, int rel_y);
     
 private:
-    void setVisibleHeight( const int h );
     void updateMovableBarSize();
     
-    
     Button       * upButton;
     Button       * downButton;
 

Modified: trunk/netpanzer/src/Lib/2D/Surface.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Surface.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Surface.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -1088,32 +1088,6 @@
 
 } // end Surface::bltStringShadowed
 
-// bltStringCenter
-//---------------------------------------------------------------------------
-// Purpose: Blits a string of text and centers it horizontally and vertically
-//          on the screen. Does not handle wrapping.
-//---------------------------------------------------------------------------
-void Surface::bltStringCenter(const char *string, PIX color)
-{
-    bltString(  (getWidth() - (strlen(string) * FONT_WIDTH)) / 2,
-                (getHeight() - getFontHeight()) / 2,
-                string, color);
-
-} // end Surface::bltStringCenter
-
-// bltStringShadowedCenter
-//---------------------------------------------------------------------------
-// Purpose: Blits a string of text and centers it horizontally and vertically
-//          on the screen. Does not handle wrapping.
-//---------------------------------------------------------------------------
-void Surface::bltStringShadowedCenter(const char *string, PIX foreground, PIX background)
-{
-    bltStringShadowed((getWidth() - (strlen(string) * FONT_WIDTH)) / 2,
-                      (getHeight() - getFontHeight()) / 2,
-                      string, foreground, background);
-
-} // end Surface::bltStringShadowedCenter
-
 // bltStringCenteredInRect
 //---------------------------------------------------------------------------
 // Purpose: Blits the string centered inside the specified rectangle.
@@ -1219,29 +1193,6 @@
     }
 }
 
-// drawButtonBorder
-//---------------------------------------------------------------------------
-void Surface::drawButtonBorder(iRect bounds, PIX topLeftColor, PIX bottomRightColor)
-{
-    assert(getDoesExist());
-    assert(this != 0);
-
-//    drawHLine(bounds.min.x,bounds.min.y,bounds.max.x-1,topLeftColor);
-//    drawVLine(bounds.min.x,bounds.min.y,bounds.max.y-1,topLeftColor);
-//    drawHLine(bounds.min.x,bounds.max.y-1,bounds.max.x-1,bottomRightColor);
-//    drawVLine(bounds.max.x-1,bounds.min.y,bounds.max.y-1,bottomRightColor);
-    RoundRect(bounds,3, topLeftColor);
-
-} // end Surface::drawButtonBorder
-
-// drawWindowsBorder
-//--------------------------------------------------------------------------
-void Surface::drawWindowsBorder()
-{
-    //drawRect(iRect(0,0,getWidth(),getHeight()), Color::darkGray);
-    RoundRect(iRect(0,0,getWidth(),getHeight()),8, Color::lightGray);
-} // end Surface::drawWindowsBorder
-
 // drawBoxCorners
 //--------------------------------------------------------------------------
 // Purpose: Draws lines in the corners of the surface of the specified length

Modified: trunk/netpanzer/src/Lib/2D/Surface.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Surface.hpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/2D/Surface.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -105,13 +105,68 @@
 
 
 public:
+    /**
+     * Blits this whole surface onto the destination surface performing clipping
+     * on it.
+     * @param dest Destination surface
+     * @param x Destination x
+     * @param y Destination y
+     */
     void blt(Surface &amp;dest, int x, int y) const;
+    
+    /**
+     * Blits this whole surface onto the destination surface ignoring transparent
+     * pixels (value = 0), performs clipping.
+     * @param dest Destination surface
+     * @param x Destination x
+     * @param y Destination y
+     */
     void bltTrans(Surface &amp;dest, int x, int y) const;
+    
+    /**
+     * Blits this whole surface onto the destination surface setting the
+     * transparent pixels (value = 0) to the passed color, performs clipping.
+     * @param dest Destination surface
+     * @param x Destination x
+     * @param y Destination y
+     * @param color New color to use for the transparent pixels
+     */
     void bltTransColor(Surface &amp;dest, int x, int y, const PIX color) const;
+    
+    /**
+     * &lt;p&gt;&lt;b&gt;Note: parameter is source not destination as the other blits&lt;/b&gt;&lt;/p&gt;
+     * &lt;p&gt;Blits the whole passed surface onto this surface on the position and
+     * size passed (may perform scaling). Performs clipping.&lt;/p&gt;
+     * @param source 
+     * @param destRect
+     */
     void bltScale(const Surface &amp;source, const iRect &amp;destRect);
+    
+    /**
+     * For each pixel in the surface, replaces it value with the mapped value of
+     * the passed table.
+     * @param destRect Area to perform the lookup
+     * @param table Lookup table
+     */
     void bltLookup(const iRect &amp;destRect, const PIX table[]);
 
+    /**
+     * 
+     * @param dest Destination surface
+     * @param x Destination x
+     * @param y Destination y
+     * @param color
+     */
     void bltAlphaColor(Surface &amp;dest, int x, int y, const PIX color) const;
+    
+    /**
+     * 
+     * @param dest
+     * @param x
+     * @param y
+     * @param rect
+     * @param color
+     */
     void bltRectAlphaColor(Surface &amp;dest, int x, int y, const iRect&amp; rect, const PIX color) const;
 
 
@@ -125,15 +180,6 @@
         drawLine(a.x, a.y, b.x, b.y, color);
     }
     
-    // Surface Effects.
-    void drawButtonBorder(iRect bounds, PIX topLeftColor, PIX bottomRightColor);
-    void drawButtonBorder(PIX topLeftColor, PIX bottomRightColor)
-    {
-        drawButtonBorder(iRect(0, 0, getWidth(), getHeight()), topLeftColor, bottomRightColor);
-    }
-
-    void drawWindowsBorder();
-    
     void fill(const PIX color);
     void flipVertical();
     void copy(const Surface &amp;source);
@@ -147,11 +193,6 @@
 
     // Blit a shadowed string of text.
     void bltStringShadowed(int x, int y, const char *str, const PIX textColor, const PIX shadowColor);
-
-    // Blits a string of text and centers it horizontally and vertically on the screen.
-    void bltStringCenter(const char *string, PIX color);
-
-    void bltStringShadowedCenter(const char *string, PIX foreground, PIX background);
     void bltStringCenteredInRect(const iRect &amp;rect, const char *string, const PIX color);
 
     void loadBMP(const char *fileName, bool needAlloc = true);

Modified: trunk/netpanzer/src/Lib/Types/UString.hpp
===================================================================
--- trunk/netpanzer/src/Lib/Types/UString.hpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/Lib/Types/UString.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -25,41 +25,134 @@
 #include &lt;stddef.h&gt;
 #include &lt;string.h&gt;
 
+/**
+ * Class to hold unicode strings.
+ */
 class UString
 {
 public:
+    /** The type used for storing characters */
     typedef uint32_t char_type;
+    
+    /**
+     * The replacement character, used when the parsed codepoint is invalid
+     * or when the index is out of bounds.
+     */
     enum { replacement_char = 0xFFFD };
     
+    /**
+     * Creates an empty UString
+     */
     UString();
+    
+    /**
+     * Creates an empty string with preallocated space for characters.
+     * @param len number of characters to preallocate
+     */
     explicit UString(const size_t len);
+    
+    /**
+     * Converts the provided utf8string to UString. If length is provided only
+     * parses that many bytes.
+     * @param utf8string The UTF8 encoded string
+     * @param len Limit on how many bytes to parse. If 0 then parses all.
+     */
     explicit UString(const char * utf8string, const size_t len = 0);
+    
+    /**
+     * Creates a copy of the provided UString
+     * @param other The UString to copy.
+     */
     explicit UString(const UString&amp; other);
+    
+    /**
+     * Destructor, releases resources
+     */
     ~UString();
     
+    /**
+     * Release resources, no buffer is allocated after this call.
+     */
     void clear();
     
+    /**
+     * Copies the provided UString onto this one. Buffer can only grow, it
+     * doesn't shrink.
+     * @param other The UString to copy
+     */
     void operator=(const UString&amp; other);
     
+    /**
+     * Returns the number of characters in this UString
+     * @return The number of characters in this UString
+     */
     size_t length() const;
     
+    /**
+     * Returns the character at provided index, or the &lt;b&gt;replacement_character&lt;/b&gt;
+     * @param index
+     * @return 
+     */
     const char_type operator[](const size_t index) const;
     
+    /**
+     * Inserts the character at the specified position, or at the end of the
+     * UString if the index is out of bounds
+     * @param index Index to insert the character
+     * @param ch The character to insert
+     */
     void insertChar(const size_t index, const char_type ch);
+    
+    /**
+     * Deletes the character at the specified position, buffer doesn't shrink.
+     * @param index
+     */
     void deleteChar(const size_t index);
     
+    /**
+     * If the length of the UString is bigger than the provided limit, use the
+     * provided limit. Buffer doesn't shrink.
+     * @param maxlen Limit for the UString length
+     */
     void cutMaxLength(const size_t maxlen);
     
+    /**
+     * Checks if the UString has the provided character.
+     * @param ch Character to look for
+     * @return true if character is in the UString.
+     */
     bool contains(const char_type ch);
     
     
 private:
+    /** Buffer for the characters data */
     char_type * data;
+    
+    /** Number of characters in the UString */
     size_t str_length;
+    
+    /** Number of reserved characters in the buffer */
     size_t reserved_length;
     
+    /**
+     * Reset the values to defaults. &lt;b&gt;Doesn't free buffer, use &lt;i&gt;clear&lt;/i&gt;
+     * for that&lt;/b&gt;.
+     */
     void reset();
+    
+    /**
+     * Reserves space for the provided number of characters. &lt;b&gt;It frees
+     * previous buffer&lt;/b&gt;
+     * @param size Character count to allocate
+     * @return false if memory allocation failed
+     */
     bool reserve(const size_t size);
+    
+    /**
+     * Grows the character buffer the provided character count
+     * @param how_many Number of characters to grow
+     * @return false if memory allocation failed
+     */
     bool grow(const size_t how_many);
     
 };
@@ -136,4 +229,3 @@
 }
 
 #endif	/* USTRING_HPP */
-

Modified: trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -32,6 +32,11 @@
 #include &quot;Types/UString.hpp&quot;
 #include &quot;Interfaces/StrManager.hpp&quot;
 #include &quot;Util/StringTokenizer.hpp&quot;
+#ifdef TEST_TABLE
+#include &quot;2D/Components/Table.hpp&quot;
+#include &quot;2D/Components/Button.hpp&quot;
+#include &quot;2D/TextRenderingSystem.hpp&quot;
+#endif
 
 #define MENU_WIDTH  (640)
 #define MENU_HEIGHT (480-26-26)
@@ -40,6 +45,128 @@
 	#define PACKAGE_VERSION &quot;testing&quot;
 #endif
 
+#ifdef TEST_TABLE
+
+#include &lt;vector&gt;
+
+struct Events
+{
+    enum
+    {
+        AddToTable = 1
+    };
+};
+
+class TestData
+{
+public:
+    TestData(const UString&amp; s1, const UString&amp; s2, const UString &amp;s3)
+        : s1(s1), s2(s2), s3(s3)
+        {}
+    UString s1, s2, s3;
+};
+
+class TestRowPainter : public Table::RowPainter
+{
+public:
+    TestRowPainter() : Table::RowPainter()
+    {
+        
+    }
+    
+    ~TestRowPainter()
+    {
+        
+    }
+    
+    void setData(const TestData&amp; data)
+    {
+        c1.setText(data.s1);
+        c2.setText(data.s2);
+        c3.setText(data.s3);
+    }
+    
+    void paintCell(Surface&amp; dest, const int x, const int y, const iRect&amp; rect, const unsigned column) const
+    {
+        switch ( column )
+        {
+            case 0: c1.drawPart(dest, x, y, rect); break;
+            case 1: c2.drawPart(dest, x, y, rect); break;
+            case 2: c3.drawPart(dest, x, y, rect); break;
+        }
+    }
+            
+private:
+    
+    TextRenderer c1, c2, c3;
+};
+
+class TestDataSource : public Table::DataSource
+{
+public:
+    std::vector&lt;TestData&gt; testrows;
+    TestDataSource() : Table::DataSource()
+    {
+        testrows.push_back(TestData(UString(&quot;0,0&quot;),UString(&quot;0,1&quot;),UString(&quot;0,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;1,0&quot;),UString(&quot;1,1&quot;),UString(&quot;1,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;2,0&quot;),UString(&quot;2,1&quot;),UString(&quot;2,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;3,0&quot;),UString(&quot;3,1&quot;),UString(&quot;3,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;4,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;5,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;6,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;7,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;8,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;9,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;10,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;11,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;12,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;13,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;14,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;15,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+        testrows.push_back(TestData(UString(&quot;16,0&quot;),UString(&quot;4,1&quot;),UString(&quot;4,2&quot;)));
+    }
+    
+    ~TestDataSource()
+    {
+        
+    }
+    
+    void addRow(const UString&amp; s1, const UString&amp; s2, const UString&amp; s3)
+    {
+        testrows.push_back(TestData(s1,s2,s3));
+        notifyDataChanged();
+    }
+    
+    
+    unsigned getRowCount() const
+    {
+        return testrows.size();
+    }
+    
+    Table::RowPainter * newRowPainter() const
+    {
+        return new TestRowPainter();
+    }
+    
+    unsigned getRowHeight() const
+    {
+        return TextRenderingSystem::line_height();
+    }
+    
+    void configureRowPainter(Table::RowPainter * painter, const unsigned row) const
+    {
+        TestRowPainter * p = reinterpret_cast&lt;TestRowPainter*&gt;(painter);
+        if ( row &lt; testrows.size() )
+        {
+            p-&gt;setData(testrows[row]);
+        }
+    }
+};
+
+TestDataSource tds;
+        
+#endif
+
 IntroLayer::IntroLayer() : ComponentLayer(0)
 {
     area = new AreaComponent( MENU_WIDTH, MENU_HEIGHT );
@@ -50,8 +177,8 @@
     input_field-&gt;setExcludedChars(UString(&quot;bc&quot;));
     input_field-&gt;setSize(100, 21);
     input_field-&gt;setText(UString(&quot;Jafgjy this is a very long line lets see what happens&quot;));
-//    input_field-&gt;setText(UString(&quot;12345&quot;));
-    
+
+#ifndef TEST_TABLE
     intro_text = new ScrollableList(MENU_WIDTH-20, MENU_HEIGHT-150);
 
     char Buf[1024];    
@@ -66,12 +193,31 @@
     {
         intro_text-&gt;addLine(UString(tok.getNextToken(true).c_str()));
     }
+#else
+    table = new Table(3, 1);
+    table-&gt;setSize(MENU_WIDTH-20, MENU_HEIGHT-150);
     
+    table-&gt;addColumn(UString(&quot;First Column&quot;), 150);
+    table-&gt;addColumn(UString(&quot;Second Column&quot;), 175);
+    table-&gt;addColumn(UString(&quot;Thirth Column&quot;), 80);
     
+    tds.setTable(table);
+    
+    tableButton = Button::createNewSpecialButton(&quot;Add&quot;, iXY(0,0), 100);
+//    tableButton = Button::createTextButton(&quot;Add&quot;, iXY(0,0), 100);
+    tableButton-&gt;setClickEvent(Events::AddToTable);
+    
+#endif
+    
     addComponent(area);
+#ifndef TEST_TABLE
     addComponent(intro_text);
-    addComponent(label);
-    addComponent(input_field);
+#else
+    addComponent(table);
+    addComponent(tableButton);
+#endif
+//    addComponent(label);
+//    addComponent(input_field);
 }
 
 IntroLayer::~IntroLayer()
@@ -88,16 +234,31 @@
 
     int x = area-&gt;getLocationX() + 10;
     int y = area-&gt;getLocationY() + 10;
-    
+#ifndef TEST_TABLE
     intro_text-&gt;setLocation(x, y);
-    
     y += intro_text-&gt;getHeight();
+#else
+    table-&gt;setLocation(x, y);
+    y += table-&gt;getHeight();
+    tableButton-&gt;setLocation(x+250, y+50);
+#endif
     
+#ifdef TEST_INPUTFIELD
     label-&gt;setLocation(x, y+20);
     input_field-&gt;setLocation(x, y + 50);
+#endif
 }
 
 void IntroLayer::handleComponentEvents()
 {
-    
+#ifdef TEST_TABLE
+    int event;
+    while ( (event = component_events.nextEvent()) ) switch ( event )
+    {
+        case Events::AddToTable:
+            tds.addRow(UString(&quot;Added col 1&quot;),UString(&quot;Added col 2&quot;),UString(&quot;Even more&quot;));
+            break;
+            
+    }
+#endif
 }

Modified: trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.hpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/NetPanzer/Scenes/MainMenu/IntroLayer.hpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -23,15 +23,26 @@
 
 #include &quot;2D/ComponentLayer.hpp&quot;
 
+#define TEST_TABLE
+#define TEST_INPUTFIELD
+
 class Component;
 class CheckBox;
 class Choice;
 class Slider;
 class Label;
 class Slider;
-class InputField;
 class ScrollableList;
 
+#ifdef TEST_TABLE
+class Table;
+class Button;
+#endif
+
+#ifdef TEST_INPUTFIELD
+class InputField;
+#endif
+
 class IntroLayer : public ComponentLayer
 {
 public:
@@ -43,10 +54,20 @@
     void handleComponentEvents();
     
     Component   * area;
+    
+#ifndef TEST_TABLE
     ScrollableList * intro_text;
+#endif
     
+#ifdef TEST_TABLE
+    Table       * table;
+    Button      * tableButton;
+#endif
+    
+#ifdef TEST_INPUTFIELD
     Label       * label;
     InputField  * input_field;
+#endif
     
 };
 

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -101,9 +101,9 @@
     
     bltViewBackground(dest);
 
-    dest.drawButtonBorder(
-            iRect(0, TABLE_BORDER_START, dest.getWidth()-1, dest.getHeight()-1),
-            Color::gray64, Color::white);
+//    dest.drawButtonBorder(
+//            iRect(0, TABLE_BORDER_START, dest.getWidth()-1, dest.getHeight()-1),
+//            Color::gray64, Color::white);
 
     dest.bltStringShadowed(0, 16, table_header, Color::red, Color::gray64);
     drawPlayerStats(dest, flagHeight);

Modified: trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/ServerListView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/ServerListView.cpp	2013-09-07 04:28:39 UTC (rev 1431)
+++ trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/ServerListView.cpp	2013-09-08 23:58:04 UTC (rev 1432)
@@ -523,7 +523,7 @@
 void
 ServerListView::doDraw( Surface&amp; dest )
 {
-    dest.drawWindowsBorder();
+//    dest.drawWindowsBorder();
     
     if(queryThread &amp;&amp; queryThread-&gt;isRunning())
     {

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000452.html">[Netpanzer-cvs] r1430 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject	projects/netpanzer-svn-windows/nbproject/private src/Lib/2D	src/Lib/2D/Components src/Lib/ArrayUtil src/Lib/GameInput	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Scenes src/NetPanzer/Scenes/Common	src/NetPanzer/Scenes/MainMenu src/NetPanzer/Views/Components	src/NetPanzer/Views/MainMenu
</A></li>
	<LI>Next message: <A HREF="000454.html">[Netpanzer-cvs] r1433 - in trunk/netpanzer:	projects/netpanzer-svn-windows/nbproject/private	src/Lib/2D/Components src/NetPanzer/Scenes/MainMenu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#453">[ date ]</a>
              <a href="thread.html#453">[ thread ]</a>
              <a href="subject.html#453">[ subject ]</a>
              <a href="author.html#453">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
