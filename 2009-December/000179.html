<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1151 - in trunk/netpanzer: . scripts src/Lib	src/Lib/2D src/Lib/Util src/Lib/toluapp src/NetPanzer/Classes	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Views/Components
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1151%20-%20in%20trunk/netpanzer%3A%20.%20scripts%20src/Lib%0A%09src/Lib/2D%20src/Lib/Util%20src/Lib/toluapp%20src/NetPanzer/Classes%0A%09src/NetPanzer/Core%20src/NetPanzer/Interfaces%0A%09src/NetPanzer/Scripts%20src/NetPanzer/Scripts/bindings%0A%09src/NetPanzer/Scripts/toluapkg%20src/NetPanzer/Views/Components&In-Reply-To=%3C200912201534.nBKFYSua024819%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000178.html">
   <LINK REL="Next"  HREF="000180.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1151 - in trunk/netpanzer: . scripts src/Lib	src/Lib/2D src/Lib/Util src/Lib/toluapp src/NetPanzer/Classes	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Views/Components</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1151%20-%20in%20trunk/netpanzer%3A%20.%20scripts%20src/Lib%0A%09src/Lib/2D%20src/Lib/Util%20src/Lib/toluapp%20src/NetPanzer/Classes%0A%09src/NetPanzer/Core%20src/NetPanzer/Interfaces%0A%09src/NetPanzer/Scripts%20src/NetPanzer/Scripts/bindings%0A%09src/NetPanzer/Scripts/toluapkg%20src/NetPanzer/Views/Components&In-Reply-To=%3C200912201534.nBKFYSua024819%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1151 - in trunk/netpanzer: . scripts src/Lib	src/Lib/2D src/Lib/Util src/Lib/toluapp src/NetPanzer/Classes	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Views/Components">kromxp at mail.berlios.de
       </A><BR>
    <I>Sun Dec 20 16:34:28 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000178.html">[Netpanzer-cvs] r1150 - in trunk/netpanzer/src/NetPanzer:	Interfaces Units
</A></li>
        <LI>Next message: <A HREF="000180.html">[Netpanzer-cvs] r1152 - in trunk/netpanzer: pics/particles/lights	scripts src/Lib/ArrayUtil src/NetPanzer/Bot	src/NetPanzer/Classes src/NetPanzer/Classes/AI	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units	src/NetPanzer/Views/Components src/NetPanzer/Views/Game	src/NetPanzer/Weapons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#179">[ date ]</a>
              <a href="thread.html#179">[ thread ]</a>
              <a href="subject.html#179">[ subject ]</a>
              <a href="author.html#179">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2009-12-20 16:33:47 +0100 (Sun, 20 Dec 2009)
New Revision: 1151

Added:
   trunk/netpanzer/src/Lib/toluapp/
   trunk/netpanzer/src/Lib/toluapp/tolua++.h
   trunk/netpanzer/src/Lib/toluapp/tolua_event.c
   trunk/netpanzer/src/Lib/toluapp/tolua_event.h
   trunk/netpanzer/src/Lib/toluapp/tolua_is.c
   trunk/netpanzer/src/Lib/toluapp/tolua_map.c
   trunk/netpanzer/src/Lib/toluapp/tolua_push.c
   trunk/netpanzer/src/Lib/toluapp/tolua_to.c
   trunk/netpanzer/src/NetPanzer/Scripts/bindings/
   trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/colors.pkg
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/consoleinterface.pkg
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/log.pkg
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg
Removed:
   trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.cpp
   trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.hpp
Modified:
   trunk/netpanzer/SConstruct
   trunk/netpanzer/scripts/initcolors.lua
   trunk/netpanzer/scripts/initialize.lua
   trunk/netpanzer/src/Lib/2D/Color.cpp
   trunk/netpanzer/src/Lib/2D/Color.hpp
   trunk/netpanzer/src/Lib/2D/Palette.cpp
   trunk/netpanzer/src/Lib/2D/Palette.hpp
   trunk/netpanzer/src/Lib/2D/Surface.cpp
   trunk/netpanzer/src/Lib/Util/Log.cpp
   trunk/netpanzer/src/Lib/Util/Log.hpp
   trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   trunk/netpanzer/src/NetPanzer/Core/main.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp
   trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.hpp
   trunk/netpanzer/src/NetPanzer/Views/Components/View.hpp
Log:
- Fix graphics slowness when there are many tanks with new graphics.
- Added some scripting using tolua++, see sample in scripts/initialize.lua, while on game type &quot;/info&quot; to see it working. Check on src/NetPanzer/Scripts/toluapkg to see exported functions.



Modified: trunk/netpanzer/SConstruct
===================================================================
--- trunk/netpanzer/SConstruct	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/SConstruct	2009-12-20 15:33:47 UTC (rev 1151)
@@ -147,7 +147,7 @@
     crosslinuxenv.Append(CCFLAGS = ['-O2','-s'])
     crosslinuxenv['FINALEXENAME'] = crosslinuxenv['FINALBUILDDIR'] + 'netpanzer'
 
-env.Append(CCFLAGS = ['-Wall' ])
+env.Append(CCFLAGS = ['-Wall'])
 
 env.BuildDir(env['FINALBUILDDIR'],'.',duplicate=0)
 crossmingwenv.BuildDir(crossmingwenv['FINALBUILDDIR'],'.',duplicate=0)
@@ -204,9 +204,9 @@
 # Configure Environments
 ################################################################
 
-env.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer' , 'src/lib/physfs'] )
-crossmingwenv.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer' , 'src/lib/physfs'] )
-crosslinuxenv.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer' , 'src/lib/physfs'] )
+env.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer', 'src/lib/physfs', 'src/Lib/lua', 'src/Lib/toluapp'] )
+crossmingwenv.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer', 'src/lib/physfs', 'src/Lib/lua', 'src/Lib/toluapp'])
+crosslinuxenv.Append( CPPPATH = [ '.', 'src/Lib', 'src/NetPanzer', 'src/lib/physfs', 'src/Lib/lua', 'src/Lib/toluapp'])
 
 # for this platform
 if thisplatform == 'darwin':
@@ -252,7 +252,8 @@
 MakeStaticLib(crosslinuxnetworkenv, 'npnetwork', 'Network', '*.cpp')
 
 # BUILDS LUA
-MakeStaticLib(luaenv, 'nplua', 'lua', '*.c')
+luaenv.Append( CPPPATH = [ 'src/Lib/lua', 'src/Lib/toluapp'] )
+MakeStaticLib(luaenv, 'nplua', 'lua toluapp', '*.c')
 MakeStaticLib(crossmingwluaenv, 'nplua', 'lua', '*.c')
 MakeStaticLib(crosslinuxluaenv, 'nplua', 'lua', '*.c')
 

Modified: trunk/netpanzer/scripts/initcolors.lua
===================================================================
--- trunk/netpanzer/scripts/initcolors.lua	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/scripts/initcolors.lua	2009-12-20 15:33:47 UTC (rev 1151)
@@ -1,77 +1,77 @@
-print(&quot;Setting colors&quot;);
-    Color.unitAqua        = ColorUtil.makeColor(  0, 204, 255);
-print(&quot;unitAqua is &quot; .. Color.unitAqua);
-    Color.unitYellow      = ColorUtil.makeColor(255, 255,   0);
-    Color.unitRed         = ColorUtil.makeColor(255,   0,   0);
-    Color.unitBlue        = ColorUtil.makeColor(  3,   3, 255);
-    Color.unitDarkBlue    = ColorUtil.makeColor(  0,   0, 128);
-    Color.unitLightGreen  = ColorUtil.makeColor(163, 214, 159);
-    Color.unitGreen       = ColorUtil.makeColor( 31, 166,  36);
-    Color.unitBlueGray    = ColorUtil.makeColor( 43,  85, 131);
-    Color.unitDarkRed     = ColorUtil.makeColor(150,   0,   0);
-    Color.unitBlack       = ColorUtil.makeColor(  6,   2,   2);
-    Color.unitDarkGreen   = ColorUtil.makeColor( 26,  88,  36);
-    Color.unitWhite       = ColorUtil.makeColor(250, 253, 248);
-    Color.unitLightOrange = ColorUtil.makeColor(246, 210,  99);
-    Color.unitOrange      = ColorUtil.makeColor(205, 144,   9);
-    Color.unitGray        = ColorUtil.makeColor(186, 186, 186);
-    Color.unitDarkGray    = ColorUtil.makeColor( 99, 100, 102);
+LOGGER:log(&quot;Setting colors&quot;);
+    Color.unitAqua        = Palette:makeColor(  0, 204, 255);
+LOGGER:log(&quot;unitAqua is &quot; .. Color.unitAqua);
+    Color.unitYellow      = Palette:makeColor(255, 255,   0);
+    Color.unitRed         = Palette:makeColor(255,   0,   0);
+    Color.unitBlue        = Palette:makeColor(  3,   3, 255);
+    Color.unitDarkBlue    = Palette:makeColor(  0,   0, 128);
+    Color.unitLightGreen  = Palette:makeColor(163, 214, 159);
+    Color.unitGreen       = Palette:makeColor( 31, 166,  36);
+    Color.unitBlueGray    = Palette:makeColor( 43,  85, 131);
+    Color.unitDarkRed     = Palette:makeColor(150,   0,   0);
+    Color.unitBlack       = Palette:makeColor(  6,   2,   2);
+    Color.unitDarkGreen   = Palette:makeColor( 26,  88,  36);
+    Color.unitWhite       = Palette:makeColor(250, 253, 248);
+    Color.unitLightOrange = Palette:makeColor(246, 210,  99);
+    Color.unitOrange      = Palette:makeColor(205, 144,   9);
+    Color.unitGray        = Palette:makeColor(186, 186, 186);
+    Color.unitDarkGray    = Palette:makeColor( 99, 100, 102);
 
     -- Grays
-    Color.black   = ColorUtil.makeColor(  0,   0,   0, true);
-    Color.gray32  = ColorUtil.makeColor( 32,  32,  32);
-    Color.gray64  = ColorUtil.makeColor( 64,  64,  64);
-    Color.gray96  = ColorUtil.makeColor( 96,  96,  96);
-    Color.gray128 = ColorUtil.makeColor(128, 128, 128);
-    Color.gray160 = ColorUtil.makeColor(160, 160, 160);
-    Color.gray192 = ColorUtil.makeColor(192, 192, 192);
-    Color.gray224 = ColorUtil.makeColor(224, 224, 224);
-    Color.white   = ColorUtil.makeColor(255, 255, 255);
-print(&quot;white is &quot; .. Color.white);
+    Color.black   = Palette:makeColor(  0,   0,   0); -- had a &quot;, true&quot; at end
+    Color.gray32  = Palette:makeColor( 32,  32,  32);
+    Color.gray64  = Palette:makeColor( 64,  64,  64);
+    Color.gray96  = Palette:makeColor( 96,  96,  96);
+    Color.gray128 = Palette:makeColor(128, 128, 128);
+    Color.gray160 = Palette:makeColor(160, 160, 160);
+    Color.gray192 = Palette:makeColor(192, 192, 192);
+    Color.gray224 = Palette:makeColor(224, 224, 224);
+    Color.white   = Palette:makeColor(255, 255, 255);
+LOGGER:log(&quot;white is &quot; .. Color.white);
     -- Dark Colors !FIXME!
     Color.darkGray    = Color.gray64;
-    Color.darkRed     = ColorUtil.makeColor(128,   0,   0); -- fixed
-    Color.darkGreen   = ColorUtil.makeColor(  0, 128,   0); -- fixed
-    Color.darkBlue    = ColorUtil.makeColor(  0,   0, 128); -- fixed
-    Color.darkYellow  = ColorUtil.makeColor(255, 168,  18); -- fixed
-    Color.darkOrange  = ColorUtil.makeColor(255, 140,   0); -- fixed
-    Color.darkMagenta = ColorUtil.makeColor(148,   0, 211); -- fixed
-    Color.darkCyan    = ColorUtil.makeColor(  0, 206, 209); -- fixed
+    Color.darkRed     = Palette:makeColor(128,   0,   0); -- fixed
+    Color.darkGreen   = Palette:makeColor(  0, 128,   0); -- fixed
+    Color.darkBlue    = Palette:makeColor(  0,   0, 128); -- fixed
+    Color.darkYellow  = Palette:makeColor(255, 168,  18); -- fixed
+    Color.darkOrange  = Palette:makeColor(255, 140,   0); -- fixed
+    Color.darkMagenta = Palette:makeColor(148,   0, 211); -- fixed
+    Color.darkCyan    = Palette:makeColor(  0, 206, 209); -- fixed
 
     -- Normal Colors
     Color.gray    = Color.gray128;
-    Color.red     = ColorUtil.makeColor(255,   0,   0); -- fixed
-    Color.green   = ColorUtil.makeColor(  0, 255,   0); -- fixed
-    Color.blue    = ColorUtil.makeColor(  0,   0, 255); -- fixed
-    Color.yellow  = ColorUtil.makeColor(255, 255,   0); -- fixed
-    Color.orange  = ColorUtil.makeColor(255, 128,   0); -- fixed
-    Color.magenta = ColorUtil.makeColor(255,   0, 255); -- fixed
-    Color.cyan    = ColorUtil.makeColor(  0, 255, 255); -- fixed
-    --Color.brown   = ColorUtil.makeColor(128,  42,  42); -- fixed
-    Color.brown   = ColorUtil.makeColor(200,  80,  80); -- new brown is lighter
+    Color.red     = Palette:makeColor(255,   0,   0); -- fixed
+    Color.green   = Palette:makeColor(  0, 255,   0); -- fixed
+    Color.blue    = Palette:makeColor(  0,   0, 255); -- fixed
+    Color.yellow  = Palette:makeColor(255, 255,   0); -- fixed
+    Color.orange  = Palette:makeColor(255, 128,   0); -- fixed
+    Color.magenta = Palette:makeColor(255,   0, 255); -- fixed
+    Color.cyan    = Palette:makeColor(  0, 255, 255); -- fixed
+    --Color.brown   = Palette:makeColor(128,  42,  42); -- fixed
+    Color.brown   = Palette:makeColor(200,  80,  80); -- new brown is lighter
     
     --tan                   210 180 140   0.8235 0.7059 0.5490
-    Color.tan            = ColorUtil.makeColor(210, 180, 140); -- fixed
+    Color.tan            = Palette:makeColor(210, 180, 140); -- fixed
     --chartreuse            127 255   0   0.4980 1.0000 0.0000
-    Color.chartreuse     = ColorUtil.makeColor(127, 255,   0); -- fixed
+    Color.chartreuse     = Palette:makeColor(127, 255,   0); -- fixed
     --cobalt_green           61 145  64   0.2400 0.5700 0.2500
-    Color.cobaltGreen    = ColorUtil.makeColor( 61, 145,  64); -- fixed
+    Color.cobaltGreen    = Palette:makeColor( 61, 145,  64); -- fixed
     --emerald_green           0 201  87   0.0000 0.7900 0.3400
-    Color.emeraldGreen   = ColorUtil.makeColor(  0, 201,  87); -- fixed
+    Color.emeraldGreen   = Palette:makeColor(  0, 201,  87); -- fixed
     --forest_green           34 139  34   0.1333 0.5451 0.1333
-    Color.forestGreen    = ColorUtil.makeColor( 34, 139,  34); -- fixed
+    Color.forestGreen    = Palette:makeColor( 34, 139,  34); -- fixed
     --olive_green_dark       85 107  47   0.3333 0.4196 0.1843
-    Color.darkOliveGreen = ColorUtil.makeColor( 85, 107,  47); -- fixed
+    Color.darkOliveGreen = Palette:makeColor( 85, 107,  47); -- fixed
     --terre_verte            56  94  15   0.2200 0.3700 0.0600
-    Color.terreVerte     = ColorUtil.makeColor( 56,  94,  15); -- fixed
+    Color.terreVerte     = Palette:makeColor( 56,  94,  15); -- fixed
 
     -- Normal Colors !FIXME!
     Color.lightGray    = Color.gray192;
-    Color.lightRed     = ColorUtil.makeColor(255, 160, 122); -- fixed
-    Color.lightGreen   = ColorUtil.makeColor( 50, 205,  50); -- fixed
-    Color.lightBlue    = ColorUtil.makeColor(135, 206, 250); -- fixed
-    Color.lightYellow  = ColorUtil.makeColor(255, 255, 224); -- fixed
-    Color.lightOrange  = ColorUtil.makeColor(237, 145,  33); -- fixed
-    Color.lightMagenta = ColorUtil.makeColor(  0, 255, 255);
-    Color.lightCyan    = ColorUtil.makeColor(224, 255, 255); -- fixed
+    Color.lightRed     = Palette:makeColor(255, 160, 122); -- fixed
+    Color.lightGreen   = Palette:makeColor( 50, 205,  50); -- fixed
+    Color.lightBlue    = Palette:makeColor(135, 206, 250); -- fixed
+    Color.lightYellow  = Palette:makeColor(255, 255, 224); -- fixed
+    Color.lightOrange  = Palette:makeColor(237, 145,  33); -- fixed
+    Color.lightMagenta = Palette:makeColor(  0, 255, 255);
+    Color.lightCyan    = Palette:makeColor(224, 255, 255); -- fixed
 

Modified: trunk/netpanzer/scripts/initialize.lua
===================================================================
--- trunk/netpanzer/scripts/initialize.lua	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/scripts/initialize.lua	2009-12-20 15:33:47 UTC (rev 1151)
@@ -1,3 +1,19 @@
 
-print(&quot;Lua is working from within a file!!!!!&quot;);
+LOGGER:log(&quot;Script initialization&quot;);
 
+function onUserMessage(msg)
+    local msgx = &quot;Wants to send message: '&quot; .. msg .. &quot;'&quot;;
+    LOGGER:log(msgx);
+    if msg == &quot;/info&quot; then
+        ConsoleInterface:post( Color.cyan, false, 0, &quot;It is info message&quot;);
+        ConsoleInterface:post( Color.cyan, false, 0, &quot;You are player: &quot; .. PlayerInterface:getLocalPlayerIndex());
+        ps = PlayerInterface:getLocalPlayer();
+        ConsoleInterface:post( Color.cyan, true, ps:getFlag(), &quot;Your name is &quot; .. ps:getName());
+        ConsoleInterface:post( Color.cyan, false, 0, &quot;Your id is &quot; .. ps:getID());
+        ConsoleInterface:post( Color.cyan, false, 0, &quot;Your have &quot; .. ps:getObjectivesHeld() .. &quot; bases&quot;);
+
+    else
+        ConsoleInterface:post( Color.cyan, false, 0, msgx);
+    end
+
+end
\ No newline at end of file

Modified: trunk/netpanzer/src/Lib/2D/Color.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Color.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/2D/Color.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -88,26 +88,10 @@
 #define MERGE_CLASS(a) a::
 #define GEN_VAR(CNAME) IntColor MERGE_CLASS(Color)CNAME;
 
-#define GEN_GETSTRUCT(CNAME) { #CNAME, GETSVTYPE_INT, &amp;MERGE_CLASS(Color)CNAME },
-#define GEN_SETSTRUCT(CNAME) { #CNAME, SETSVTYPE_INT, &amp;MERGE_CLASS(Color)CNAME },
-
 // This generate the Uint8 Color::colorname for all the colors
 // Must not have ';' at end
 GEN_COLORS(GEN_VAR)
 
-// This generates the tables needed for script binding
-const ScriptVarBindRecord Color::colorGetters[] =
-{
-    GEN_COLORS(GEN_GETSTRUCT)
-    {0,0}
-};
-        
-const ScriptVarBindRecord Color::colorSetters[] =
-{
-    GEN_COLORS(GEN_SETSTRUCT)
-    {0,0}
-};
-
 SDL_Color NamedColors::colors[] =
 {
 	{  0,   0,   0,   0}, // black

Modified: trunk/netpanzer/src/Lib/2D/Color.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Color.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/2D/Color.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -103,9 +103,6 @@
 class Color
 {
 public:
-
-    static const ScriptVarBindRecord colorGetters[];
-    static const ScriptVarBindRecord colorSetters[];
     // Color for netPanzer players.
     static IntColor unitAqua;
     static IntColor unitYellow;
@@ -180,8 +177,7 @@
     static IntColor gray192;
     static IntColor gray224;
 
-}
-; // end Color
+};
 
 #endif // end __Color_hpp__
 

Modified: trunk/netpanzer/src/Lib/2D/Palette.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Palette.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/2D/Palette.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -35,34 +35,13 @@
 } // end Palette::Palette
 
 int
-Palette::makeColor(lua_State *L)
+Palette::makeColor(int r, int g, int b)
 {
-    int r = luaL_checkint(L,1); // r
-    int g = luaL_checkint(L,2); // g
-    int b = luaL_checkint(L,3); // b
-    
 //    int color = findNearestColor(r,g,b,true);
     IntColor color = SDL_MapRGB(screen-&gt;getPixelFormat(), r, g, b);
-    
-    lua_pushinteger(L, color);
-    return 1;
+    return color;
 }
 
-static const luaL_reg colorUtilLib[] =
-{
-    {&quot;makeColor&quot;,   Palette::makeColor},
-    {0,0}
-};
-
-void
-Palette::registerScript()
-{
-    ScriptManager::registerLib( &quot;ColorUtil&quot;, colorUtilLib);
-    ScriptManager::bindStaticVariables( &quot;Color&quot;, &quot;ColorMetaTable&quot;,
-                                       Color::colorGetters,
-                                       Color::colorSetters);
-}
-
 // setColors
 //---------------------------------------------------------------------------
 void Palette::setColors()

Modified: trunk/netpanzer/src/Lib/2D/Palette.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Palette.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/2D/Palette.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -23,7 +23,6 @@
 #include &lt;cassert&gt;
 
 #include &quot;Color.hpp&quot;
-#include &quot;Scripts/ScriptManager.hpp&quot;
 
 const size_t PALETTE_LENGTH = 256;
 
@@ -49,8 +48,7 @@
     static Uint8 findNearestColor(int r, int g, int b, const bool &amp;ignoreIndexZero = false);
     static void init();
     static void setColors();
-    static int makeColor(lua_State *L);
-    static void registerScript();
+    static int makeColor(int r, int g, int b);
 };
 
 #endif // end __Palette_hpp__

Modified: trunk/netpanzer/src/Lib/2D/Surface.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Surface.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/2D/Surface.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -283,7 +283,8 @@
 void Surface::bltSolid(Surface &amp;dest, int x, int y) const
 {
     SDL_Rect r = { x + offset.x, y+offset.y, 0, 0 };
-    SDL_SetAlpha(cur_frame, cur_frame-&gt;flags &amp; (~SDL_SRCALPHA), 255);
+    // XXX this slows it so much
+//    SDL_SetAlpha(cur_frame, cur_frame-&gt;flags &amp; (~SDL_SRCALPHA), 255);
     SDL_BlitSurface( cur_frame, 0, dest.cur_frame, &amp;r);
 }
 

Modified: trunk/netpanzer/src/Lib/Util/Log.cpp
===================================================================
--- trunk/netpanzer/src/Lib/Util/Log.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/Util/Log.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -142,6 +142,14 @@
     }    
 
 }
+
+void
+Logger::log(const char * str)
+{
+//    printf(&quot;xxx Received str: '%s'\n&quot;, str);
+    warning(&quot;* %s&quot;, str);
+}
+
 //-----------------------------------------------------------------
 void
 Logger::log(int priority, const char *fmt, va_list ap)

Modified: trunk/netpanzer/src/Lib/Util/Log.hpp
===================================================================
--- trunk/netpanzer/src/Lib/Util/Log.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/Util/Log.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -49,6 +49,8 @@
     void warning(const char *fmt, ...)
         __attribute__((format (__printf__, 2, 3)));
 
+    void log(const char * str);
+
 private:
     void log(int priority, const char *fmt, va_list ap);
     void cleanLogs();

Added: trunk/netpanzer/src/Lib/toluapp/tolua++.h
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua++.h	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua++.h	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,186 @@
+/* tolua
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+
+#ifndef TOLUA_H
+#define TOLUA_H
+
+#ifndef TOLUA_API
+#define TOLUA_API extern
+#endif
+
+#define TOLUA_VERSION &quot;tolua++-1.0.92&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define tolua_pushcppstring(x,y)	tolua_pushstring(x,y.c_str())
+#define tolua_iscppstring	tolua_isstring
+
+#define tolua_iscppstringarray tolua_isstringarray
+#define tolua_pushfieldcppstring(L,lo,idx,s) tolua_pushfieldstring(L, lo, idx, s.c_str())
+
+#ifndef TEMPLATE_BIND
+ #define TEMPLATE_BIND(p)
+#endif
+
+#define TOLUA_TEMPLATE_BIND(p)
+
+#define TOLUA_PROTECTED_DESTRUCTOR
+#define TOLUA_PROPERTY_TYPE(p)
+
+typedef int lua_Object;
+
+#include &quot;lua.h&quot;
+#include &quot;lauxlib.h&quot;
+
+struct tolua_Error
+{
+	int index;
+	int array;
+	const char* type;
+};
+typedef struct tolua_Error tolua_Error;
+
+#define TOLUA_NOPEER	LUA_REGISTRYINDEX /* for lua 5.1 */
+
+TOLUA_API const char* tolua_typename (lua_State* L, int lo);
+TOLUA_API void tolua_error (lua_State* L, const char* msg, tolua_Error* err);
+TOLUA_API int tolua_isnoobj (lua_State* L, int lo, tolua_Error* err);
+TOLUA_API int tolua_isvalue (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_isvaluenil (lua_State* L, int lo, tolua_Error* err);
+TOLUA_API int tolua_isboolean (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_isnumber (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_isstring (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_istable (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_isusertable (lua_State* L, int lo, const char* type, int def, tolua_Error* err);
+TOLUA_API int tolua_isuserdata (lua_State* L, int lo, int def, tolua_Error* err);
+TOLUA_API int tolua_isusertype (lua_State* L, int lo, const char* type, int def, tolua_Error* err);
+TOLUA_API int tolua_isvaluearray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_isbooleanarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_isnumberarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_isstringarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_istablearray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_isuserdataarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err);
+TOLUA_API int tolua_isusertypearray
+ (lua_State* L, int lo, const char* type, int dim, int def, tolua_Error* err);
+
+TOLUA_API void tolua_open (lua_State* L);
+
+TOLUA_API void* tolua_copy (lua_State* L, void* value, unsigned int size);
+TOLUA_API int tolua_register_gc (lua_State* L, int lo);
+TOLUA_API int tolua_default_collect (lua_State* tolua_S);
+
+TOLUA_API void tolua_usertype (lua_State* L, const char* type);
+TOLUA_API void tolua_beginmodule (lua_State* L, const char* name);
+TOLUA_API void tolua_endmodule (lua_State* L);
+TOLUA_API void tolua_module (lua_State* L, const char* name, int hasvar);
+TOLUA_API void tolua_class (lua_State* L, const char* name, const char* base);
+TOLUA_API void tolua_cclass (lua_State* L, const char* lname, const char* name, const char* base, lua_CFunction col);
+TOLUA_API void tolua_function (lua_State* L, const char* name, lua_CFunction func);
+TOLUA_API void tolua_constant (lua_State* L, const char* name, lua_Number value);
+TOLUA_API void tolua_variable (lua_State* L, const char* name, lua_CFunction get, lua_CFunction set);
+TOLUA_API void tolua_array (lua_State* L,const char* name, lua_CFunction get, lua_CFunction set);
+
+/* TOLUA_API void tolua_set_call_event(lua_State* L, lua_CFunction func, char* type); */
+/* TOLUA_API void tolua_addbase(lua_State* L, char* name, char* base); */
+
+TOLUA_API void tolua_pushvalue (lua_State* L, int lo);
+TOLUA_API void tolua_pushboolean (lua_State* L, int value);
+TOLUA_API void tolua_pushnumber (lua_State* L, lua_Number value);
+TOLUA_API void tolua_pushstring (lua_State* L, const char* value);
+TOLUA_API void tolua_pushuserdata (lua_State* L, void* value);
+TOLUA_API void tolua_pushusertype (lua_State* L, void* value, const char* type);
+TOLUA_API void tolua_pushusertype_and_takeownership(lua_State* L, void* value, const char* type);
+TOLUA_API void tolua_pushfieldvalue (lua_State* L, int lo, int index, int v);
+TOLUA_API void tolua_pushfieldboolean (lua_State* L, int lo, int index, int v);
+TOLUA_API void tolua_pushfieldnumber (lua_State* L, int lo, int index, lua_Number v);
+TOLUA_API void tolua_pushfieldstring (lua_State* L, int lo, int index, const char* v);
+TOLUA_API void tolua_pushfielduserdata (lua_State* L, int lo, int index, void* v);
+TOLUA_API void tolua_pushfieldusertype (lua_State* L, int lo, int index, void* v, const char* type);
+TOLUA_API void tolua_pushfieldusertype_and_takeownership (lua_State* L, int lo, int index, void* v, const char* type);
+
+TOLUA_API lua_Number tolua_tonumber (lua_State* L, int narg, lua_Number def);
+TOLUA_API const char* tolua_tostring (lua_State* L, int narg, const char* def);
+TOLUA_API void* tolua_touserdata (lua_State* L, int narg, void* def);
+TOLUA_API void* tolua_tousertype (lua_State* L, int narg, void* def);
+TOLUA_API int tolua_tovalue (lua_State* L, int narg, int def);
+TOLUA_API int tolua_toboolean (lua_State* L, int narg, int def);
+TOLUA_API lua_Number tolua_tofieldnumber (lua_State* L, int lo, int index, lua_Number def);
+TOLUA_API const char* tolua_tofieldstring (lua_State* L, int lo, int index, const char* def);
+TOLUA_API void* tolua_tofielduserdata (lua_State* L, int lo, int index, void* def);
+TOLUA_API void* tolua_tofieldusertype (lua_State* L, int lo, int index, void* def);
+TOLUA_API int tolua_tofieldvalue (lua_State* L, int lo, int index, int def);
+TOLUA_API int tolua_getfieldboolean (lua_State* L, int lo, int index, int def);
+
+TOLUA_API void tolua_dobuffer(lua_State* L, char* B, unsigned int size, const char* name);
+
+TOLUA_API int class_gc_event (lua_State* L);
+
+#ifdef __cplusplus
+static inline const char* tolua_tocppstring (lua_State* L, int narg, const char* def) {
+
+	const char* s = tolua_tostring(L, narg, def);
+	return s?s:&quot;&quot;;
+};
+
+static inline const char* tolua_tofieldcppstring (lua_State* L, int lo, int index, const char* def) {
+
+	const char* s = tolua_tofieldstring(L, lo, index, def);
+	return s?s:&quot;&quot;;
+};
+
+#else
+#define tolua_tocppstring tolua_tostring
+#define tolua_tofieldcppstring tolua_tofieldstring
+#endif
+
+TOLUA_API int tolua_fast_isa(lua_State *L, int mt_indexa, int mt_indexb, int super_index);
+
+#ifndef Mtolua_new
+#define Mtolua_new(EXP) new EXP
+#endif
+
+#ifndef Mtolua_delete
+#define Mtolua_delete(EXP) delete EXP
+#endif
+
+#ifndef Mtolua_new_dim
+#define Mtolua_new_dim(EXP, len) new EXP[len]
+#endif
+
+#ifndef Mtolua_delete_dim
+#define Mtolua_delete_dim(EXP) delete [] EXP
+#endif
+
+#ifndef tolua_outside
+#define tolua_outside
+#endif
+
+#ifndef tolua_owned
+#define tolua_owned
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

Added: trunk/netpanzer/src/Lib/toluapp/tolua_event.c
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_event.c	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_event.c	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,536 @@
+/* tolua: event functions
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#include &lt;stdio.h&gt;
+
+#include &quot;tolua++.h&quot;
+
+/* Store at ubox
+	* It stores, creating the corresponding table if needed,
+	* the pair key/value in the corresponding ubox table
+*/
+static void storeatubox (lua_State* L, int lo)
+{
+	#ifdef LUA_VERSION_NUM
+		lua_getfenv(L, lo);
+		if (lua_rawequal(L, -1, TOLUA_NOPEER)) {
+			lua_pop(L, 1);
+			lua_newtable(L);
+			lua_pushvalue(L, -1);
+			lua_setfenv(L, lo);	/* stack: k,v,table  */
+		};
+		lua_insert(L, -3);
+		lua_settable(L, -3); /* on lua 5.1, we trade the &quot;tolua_peers&quot; lookup for a settable call */
+		lua_pop(L, 1);
+	#else
+	 /* stack: key value (to be stored) */
+		lua_pushstring(L,&quot;tolua_peers&quot;);
+		lua_rawget(L,LUA_REGISTRYINDEX);        /* stack: k v ubox */
+		lua_pushvalue(L,lo);
+		lua_rawget(L,-2);                       /* stack: k v ubox ubox[u] */
+		if (!lua_istable(L,-1))
+		{
+			lua_pop(L,1);                          /* stack: k v ubox */
+			lua_newtable(L);                       /* stack: k v ubox table */
+			lua_pushvalue(L,1);
+			lua_pushvalue(L,-2);                   /* stack: k v ubox table u table */
+			lua_rawset(L,-4);                      /* stack: k v ubox ubox[u]=table */
+		}
+		lua_insert(L,-4);                       /* put table before k */
+		lua_pop(L,1);                           /* pop ubox */
+		lua_rawset(L,-3);                       /* store at table */
+		lua_pop(L,1);                           /* pop ubox[u] */
+	#endif
+}
+
+/* Module index function
+*/
+static int module_index_event (lua_State* L)
+{
+	lua_pushstring(L,&quot;.get&quot;);
+	lua_rawget(L,-3);
+	if (lua_istable(L,-1))
+	{
+		lua_pushvalue(L,2);  /* key */
+		lua_rawget(L,-2);
+		if (lua_iscfunction(L,-1))
+		{
+			lua_call(L,0,1);
+			return 1;
+		}
+		else if (lua_istable(L,-1))
+			return 1;
+	}
+	/* call old index meta event */
+	if (lua_getmetatable(L,1))
+	{
+		lua_pushstring(L,&quot;__index&quot;);
+		lua_rawget(L,-2);
+		lua_pushvalue(L,1);
+		lua_pushvalue(L,2);
+		if (lua_isfunction(L,-1))
+		{
+			lua_call(L,2,1);
+			return 1;
+		}
+		else if (lua_istable(L,-1))
+		{
+			lua_gettable(L,-3);
+			return 1;
+		}
+	}
+	lua_pushnil(L);
+	return 1;
+}
+
+/* Module newindex function
+*/
+static int module_newindex_event (lua_State* L)
+{
+	lua_pushstring(L,&quot;.set&quot;);
+	lua_rawget(L,-4);
+	if (lua_istable(L,-1))
+	{
+		lua_pushvalue(L,2);  /* key */
+		lua_rawget(L,-2);
+		if (lua_iscfunction(L,-1))
+		{
+			lua_pushvalue(L,1); /* only to be compatible with non-static vars */
+			lua_pushvalue(L,3); /* value */
+			lua_call(L,2,0);
+			return 0;
+		}
+	}
+	/* call old newindex meta event */
+	if (lua_getmetatable(L,1) &amp;&amp; lua_getmetatable(L,-1))
+	{
+		lua_pushstring(L,&quot;__newindex&quot;);
+		lua_rawget(L,-2);
+		if (lua_isfunction(L,-1))
+		{
+		 lua_pushvalue(L,1);
+		 lua_pushvalue(L,2);
+		 lua_pushvalue(L,3);
+			lua_call(L,3,0);
+		}
+	}
+	lua_settop(L,3);
+	lua_rawset(L,-3);
+	return 0;
+}
+
+/* Class index function
+	* If the object is a userdata (ie, an object), it searches the field in
+	* the alternative table stored in the corresponding &quot;ubox&quot; table.
+*/
+static int class_index_event (lua_State* L)
+{
+ int t = lua_type(L,1);
+	if (t == LUA_TUSERDATA)
+	{
+		/* Access alternative table */
+		#ifdef LUA_VERSION_NUM /* new macro on version 5.1 */
+		lua_getfenv(L,1);
+		if (!lua_rawequal(L, -1, TOLUA_NOPEER)) {
+			lua_pushvalue(L, 2); /* key */
+			lua_gettable(L, -2); /* on lua 5.1, we trade the &quot;tolua_peers&quot; lookup for a gettable call */
+			if (!lua_isnil(L, -1))
+				return 1;
+		};
+		#else
+		lua_pushstring(L,&quot;tolua_peers&quot;);
+		lua_rawget(L,LUA_REGISTRYINDEX);        /* stack: obj key ubox */
+		lua_pushvalue(L,1);
+		lua_rawget(L,-2);                       /* stack: obj key ubox ubox[u] */
+		if (lua_istable(L,-1))
+		{
+			lua_pushvalue(L,2);  /* key */
+			lua_rawget(L,-2);                      /* stack: obj key ubox ubox[u] value */
+			if (!lua_isnil(L,-1))
+				return 1;
+		}
+		#endif
+		lua_settop(L,2);                        /* stack: obj key */
+		/* Try metatables */
+		lua_pushvalue(L,1);                     /* stack: obj key obj */
+		while (lua_getmetatable(L,-1))
+		{                                       /* stack: obj key obj mt */
+			lua_remove(L,-2);                      /* stack: obj key mt */
+			if (lua_isnumber(L,2))                 /* check if key is a numeric value */
+			{
+				/* try operator[] */
+				lua_pushstring(L,&quot;.geti&quot;);
+				lua_rawget(L,-2);                      /* stack: obj key mt func */
+				if (lua_isfunction(L,-1))
+				{
+					lua_pushvalue(L,1);
+					lua_pushvalue(L,2);
+					lua_call(L,2,1);
+					return 1;
+				}
+			}
+			else
+			{
+			 lua_pushvalue(L,2);                    /* stack: obj key mt key */
+				lua_rawget(L,-2);                      /* stack: obj key mt value */
+				if (!lua_isnil(L,-1))
+					return 1;
+				else
+					lua_pop(L,1);
+				/* try C/C++ variable */
+				lua_pushstring(L,&quot;.get&quot;);
+				lua_rawget(L,-2);                      /* stack: obj key mt tget */
+				if (lua_istable(L,-1))
+				{
+					lua_pushvalue(L,2);
+					lua_rawget(L,-2);                      /* stack: obj key mt value */
+					if (lua_iscfunction(L,-1))
+					{
+						lua_pushvalue(L,1);
+						lua_pushvalue(L,2);
+						lua_call(L,2,1);
+						return 1;
+					}
+					else if (lua_istable(L,-1))
+					{
+						/* deal with array: create table to be returned and cache it in ubox */
+						void* u = *((void**)lua_touserdata(L,1));
+						lua_newtable(L);                /* stack: obj key mt value table */
+						lua_pushstring(L,&quot;.self&quot;);
+						lua_pushlightuserdata(L,u);
+						lua_rawset(L,-3);               /* store usertype in &quot;.self&quot; */
+						lua_insert(L,-2);               /* stack: obj key mt table value */
+						lua_setmetatable(L,-2);         /* set stored value as metatable */
+						lua_pushvalue(L,-1);            /* stack: obj key met table table */
+						lua_pushvalue(L,2);             /* stack: obj key mt table table key */
+						lua_insert(L,-2);               /*  stack: obj key mt table key table */
+						storeatubox(L,1);               /* stack: obj key mt table */
+						return 1;
+					}
+				}
+			}
+			lua_settop(L,3);
+		}
+		lua_pushnil(L);
+		return 1;
+	}
+	else if (t== LUA_TTABLE)
+	{
+		module_index_event(L);
+		return 1;
+	}
+	lua_pushnil(L);
+	return 1;
+}
+
+/* Newindex function
+	* It first searches for a C/C++ varaible to be set.
+	* Then, it either stores it in the alternative ubox table (in the case it is
+	* an object) or in the own table (that represents the class or module).
+*/
+static int class_newindex_event (lua_State* L)
+{
+ int t = lua_type(L,1);
+	if (t == LUA_TUSERDATA)
+	{
+	 /* Try accessing a C/C++ variable to be set */
+		lua_getmetatable(L,1);
+		while (lua_istable(L,-1))                /* stack: t k v mt */
+		{
+			if (lua_isnumber(L,2))                 /* check if key is a numeric value */
+			{
+				/* try operator[] */
+				lua_pushstring(L,&quot;.seti&quot;);
+				lua_rawget(L,-2);                      /* stack: obj key mt func */
+				if (lua_isfunction(L,-1))
+				{
+					lua_pushvalue(L,1);
+					lua_pushvalue(L,2);
+					lua_pushvalue(L,3);
+					lua_call(L,3,0);
+					return 0;
+				}
+			}
+			else
+			{
+				lua_pushstring(L,&quot;.set&quot;);
+				lua_rawget(L,-2);                      /* stack: t k v mt tset */
+				if (lua_istable(L,-1))
+				{
+					lua_pushvalue(L,2);
+					lua_rawget(L,-2);                     /* stack: t k v mt tset func */
+					if (lua_iscfunction(L,-1))
+					{
+						lua_pushvalue(L,1);
+						lua_pushvalue(L,3);
+						lua_call(L,2,0);
+						return 0;
+					}
+					lua_pop(L,1);                          /* stack: t k v mt tset */
+				}
+				lua_pop(L,1);                           /* stack: t k v mt */
+				if (!lua_getmetatable(L,-1))            /* stack: t k v mt mt */
+					lua_pushnil(L);
+				lua_remove(L,-2);                       /* stack: t k v mt */
+			}
+		}
+	 lua_settop(L,3);                          /* stack: t k v */
+
+		/* then, store as a new field */
+		storeatubox(L,1);
+	}
+	else if (t== LUA_TTABLE)
+	{
+		module_newindex_event(L);
+	}
+	return 0;
+}
+
+static int class_call_event(lua_State* L) {
+
+	if (lua_istable(L, 1)) {
+		lua_pushstring(L, &quot;.call&quot;);
+		lua_rawget(L, 1);
+		if (lua_isfunction(L, -1)) {
+
+			lua_insert(L, 1);
+			lua_call(L, lua_gettop(L)-1, 1);
+
+			return 1;
+		};
+	};
+	tolua_error(L,&quot;Attempt to call a non-callable object.&quot;,NULL);
+	return 0;
+};
+
+static int do_operator (lua_State* L, const char* op)
+{
+	if (lua_isuserdata(L,1))
+	{
+		/* Try metatables */
+		lua_pushvalue(L,1);                     /* stack: op1 op2 */
+		while (lua_getmetatable(L,-1))
+		{                                       /* stack: op1 op2 op1 mt */
+			lua_remove(L,-2);                      /* stack: op1 op2 mt */
+			lua_pushstring(L,op);                  /* stack: op1 op2 mt key */
+			lua_rawget(L,-2);                      /* stack: obj key mt func */
+			if (lua_isfunction(L,-1))
+			{
+				lua_pushvalue(L,1);
+				lua_pushvalue(L,2);
+				lua_call(L,2,1);
+				return 1;
+			}
+			lua_settop(L,3);
+		}
+	}
+	tolua_error(L,&quot;Attempt to perform operation on an invalid operand&quot;,NULL);
+	return 0;
+}
+
+static int class_add_event (lua_State* L)
+{
+	return do_operator(L,&quot;.add&quot;);
+}
+
+static int class_sub_event (lua_State* L)
+{
+	return do_operator(L,&quot;.sub&quot;);
+}
+
+static int class_mul_event (lua_State* L)
+{
+	return do_operator(L,&quot;.mul&quot;);
+}
+
+static int class_div_event (lua_State* L)
+{
+	return do_operator(L,&quot;.div&quot;);
+}
+
+static int class_lt_event (lua_State* L)
+{
+	return do_operator(L,&quot;.lt&quot;);
+}
+
+static int class_le_event (lua_State* L)
+{
+	return do_operator(L,&quot;.le&quot;);
+}
+
+static int class_eq_event (lua_State* L)
+{
+	/* copying code from do_operator here to return false when no operator is found */
+	if (lua_isuserdata(L,1))
+	{
+		/* Try metatables */
+		lua_pushvalue(L,1);                     /* stack: op1 op2 */
+		while (lua_getmetatable(L,-1))
+		{                                       /* stack: op1 op2 op1 mt */
+			lua_remove(L,-2);                      /* stack: op1 op2 mt */
+			lua_pushstring(L,&quot;.eq&quot;);                  /* stack: op1 op2 mt key */
+			lua_rawget(L,-2);                      /* stack: obj key mt func */
+			if (lua_isfunction(L,-1))
+			{
+				lua_pushvalue(L,1);
+				lua_pushvalue(L,2);
+				lua_call(L,2,1);
+				return 1;
+			}
+			lua_settop(L,3);
+		}
+	}
+
+	lua_settop(L, 3);
+	lua_pushboolean(L, 0);
+	return 1;
+}
+
+/*
+static int class_gc_event (lua_State* L)
+{
+	void* u = *((void**)lua_touserdata(L,1));
+	fprintf(stderr, &quot;collecting: looking at %p\n&quot;, u);
+	lua_pushstring(L,&quot;tolua_gc&quot;);
+	lua_rawget(L,LUA_REGISTRYINDEX);
+	lua_pushlightuserdata(L,u);
+	lua_rawget(L,-2);
+	if (lua_isfunction(L,-1))
+	{
+		lua_pushvalue(L,1);
+		lua_call(L,1,0);
+ 		lua_pushlightuserdata(L,u);
+		lua_pushnil(L);
+		lua_rawset(L,-3);
+	}
+	lua_pop(L,2);
+	return 0;
+}
+*/
+TOLUA_API int class_gc_event (lua_State* L)
+{
+	void* u = *((void**)lua_touserdata(L,1));
+	int top;
+	/*fprintf(stderr, &quot;collecting: looking at %p\n&quot;, u);*/
+	/*
+	lua_pushstring(L,&quot;tolua_gc&quot;);
+	lua_rawget(L,LUA_REGISTRYINDEX);
+	*/
+	lua_pushvalue(L, lua_upvalueindex(1));
+	lua_pushlightuserdata(L,u);
+	lua_rawget(L,-2);            /* stack: gc umt    */
+	lua_getmetatable(L,1);       /* stack: gc umt mt */
+	/*fprintf(stderr, &quot;checking type\n&quot;);*/
+	top = lua_gettop(L);
+	if (tolua_fast_isa(L,top,top-1, lua_upvalueindex(2))) /* make sure we collect correct type */
+	{
+		/*fprintf(stderr, &quot;Found type!\n&quot;);*/
+		/* get gc function */
+		lua_pushliteral(L,&quot;.collector&quot;);
+		lua_rawget(L,-2);           /* stack: gc umt mt collector */
+		if (lua_isfunction(L,-1)) {
+			/*fprintf(stderr, &quot;Found .collector!\n&quot;);*/
+		}
+		else {
+			lua_pop(L,1);
+			/*fprintf(stderr, &quot;Using default cleanup\n&quot;);*/
+			lua_pushcfunction(L,tolua_default_collect);
+		}
+
+		lua_pushvalue(L,1);         /* stack: gc umt mt collector u */
+		lua_call(L,1,0);
+
+		lua_pushlightuserdata(L,u); /* stack: gc umt mt u */
+		lua_pushnil(L);             /* stack: gc umt mt u nil */
+		lua_rawset(L,-5);           /* stack: gc umt mt */
+	}
+	lua_pop(L,3);
+	return 0;
+}
+
+
+/* Register module events
+	* It expects the metatable on the top of the stack
+*/
+TOLUA_API void tolua_moduleevents (lua_State* L)
+{
+	lua_pushstring(L,&quot;__index&quot;);
+	lua_pushcfunction(L,module_index_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__newindex&quot;);
+	lua_pushcfunction(L,module_newindex_event);
+	lua_rawset(L,-3);
+}
+
+/* Check if the object on the top has a module metatable
+*/
+TOLUA_API int tolua_ismodulemetatable (lua_State* L)
+{
+	int r = 0;
+	if (lua_getmetatable(L,-1))
+	{
+		lua_pushstring(L,&quot;__index&quot;);
+		lua_rawget(L,-2);
+		r = (lua_tocfunction(L,-1) == module_index_event);
+		lua_pop(L,2);
+	}
+	return r;
+}
+
+/* Register class events
+	* It expects the metatable on the top of the stack
+*/
+TOLUA_API void tolua_classevents (lua_State* L)
+{
+	lua_pushstring(L,&quot;__index&quot;);
+	lua_pushcfunction(L,class_index_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__newindex&quot;);
+	lua_pushcfunction(L,class_newindex_event);
+	lua_rawset(L,-3);
+
+	lua_pushstring(L,&quot;__add&quot;);
+	lua_pushcfunction(L,class_add_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__sub&quot;);
+	lua_pushcfunction(L,class_sub_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__mul&quot;);
+	lua_pushcfunction(L,class_mul_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__div&quot;);
+	lua_pushcfunction(L,class_div_event);
+	lua_rawset(L,-3);
+
+	lua_pushstring(L,&quot;__lt&quot;);
+	lua_pushcfunction(L,class_lt_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__le&quot;);
+	lua_pushcfunction(L,class_le_event);
+	lua_rawset(L,-3);
+	lua_pushstring(L,&quot;__eq&quot;);
+	lua_pushcfunction(L,class_eq_event);
+	lua_rawset(L,-3);
+
+	lua_pushstring(L,&quot;__call&quot;);
+	lua_pushcfunction(L,class_call_event);
+	lua_rawset(L,-3);
+
+	lua_pushstring(L,&quot;__gc&quot;);
+	lua_pushstring(L, &quot;tolua_gc_event&quot;);
+	lua_rawget(L, LUA_REGISTRYINDEX);
+	/*lua_pushcfunction(L,class_gc_event);*/
+	lua_rawset(L,-3);
+}
+

Added: trunk/netpanzer/src/Lib/toluapp/tolua_event.h
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_event.h	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_event.h	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,24 @@
+/* tolua: event functions
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#ifndef TOLUA_EVENT_H
+#define TOLUA_EVENT_H
+
+#include &quot;tolua++.h&quot;
+
+TOLUA_API void tolua_moduleevents (lua_State* L);
+TOLUA_API int tolua_ismodulemetatable (lua_State* L);
+TOLUA_API void tolua_classevents (lua_State* L);
+
+#endif

Added: trunk/netpanzer/src/Lib/toluapp/tolua_is.c
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_is.c	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_is.c	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,621 @@
+/* tolua: functions to check types.
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#include &quot;tolua++.h&quot;
+#include &quot;lauxlib.h&quot;
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+/* a fast check if a is b, without parameter validation
+ i.e. if b is equal to a or a superclass of a. */
+TOLUA_API int tolua_fast_isa(lua_State *L, int mt_indexa, int mt_indexb, int super_index)
+{
+ int result;
+	if (lua_rawequal(L,mt_indexa,mt_indexb))
+		result = 1;
+	else
+	{
+		if (super_index) {
+			lua_pushvalue(L, super_index);
+		} else {
+			lua_pushliteral(L,&quot;tolua_super&quot;);
+			lua_rawget(L,LUA_REGISTRYINDEX);  /* stack: super */
+		};
+		lua_pushvalue(L,mt_indexa);       /* stack: super mta */
+		lua_rawget(L,-2);                 /* stack: super super[mta] */
+		lua_pushvalue(L,mt_indexb);       /* stack: super super[mta] mtb */
+		lua_rawget(L,LUA_REGISTRYINDEX);  /* stack: super super[mta] typenameB */
+		lua_rawget(L,-2);                 /* stack: super super[mta] bool */
+		result = lua_toboolean(L,-1);
+		lua_pop(L,3);
+	}
+	return result;
+}
+
+/* Push and returns the corresponding object typename */
+TOLUA_API const char* tolua_typename (lua_State* L, int lo)
+{
+	int tag = lua_type(L,lo);
+ if (tag == LUA_TNONE)
+  lua_pushstring(L,&quot;[no object]&quot;);
+ else if (tag != LUA_TUSERDATA &amp;&amp; tag != LUA_TTABLE)
+  lua_pushstring(L,lua_typename(L,tag));
+ else if (tag == LUA_TUSERDATA)
+ {
+  if (!lua_getmetatable(L,lo))
+   lua_pushstring(L,lua_typename(L,tag));
+		else
+		{
+		 lua_rawget(L,LUA_REGISTRYINDEX);
+		 if (!lua_isstring(L,-1))
+			{
+		  lua_pop(L,1);
+				lua_pushstring(L,&quot;[undefined]&quot;);
+			}
+		}
+	}
+	else  /* is table */
+	{
+		lua_pushvalue(L,lo);
+		lua_rawget(L,LUA_REGISTRYINDEX);
+		if (!lua_isstring(L,-1))
+		{
+			lua_pop(L,1);
+			lua_pushstring(L,&quot;table&quot;);
+		}
+		else
+		{
+   lua_pushstring(L,&quot;class &quot;);
+			lua_insert(L,-2);
+			lua_concat(L,2);
+		}
+	}
+	return lua_tostring(L,-1);
+}
+
+TOLUA_API void tolua_error (lua_State* L, const char* msg, tolua_Error* err)
+{
+	if (msg[0] == '#')
+	{
+  const char* expected = err-&gt;type;
+		const char* provided = tolua_typename(L,err-&gt;index);
+  if (msg[1]=='f')
+  {
+   int narg = err-&gt;index;
+			if (err-&gt;array)
+    luaL_error(L,&quot;%s\n     argument #%d is array of '%s'; array of '%s' expected.\n&quot;,
+               msg+2,narg,provided,expected);
+			else
+    luaL_error(L,&quot;%s\n     argument #%d is '%s'; '%s' expected.\n&quot;,
+               msg+2,narg,provided,expected);
+  }
+  else if (msg[1]=='v')
+		{
+			if (err-&gt;array)
+    luaL_error(L,&quot;%s\n     value is array of '%s'; array of '%s' expected.\n&quot;,
+               msg+2,provided,expected);
+			else
+    luaL_error(L,&quot;%s\n     value is '%s'; '%s' expected.\n&quot;,
+               msg+2,provided,expected);
+		}
+ }
+ else
+  luaL_error(L,msg);
+}
+
+/* the equivalent of lua_is* for usertable */
+static  int lua_isusertable (lua_State* L, int lo, const const char* type)
+{
+	int r = 0;
+	if (lo &lt; 0) lo = lua_gettop(L)+lo+1;
+	lua_pushvalue(L,lo);
+	lua_rawget(L,LUA_REGISTRYINDEX);  /* get registry[t] */
+	if (lua_isstring(L,-1))
+	{
+		r = strcmp(lua_tostring(L,-1),type)==0;
+		if (!r)
+		{
+			/* try const */
+			lua_pushstring(L,&quot;const &quot;);
+			lua_insert(L,-2);
+			lua_concat(L,2);
+			r = lua_isstring(L,-1) &amp;&amp; strcmp(lua_tostring(L,-1),type)==0;
+		}
+	}
+	lua_pop(L, 1);
+	return r;
+}
+
+int push_table_instance(lua_State* L, int lo) {
+
+	if (lua_istable(L, lo)) {
+
+		lua_pushstring(L, &quot;.c_instance&quot;);
+		lua_gettable(L, lo);
+		if (lua_isuserdata(L, -1)) {
+
+			lua_replace(L, lo);
+			return 1;
+		} else {
+
+			lua_pop(L, 1);
+			return 0;
+		};
+	} else {
+		return 0;
+	};
+
+	return 0;
+};
+
+/* the equivalent of lua_is* for usertype */
+static int lua_isusertype (lua_State* L, int lo, const char* type)
+{
+	if (!lua_isuserdata(L,lo)) {
+		if (!push_table_instance(L, lo)) {
+			return 0;
+		};
+	};
+	{
+		/* check if it is of the same type */
+		int r;
+		const char *tn;
+		if (lua_getmetatable(L,lo))        /* if metatable? */
+		{
+		 lua_rawget(L,LUA_REGISTRYINDEX);  /* get registry[mt] */
+		 tn = lua_tostring(L,-1);
+		 r = tn &amp;&amp; (strcmp(tn,type) == 0);
+		 lua_pop(L, 1);
+			if (r)
+			 return 1;
+			else
+			{
+				/* check if it is a specialized class */
+				lua_pushstring(L,&quot;tolua_super&quot;);
+				lua_rawget(L,LUA_REGISTRYINDEX); /* get super */
+				lua_getmetatable(L,lo);
+				lua_rawget(L,-2);                /* get super[mt] */
+				if (lua_istable(L,-1))
+				{
+					int b;
+					lua_pushstring(L,type);
+					lua_rawget(L,-2);                /* get super[mt][type] */
+					b = lua_toboolean(L,-1);
+					lua_pop(L,3);
+					if (b)
+					 return 1;
+				}
+			}
+		}
+ }
+	return 0;
+}
+
+TOLUA_API int tolua_isnoobj (lua_State* L, int lo, tolua_Error* err)
+{
+ if (lua_gettop(L)&lt;abs(lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;[no object]&quot;;
+ return 0;
+}
+
+TOLUA_API int tolua_isboolean (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_isnil(L,lo) || lua_isboolean(L,lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;boolean&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_isnumber (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_isnumber(L,lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;number&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_isstring (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+ if (lua_isnil(L,lo) || lua_isstring(L,lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;string&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_istable (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_istable(L,lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;table&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_isusertable (lua_State* L, int lo, const char* type, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_isusertable(L,lo,type))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = type;
+	return 0;
+}
+
+
+TOLUA_API int tolua_isuserdata (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_isnil(L,lo) || lua_isuserdata(L,lo))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;userdata&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_isvaluenil (lua_State* L, int lo, tolua_Error* err) {
+
+	if (lua_gettop(L)&lt;abs(lo))
+		return 0; /* somebody else should chack this */
+	if (!lua_isnil(L, lo))
+		return 0;
+	
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;value&quot;;
+	return 1;
+};
+
+TOLUA_API int tolua_isvalue (lua_State* L, int lo, int def, tolua_Error* err)
+{
+	if (def || abs(lo)&lt;=lua_gettop(L))  /* any valid index */
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = &quot;value&quot;;
+	return 0;
+}
+
+TOLUA_API int tolua_isusertype (lua_State* L, int lo, const char* type, int def, tolua_Error* err)
+{
+	if (def &amp;&amp; lua_gettop(L)&lt;abs(lo))
+		return 1;
+	if (lua_isnil(L,lo) || lua_isusertype(L,lo,type))
+		return 1;
+	err-&gt;index = lo;
+	err-&gt;array = 0;
+	err-&gt;type = type;
+	return 0;
+}
+
+TOLUA_API int tolua_isvaluearray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+		return 1;
+}
+
+TOLUA_API int tolua_isbooleanarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+	  if (!(lua_isnil(L,-1) || lua_isboolean(L,-1)) &amp;&amp;
+					  !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;array = 1;
+				err-&gt;type = &quot;boolean&quot;;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+TOLUA_API int tolua_isnumberarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+			if (!lua_isnumber(L,-1) &amp;&amp;
+					  !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;array = 1;
+				err-&gt;type = &quot;number&quot;;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+TOLUA_API int tolua_isstringarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+   if (!(lua_isnil(L,-1) || lua_isstring(L,-1)) &amp;&amp;
+			    !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;array = 1;
+				err-&gt;type = &quot;string&quot;;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+TOLUA_API int tolua_istablearray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+	  if (! lua_istable(L,-1) &amp;&amp;
+			    !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;array = 1;
+				err-&gt;type = &quot;table&quot;;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+TOLUA_API int tolua_isuserdataarray
+ (lua_State* L, int lo, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+	  if (!(lua_isnil(L,-1) || lua_isuserdata(L,-1)) &amp;&amp;
+			    !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;array = 1;
+				err-&gt;type = &quot;userdata&quot;;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+TOLUA_API int tolua_isusertypearray
+ (lua_State* L, int lo, const char* type, int dim, int def, tolua_Error* err)
+{
+	if (!tolua_istable(L,lo,def,err))
+		return 0;
+	else
+	{
+		int i;
+		for (i=1; i&lt;=dim; ++i)
+		{
+			lua_pushnumber(L,i);
+			lua_gettable(L,lo);
+	  if (!(lua_isnil(L,-1) || lua_isuserdata(L,-1)) &amp;&amp;
+			    !(def &amp;&amp; lua_isnil(L,-1))
+						)
+			{
+				err-&gt;index = lo;
+				err-&gt;type = type;
+				err-&gt;array = 1;
+				return 0;
+			}
+			lua_pop(L,1);
+		}
+ }
+ return 1;
+}
+
+#if 0
+int tolua_isbooleanfield
+ (lua_State* L, int lo, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+	if (!(lua_isnil(L,-1) || lua_isboolean(L,-1)) &amp;&amp;
+			  !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = &quot;boolean&quot;;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+int tolua_isnumberfield
+ (lua_State* L, int lo, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+	if (!lua_isnumber(L,-1) &amp;&amp;
+			  !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = &quot;number&quot;;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+int tolua_isstringfield
+ (lua_State* L, int lo, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+ if (!(lua_isnil(L,-1) || lua_isstring(L,-1)) &amp;&amp;
+	    !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = &quot;string&quot;;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+int tolua_istablefield
+ (lua_State* L, int lo, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i+1);
+	lua_gettable(L,lo);
+	if (! lua_istable(L,-1) &amp;&amp;
+	    !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = &quot;table&quot;;
+		return 0;
+	}
+	lua_pop(L,1);
+}
+
+int tolua_isusertablefield
+ (lua_State* L, int lo, const char* type, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+	if (! lua_isusertable(L,-1,type) &amp;&amp;
+	    !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = type;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+int tolua_isuserdatafield
+ (lua_State* L, int lo, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+	if (!(lua_isnil(L,-1) || lua_isuserdata(L,-1)) &amp;&amp;
+	    !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;array = 1;
+		err-&gt;type = &quot;userdata&quot;;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+int tolua_isusertypefield
+ (lua_State* L, int lo, const char* type, int i, int def, tolua_Error* err)
+{
+	lua_pushnumber(L,i);
+	lua_gettable(L,lo);
+	if (!(lua_isnil(L,-1) || lua_isusertype(L,-1,type)) &amp;&amp;
+	    !(def &amp;&amp; lua_isnil(L,-1))
+				)
+	{
+		err-&gt;index = lo;
+		err-&gt;type = type;
+		err-&gt;array = 1;
+		return 0;
+	}
+	lua_pop(L,1);
+ return 1;
+}
+
+#endif

Added: trunk/netpanzer/src/Lib/toluapp/tolua_map.c
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_map.c	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_map.c	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,704 @@
+/* tolua: functions to map features
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#include &quot;tolua++.h&quot;
+#include &quot;tolua_event.h&quot;
+#include &quot;lauxlib.h&quot;
+
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+
+/* Create metatable
+	* Create and register new metatable
+*/
+static int tolua_newmetatable (lua_State* L, char* name)
+{
+	int r = luaL_newmetatable(L,name);
+
+	#ifdef LUA_VERSION_NUM /* only lua 5.1 */
+	if (r) {
+		lua_pushvalue(L, -1);
+		lua_pushstring(L, name);
+		lua_settable(L, LUA_REGISTRYINDEX); /* reg[mt] = type_name */
+	};
+	#endif
+
+	if (r)
+		tolua_classevents(L); /* set meta events */
+	lua_pop(L,1);
+	return r;
+}
+
+/* Map super classes
+	* It sets 'name' as being also a 'base', mapping all super classes of 'base' in 'name'
+*/
+static void mapsuper (lua_State* L, const char* name, const char* base)
+{
+	/* push registry.super */
+ lua_pushstring(L,&quot;tolua_super&quot;);
+ lua_rawget(L,LUA_REGISTRYINDEX);    /* stack: super */
+	luaL_getmetatable(L,name);          /* stack: super mt */
+ lua_rawget(L,-2);                   /* stack: super table */
+	if (lua_isnil(L,-1))
+	{
+	 /* create table */
+		lua_pop(L,1);
+	 lua_newtable(L);                    /* stack: super table */
+	 luaL_getmetatable(L,name);          /* stack: super table mt */
+		lua_pushvalue(L,-2);                /* stack: super table mt table */
+		lua_rawset(L,-4);                   /* stack: super table */
+	}
+
+	/* set base as super class */
+	lua_pushstring(L,base);
+	lua_pushboolean(L,1);
+	lua_rawset(L,-3);                    /* stack: super table */
+
+	/* set all super class of base as super class of name */
+	luaL_getmetatable(L,base);          /* stack: super table base_mt */
+	lua_rawget(L,-3);                   /* stack: super table base_table */
+	if (lua_istable(L,-1))
+	{
+		/* traverse base table */
+		lua_pushnil(L);  /* first key */
+		while (lua_next(L,-2) != 0)
+		{
+			/* stack: ... base_table key value */
+			lua_pushvalue(L,-2);    /* stack: ... base_table key value key */
+			lua_insert(L,-2);       /* stack: ... base_table key key value */
+			lua_rawset(L,-5);       /* stack: ... base_table key */
+		}
+	}
+	lua_pop(L,3);                       /* stack: &lt;empty&gt; */
+}
+
+/* creates a 'tolua_ubox' table for base clases, and
+// expects the metatable and base metatable on the stack */
+static void set_ubox(lua_State* L) {
+
+	/* mt basemt */
+	if (!lua_isnil(L, -1)) {
+		lua_pushstring(L, &quot;tolua_ubox&quot;);
+		lua_rawget(L,-2);
+	} else {
+		lua_pushnil(L);
+	};
+	/* mt basemt base_ubox */
+	if (!lua_isnil(L,-1)) {
+		lua_pushstring(L, &quot;tolua_ubox&quot;);
+		lua_insert(L, -2);
+		/* mt basemt key ubox */
+		lua_rawset(L,-4);
+		/* (mt with ubox) basemt */
+	} else {
+		/* mt basemt nil */
+		lua_pop(L, 1);
+		lua_pushstring(L,&quot;tolua_ubox&quot;); lua_newtable(L);
+		/* make weak value metatable for ubox table to allow userdata to be
+		garbage-collected */
+		lua_newtable(L); lua_pushliteral(L, &quot;__mode&quot;); lua_pushliteral(L, &quot;v&quot;); lua_rawset(L, -3);               /* stack: string ubox mt */
+		lua_setmetatable(L, -2);  /* stack:mt basemt string ubox */
+		lua_rawset(L,-4);
+	};
+
+};
+
+/* Map inheritance
+	* It sets 'name' as derived from 'base' by setting 'base' as metatable of 'name'
+*/
+static void mapinheritance (lua_State* L, const char* name, const char* base)
+{
+	/* set metatable inheritance */
+	luaL_getmetatable(L,name);
+
+	if (base &amp;&amp; *base)
+		luaL_getmetatable(L,base);
+	else {
+
+		if (lua_getmetatable(L, -1)) { /* already has a mt, we don't overwrite it */
+			lua_pop(L, 2);
+			return;
+		};
+		luaL_getmetatable(L,&quot;tolua_commonclass&quot;);
+	};
+
+	set_ubox(L);
+
+	lua_setmetatable(L,-2);
+	lua_pop(L,1);
+}
+
+/* Object type
+*/
+static int tolua_bnd_type (lua_State* L)
+{
+	tolua_typename(L,lua_gettop(L));
+	return 1;
+}
+
+/* Take ownership
+*/
+static int tolua_bnd_takeownership (lua_State* L)
+{
+	int success = 0;
+	if (lua_isuserdata(L,1))
+	{
+		if (lua_getmetatable(L,1))        /* if metatable? */
+		{
+			lua_pop(L,1);             /* clear metatable off stack */
+			/* force garbage collection to avoid C to reuse a to-be-collected address */
+			#ifdef LUA_VERSION_NUM
+			lua_gc(L, LUA_GCCOLLECT, 0);
+			#else
+			lua_setgcthreshold(L,0);
+			#endif
+
+			success = tolua_register_gc(L,1);
+		}
+	}
+	lua_pushboolean(L,success!=0);
+	return 1;
+}
+
+/* Release ownership
+*/
+static int tolua_bnd_releaseownership (lua_State* L)
+{
+	int done = 0;
+	if (lua_isuserdata(L,1))
+	{
+		void* u = *((void**)lua_touserdata(L,1));
+		/* force garbage collection to avoid releasing a to-be-collected address */
+		#ifdef LUA_VERSION_NUM
+		lua_gc(L, LUA_GCCOLLECT, 0);
+		#else
+		lua_setgcthreshold(L,0);
+		#endif
+		lua_pushstring(L,&quot;tolua_gc&quot;);
+		lua_rawget(L,LUA_REGISTRYINDEX);
+		lua_pushlightuserdata(L,u);
+		lua_rawget(L,-2);
+		lua_getmetatable(L,1);
+		if (lua_rawequal(L,-1,-2))  /* check that we are releasing the correct type */
+		{
+			lua_pushlightuserdata(L,u);
+			lua_pushnil(L);
+			lua_rawset(L,-5);
+			done = 1;
+		}
+	}
+	lua_pushboolean(L,done!=0);
+	return 1;
+}
+
+/* Type casting
+*/
+static int tolua_bnd_cast (lua_State* L)
+{
+
+/* // old code
+        void* v = tolua_tousertype(L,1,NULL);
+        const char* s = tolua_tostring(L,2,NULL);
+        if (v &amp;&amp; s)
+         tolua_pushusertype(L,v,s);
+        else
+         lua_pushnil(L);
+        return 1;
+*/
+
+	void* v;
+	const char* s;
+	if (lua_islightuserdata(L, 1)) {
+		v = tolua_touserdata(L, 1, NULL);
+	} else {
+		v = tolua_tousertype(L, 1, 0);
+	};
+
+	s = tolua_tostring(L,2,NULL);
+	if (v &amp;&amp; s)
+	 tolua_pushusertype(L,v,s);
+	else
+	 lua_pushnil(L);
+	return 1;
+}
+
+/* Inheritance
+*/
+static int tolua_bnd_inherit (lua_State* L) {
+
+	/* stack: lua object, c object */
+	lua_pushstring(L, &quot;.c_instance&quot;);
+	lua_pushvalue(L, -2);
+	lua_rawset(L, -4);
+	/* l_obj[&quot;.c_instance&quot;] = c_obj */
+
+	return 0;
+};
+
+#ifdef LUA_VERSION_NUM /* lua 5.1 */
+static int tolua_bnd_setpeer(lua_State* L) {
+
+	/* stack: userdata, table */
+	if (!lua_isuserdata(L, -2)) {
+		lua_pushstring(L, &quot;Invalid argument #1 to setpeer: userdata expected.&quot;);
+		lua_error(L);
+	};
+	
+	if (lua_isnil(L, -1)) {
+
+		lua_pop(L, 1);
+		lua_pushvalue(L, TOLUA_NOPEER);
+	};
+	lua_setfenv(L, -2);
+
+	return 0;
+};
+
+static int tolua_bnd_getpeer(lua_State* L) {
+
+	/* stack: userdata */
+	lua_getfenv(L, -1);
+	if (lua_rawequal(L, -1, TOLUA_NOPEER)) {
+		lua_pop(L, 1);
+		lua_pushnil(L);
+	};
+	return 1;
+};
+#endif
+
+/* static int class_gc_event (lua_State* L); */
+
+TOLUA_API void tolua_open (lua_State* L)
+{
+ int top = lua_gettop(L);
+ lua_pushstring(L,&quot;tolua_opened&quot;);
+ lua_rawget(L,LUA_REGISTRYINDEX);
+ if (!lua_isboolean(L,-1))
+ {
+  lua_pushstring(L,&quot;tolua_opened&quot;); lua_pushboolean(L,1); lua_rawset(L,LUA_REGISTRYINDEX);
+
+  #ifndef LUA_VERSION_NUM /* only prior to lua 5.1 */
+  /* create peer object table */
+  lua_pushstring(L, &quot;tolua_peers&quot;); lua_newtable(L);
+  /* make weak key metatable for peers indexed by userdata object */
+  lua_newtable(L); lua_pushliteral(L, &quot;__mode&quot;); lua_pushliteral(L, &quot;k&quot;); lua_rawset(L, -3);                /* stack: string peers mt */
+  lua_setmetatable(L, -2);   /* stack: string peers */
+  lua_rawset(L,LUA_REGISTRYINDEX);
+  #endif
+
+  /* create object ptr -&gt; udata mapping table */
+  lua_pushstring(L,&quot;tolua_ubox&quot;); lua_newtable(L);
+  /* make weak value metatable for ubox table to allow userdata to be
+     garbage-collected */
+  lua_newtable(L); lua_pushliteral(L, &quot;__mode&quot;); lua_pushliteral(L, &quot;v&quot;); lua_rawset(L, -3);               /* stack: string ubox mt */
+  lua_setmetatable(L, -2);  /* stack: string ubox */
+  lua_rawset(L,LUA_REGISTRYINDEX);
+
+  lua_pushstring(L,&quot;tolua_super&quot;); lua_newtable(L); lua_rawset(L,LUA_REGISTRYINDEX);
+  lua_pushstring(L,&quot;tolua_gc&quot;); lua_newtable(L);lua_rawset(L,LUA_REGISTRYINDEX);
+
+  /* create gc_event closure */
+  lua_pushstring(L, &quot;tolua_gc_event&quot;);
+  lua_pushstring(L, &quot;tolua_gc&quot;);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushstring(L, &quot;tolua_super&quot;);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushcclosure(L, class_gc_event, 2);
+  lua_rawset(L, LUA_REGISTRYINDEX);
+
+  tolua_newmetatable(L,&quot;tolua_commonclass&quot;);
+
+  tolua_module(L,NULL,0);
+  tolua_beginmodule(L,NULL);
+  tolua_module(L,&quot;tolua&quot;,0);
+  tolua_beginmodule(L,&quot;tolua&quot;);
+  tolua_function(L,&quot;type&quot;,tolua_bnd_type);
+  tolua_function(L,&quot;takeownership&quot;,tolua_bnd_takeownership);
+  tolua_function(L,&quot;releaseownership&quot;,tolua_bnd_releaseownership);
+  tolua_function(L,&quot;cast&quot;,tolua_bnd_cast);
+  tolua_function(L,&quot;inherit&quot;, tolua_bnd_inherit);
+  #ifdef LUA_VERSION_NUM /* lua 5.1 */
+  tolua_function(L, &quot;setpeer&quot;, tolua_bnd_setpeer);
+  tolua_function(L, &quot;getpeer&quot;, tolua_bnd_getpeer);
+  #endif
+
+  tolua_endmodule(L);
+  tolua_endmodule(L);
+ }
+ lua_settop(L,top);
+}
+
+/* Copy a C object
+*/
+TOLUA_API void* tolua_copy (lua_State* L, void* value, unsigned int size)
+{
+	void* clone = (void*)malloc(size);
+	if (clone)
+	 memcpy(clone,value,size);
+	else
+		tolua_error(L,&quot;insuficient memory&quot;,NULL);
+	return clone;
+}
+
+/* Default collect function
+*/
+TOLUA_API int tolua_default_collect (lua_State* tolua_S)
+{
+ void* self = tolua_tousertype(tolua_S,1,0);
+ free(self);
+ return 0;
+}
+
+/* Do clone
+*/
+TOLUA_API int tolua_register_gc (lua_State* L, int lo)
+{
+ int success = 1;
+ void *value = *(void **)lua_touserdata(L,lo);
+ lua_pushstring(L,&quot;tolua_gc&quot;);
+ lua_rawget(L,LUA_REGISTRYINDEX);
+	lua_pushlightuserdata(L,value);
+	lua_rawget(L,-2);
+	if (!lua_isnil(L,-1)) /* make sure that object is not already owned */
+		success = 0;
+	else
+	{
+		lua_pushlightuserdata(L,value);
+		lua_getmetatable(L,lo);
+		lua_rawset(L,-4);
+	}
+	lua_pop(L,2);
+	return success;
+}
+
+/* Register a usertype
+	* It creates the correspoding metatable in the registry, for both 'type' and 'const type'.
+	* It maps 'const type' as being also a 'type'
+*/
+TOLUA_API void tolua_usertype (lua_State* L, const char* type)
+{
+ char ctype[128] = &quot;const &quot;;
+ strncat(ctype,type,120);
+
+	/* create both metatables */
+ if (tolua_newmetatable(L,ctype) &amp;&amp; tolua_newmetatable(L,type))
+	 mapsuper(L,type,ctype);             /* 'type' is also a 'const type' */
+}
+
+
+/* Begin module
+	* It pushes the module (or class) table on the stack
+*/
+TOLUA_API void tolua_beginmodule (lua_State* L, const char* name)
+{
+	if (name)
+	{
+	 lua_pushstring(L,name);
+		lua_rawget(L,-2);
+	}
+	else
+	 lua_pushvalue(L,LUA_GLOBALSINDEX);
+}
+
+/* End module
+	* It pops the module (or class) from the stack
+*/
+TOLUA_API void tolua_endmodule (lua_State* L)
+{
+	lua_pop(L,1);
+}
+
+/* Map module
+	* It creates a new module
+*/
+#if 1
+TOLUA_API void tolua_module (lua_State* L, const char* name, int hasvar)
+{
+	if (name)
+	{
+		/* tolua module */
+		lua_pushstring(L,name);
+		lua_rawget(L,-2);
+		if (!lua_istable(L,-1))  /* check if module already exists */
+		{
+			lua_pop(L,1);
+		 lua_newtable(L);
+		 lua_pushstring(L,name);
+			lua_pushvalue(L,-2);
+		 lua_rawset(L,-4);       /* assing module into module */
+		}
+	}
+	else
+	{
+		/* global table */
+		lua_pushvalue(L,LUA_GLOBALSINDEX);
+	}
+	if (hasvar)
+	{
+		if (!tolua_ismodulemetatable(L))  /* check if it already has a module metatable */
+		{
+			/* create metatable to get/set C/C++ variable */
+			lua_newtable(L);
+			tolua_moduleevents(L);
+			if (lua_getmetatable(L,-2))
+				lua_setmetatable(L,-2);  /* set old metatable as metatable of metatable */
+			lua_setmetatable(L,-2);
+		}
+	}
+	lua_pop(L,1);               /* pop module */
+}
+#else
+TOLUA_API void tolua_module (lua_State* L, const char* name, int hasvar)
+{
+	if (name)
+	{
+		/* tolua module */
+		lua_pushstring(L,name);
+		lua_newtable(L);
+	}
+	else
+	{
+		/* global table */
+		lua_pushvalue(L,LUA_GLOBALSINDEX);
+	}
+	if (hasvar)
+	{
+		/* create metatable to get/set C/C++ variable */
+		lua_newtable(L);
+		tolua_moduleevents(L);
+		if (lua_getmetatable(L,-2))
+			lua_setmetatable(L,-2);  /* set old metatable as metatable of metatable */
+		lua_setmetatable(L,-2);
+	}
+	if (name)
+		lua_rawset(L,-3);       /* assing module into module */
+	else
+		lua_pop(L,1);           /* pop global table */
+}
+#endif
+
+static void push_collector(lua_State* L, const char* type, lua_CFunction col) {
+
+	/* push collector function, but only if it's not NULL, or if there's no
+	   collector already */
+	if (!col) return;
+	luaL_getmetatable(L,type);
+	lua_pushstring(L,&quot;.collector&quot;);
+	/*
+	if (!col) {
+		lua_pushvalue(L, -1);
+		lua_rawget(L, -3);
+		if (!lua_isnil(L, -1)) {
+			lua_pop(L, 3);
+			return;
+		};
+		lua_pop(L, 1);
+	};
+	//	*/
+	lua_pushcfunction(L,col);
+
+	lua_rawset(L,-3);
+	lua_pop(L, 1);
+};
+
+/* Map C class
+	* It maps a C class, setting the appropriate inheritance and super classes.
+*/
+TOLUA_API void tolua_cclass (lua_State* L, const char* lname, const char* name, const char* base, lua_CFunction col)
+{
+	char cname[128] = &quot;const &quot;;
+	char cbase[128] = &quot;const &quot;;
+	strncat(cname,name,120);
+	strncat(cbase,base,120);
+
+	mapinheritance(L,name,base);
+	mapinheritance(L,cname,name);
+
+	mapsuper(L,cname,cbase);
+	mapsuper(L,name,base);
+
+	lua_pushstring(L,lname);
+	
+	push_collector(L, name, col);
+	/*
+	luaL_getmetatable(L,name);
+	lua_pushstring(L,&quot;.collector&quot;);
+	lua_pushcfunction(L,col);
+
+	lua_rawset(L,-3);
+	*/
+	
+	luaL_getmetatable(L,name);
+	lua_rawset(L,-3);              /* assign class metatable to module */
+
+	/* now we also need to store the collector table for the const
+	   instances of the class */
+	push_collector(L, cname, col);
+	/*
+	luaL_getmetatable(L,cname);
+	lua_pushstring(L,&quot;.collector&quot;);
+	lua_pushcfunction(L,col);
+	lua_rawset(L,-3);
+	lua_pop(L,1);
+	*/
+	
+
+}
+
+/* Add base
+	* It adds additional base classes to a class (for multiple inheritance)
+	* (not for now)
+TOLUA_API void tolua_addbase(lua_State* L, char* name, char* base) {
+
+	char cname[128] = &quot;const &quot;;
+	char cbase[128] = &quot;const &quot;;
+	strncat(cname,name,120);
+	strncat(cbase,base,120);
+
+	mapsuper(L,cname,cbase);
+	mapsuper(L,name,base);
+};
+*/
+
+/* Map function
+	* It assigns a function into the current module (or class)
+*/
+TOLUA_API void tolua_function (lua_State* L, const char* name, lua_CFunction func)
+{
+ lua_pushstring(L,name);
+ lua_pushcfunction(L,func);
+	lua_rawset(L,-3);
+}
+
+/* sets the __call event for the class (expects the class' main table on top) */
+/*	never really worked :(
+TOLUA_API void tolua_set_call_event(lua_State* L, lua_CFunction func, char* type) {
+
+	lua_getmetatable(L, -1);
+	//luaL_getmetatable(L, type);
+	lua_pushstring(L,&quot;__call&quot;);
+	lua_pushcfunction(L,func);
+	lua_rawset(L,-3);
+	lua_pop(L, 1);
+};
+*/
+
+/* Map constant number
+	* It assigns a constant number into the current module (or class)
+*/
+TOLUA_API void tolua_constant (lua_State* L, const char* name, lua_Number value)
+{
+	lua_pushstring(L,name);
+	tolua_pushnumber(L,value);
+	lua_rawset(L,-3);
+}
+
+
+/* Map variable
+	* It assigns a variable into the current module (or class)
+*/
+TOLUA_API void tolua_variable (lua_State* L, const char* name, lua_CFunction get, lua_CFunction set)
+{
+	/* get func */
+	lua_pushstring(L,&quot;.get&quot;);
+	lua_rawget(L,-2);
+	if (!lua_istable(L,-1))
+	{
+		/* create .get table, leaving it at the top */
+		lua_pop(L,1);
+		lua_newtable(L);
+	 lua_pushstring(L,&quot;.get&quot;);
+		lua_pushvalue(L,-2);
+		lua_rawset(L,-4);
+	}
+	lua_pushstring(L,name);
+	lua_pushcfunction(L,get);
+ lua_rawset(L,-3);                  /* store variable */
+	lua_pop(L,1);                      /* pop .get table */
+
+	/* set func */
+	if (set)
+	{
+		lua_pushstring(L,&quot;.set&quot;);
+		lua_rawget(L,-2);
+		if (!lua_istable(L,-1))
+		{
+			/* create .set table, leaving it at the top */
+			lua_pop(L,1);
+			lua_newtable(L);
+			lua_pushstring(L,&quot;.set&quot;);
+			lua_pushvalue(L,-2);
+			lua_rawset(L,-4);
+		}
+		lua_pushstring(L,name);
+		lua_pushcfunction(L,set);
+		lua_rawset(L,-3);                  /* store variable */
+		lua_pop(L,1);                      /* pop .set table */
+	}
+}
+
+/* Access const array
+	* It reports an error when trying to write into a const array
+*/
+static int const_array (lua_State* L)
+{
+ luaL_error(L,&quot;value of const array cannot be changed&quot;);
+ return 0;
+}
+
+/* Map an array
+	* It assigns an array into the current module (or class)
+*/
+TOLUA_API void tolua_array (lua_State* L, const char* name, lua_CFunction get, lua_CFunction set)
+{
+	lua_pushstring(L,&quot;.get&quot;);
+	lua_rawget(L,-2);
+	if (!lua_istable(L,-1))
+	{
+		/* create .get table, leaving it at the top */
+		lua_pop(L,1);
+		lua_newtable(L);
+	 lua_pushstring(L,&quot;.get&quot;);
+		lua_pushvalue(L,-2);
+		lua_rawset(L,-4);
+	}
+	lua_pushstring(L,name);
+
+ lua_newtable(L);           /* create array metatable */
+ lua_pushvalue(L,-1);
+	lua_setmetatable(L,-2);    /* set the own table as metatable (for modules) */
+ lua_pushstring(L,&quot;__index&quot;);
+ lua_pushcfunction(L,get);
+	lua_rawset(L,-3);
+ lua_pushstring(L,&quot;__newindex&quot;);
+ lua_pushcfunction(L,set?set:const_array);
+	lua_rawset(L,-3);
+
+ lua_rawset(L,-3);                  /* store variable */
+	lua_pop(L,1);                      /* pop .get table */
+}
+
+
+TOLUA_API void tolua_dobuffer(lua_State* L, char* B, unsigned int size, const char* name) {
+
+ #ifdef LUA_VERSION_NUM /* lua 5.1 */
+ luaL_loadbuffer(L, B, size, name) || lua_pcall(L, 0, 0, 0);
+ #else
+ lua_dobuffer(L, B, size, name);
+ #endif
+};
+

Added: trunk/netpanzer/src/Lib/toluapp/tolua_push.c
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_push.c	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_push.c	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,171 @@
+/* tolua: functions to push C values.
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#include &quot;tolua++.h&quot;
+#include &quot;lauxlib.h&quot;
+
+#include &lt;stdlib.h&gt;
+
+TOLUA_API void tolua_pushvalue (lua_State* L, int lo)
+{
+ lua_pushvalue(L,lo);
+}
+
+TOLUA_API void tolua_pushboolean (lua_State* L, int value)
+{
+ lua_pushboolean(L,value);
+}
+
+TOLUA_API void tolua_pushnumber (lua_State* L, lua_Number value)
+{
+ lua_pushnumber(L,value);
+}
+
+TOLUA_API void tolua_pushstring (lua_State* L, const char* value)
+{
+ if (value == NULL)
+  lua_pushnil(L);
+ else
+  lua_pushstring(L,value);
+}
+
+TOLUA_API void tolua_pushuserdata (lua_State* L, void* value)
+{
+ if (value == NULL)
+  lua_pushnil(L);
+ else
+  lua_pushlightuserdata(L,value);
+}
+
+TOLUA_API void tolua_pushusertype (lua_State* L, void* value, const char* type)
+{
+ if (value == NULL)
+  lua_pushnil(L);
+ else
+ {
+  luaL_getmetatable(L, type);
+  lua_pushstring(L,&quot;tolua_ubox&quot;);
+  lua_rawget(L,-2);        /* stack: mt ubox */
+  if (lua_isnil(L, -1)) {
+	  lua_pop(L, 1);
+	  lua_pushstring(L, &quot;tolua_ubox&quot;);
+	  lua_rawget(L, LUA_REGISTRYINDEX);
+  };
+  lua_pushlightuserdata(L,value);
+  lua_rawget(L,-2);                       /* stack: mt ubox ubox[u] */
+  if (lua_isnil(L,-1))
+  {
+   lua_pop(L,1);                          /* stack: mt ubox */
+   lua_pushlightuserdata(L,value);
+   *(void**)lua_newuserdata(L,sizeof(void *)) = value;   /* stack: mt ubox u newud */
+   lua_pushvalue(L,-1);                   /* stack: mt ubox u newud newud */
+   lua_insert(L,-4);                      /* stack: mt newud ubox u newud */
+   lua_rawset(L,-3);                      /* stack: mt newud ubox */
+   lua_pop(L,1);                          /* stack: mt newud */
+   /*luaL_getmetatable(L,type);*/
+   lua_pushvalue(L, -2);			/* stack: mt newud mt */
+   lua_setmetatable(L,-2);			/* stack: mt newud */
+
+   #ifdef LUA_VERSION_NUM
+   lua_pushvalue(L, TOLUA_NOPEER);
+   lua_setfenv(L, -2);
+   #endif
+  }
+  else
+  {
+   /* check the need of updating the metatable to a more specialized class */
+   lua_insert(L,-2);                       /* stack: mt ubox[u] ubox */
+   lua_pop(L,1);                           /* stack: mt ubox[u] */
+   lua_pushstring(L,&quot;tolua_super&quot;);
+   lua_rawget(L,LUA_REGISTRYINDEX);        /* stack: mt ubox[u] super */
+   lua_getmetatable(L,-2);                 /* stack: mt ubox[u] super mt */
+   lua_rawget(L,-2);                       /* stack: mt ubox[u] super super[mt] */
+			if (lua_istable(L,-1))
+			{
+				lua_pushstring(L,type);                 /* stack: mt ubox[u] super super[mt] type */
+				lua_rawget(L,-2);                       /* stack: mt ubox[u] super super[mt] flag */
+				if (lua_toboolean(L,-1) == 1)   /* if true */
+				{
+					lua_pop(L,3);	/* mt ubox[u]*/
+					lua_remove(L, -2);
+					return;
+				}
+			}
+			/* type represents a more specilized type */
+			/*luaL_getmetatable(L,type);             // stack: mt ubox[u] super super[mt] flag mt */
+			lua_pushvalue(L, -5);					/* stack: mt ubox[u] super super[mt] flag mt */
+			lua_setmetatable(L,-5);                /* stack: mt ubox[u] super super[mt] flag */
+			lua_pop(L,3);                          /* stack: mt ubox[u] */
+  }
+  lua_remove(L, -2);	/* stack: ubox[u]*/
+ }
+}
+
+TOLUA_API void tolua_pushusertype_and_takeownership (lua_State* L, void* value, const char* type)
+{
+	tolua_pushusertype(L,value,type);
+	tolua_register_gc(L,lua_gettop(L));
+}
+
+TOLUA_API void tolua_pushfieldvalue (lua_State* L, int lo, int index, int v)
+{
+ lua_pushnumber(L,index);
+ lua_pushvalue(L,v);
+ lua_settable(L,lo);
+}
+
+TOLUA_API void tolua_pushfieldboolean (lua_State* L, int lo, int index, int v)
+{
+ lua_pushnumber(L,index);
+ lua_pushboolean(L,v);
+ lua_settable(L,lo);
+}
+
+
+TOLUA_API void tolua_pushfieldnumber (lua_State* L, int lo, int index, lua_Number v)
+{
+ lua_pushnumber(L,index);
+ tolua_pushnumber(L,v);
+ lua_settable(L,lo);
+}
+
+TOLUA_API void tolua_pushfieldstring (lua_State* L, int lo, int index, const char* v)
+{
+ lua_pushnumber(L,index);
+ tolua_pushstring(L,v);
+ lua_settable(L,lo);
+}
+
+TOLUA_API void tolua_pushfielduserdata (lua_State* L, int lo, int index, void* v)
+{
+ lua_pushnumber(L,index);
+ tolua_pushuserdata(L,v);
+ lua_settable(L,lo);
+}
+
+TOLUA_API void tolua_pushfieldusertype (lua_State* L, int lo, int index, void* v, const char* type)
+{
+ lua_pushnumber(L,index);
+ tolua_pushusertype(L,v,type);
+ lua_settable(L,lo);
+}
+
+TOLUA_API void tolua_pushfieldusertype_and_takeownership (lua_State* L, int lo, int index, void* v, const char* type)
+{
+ lua_pushnumber(L,index);
+ tolua_pushusertype(L,v,type);
+	tolua_register_gc(L,lua_gettop(L));
+ lua_settable(L,lo);
+}
+

Added: trunk/netpanzer/src/Lib/toluapp/tolua_to.c
===================================================================
--- trunk/netpanzer/src/Lib/toluapp/tolua_to.c	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/Lib/toluapp/tolua_to.c	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,133 @@
+/* tolua: funcitons to convert to C types
+** Support code for Lua bindings.
+** Written by Waldemar Celes
+** TeCGraf/PUC-Rio
+** Apr 2003
+** $Id: $
+*/
+
+/* This code is free software; you can redistribute it and/or modify it.
+** The software provided hereunder is on an &quot;as is&quot; basis, and
+** the author has no obligation to provide maintenance, support, updates,
+** enhancements, or modifications.
+*/
+
+#include &quot;tolua++.h&quot;
+
+#include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
+
+TOLUA_API lua_Number tolua_tonumber (lua_State* L, int narg, lua_Number def)
+{
+ return lua_gettop(L)&lt;abs(narg) ? def : lua_tonumber(L,narg);
+}
+
+TOLUA_API const char* tolua_tostring (lua_State* L, int narg, const char* def)
+{
+ return lua_gettop(L)&lt;abs(narg) ? def : lua_tostring(L,narg);
+}
+
+TOLUA_API void* tolua_touserdata (lua_State* L, int narg, void* def)
+{
+	
+	/* return lua_gettop(L)&lt;abs(narg) ? def : lua_touserdata(L,narg); */
+
+	if (lua_gettop(L)&lt;abs(narg)) {
+ 		return def;
+	};
+	 
+	if (lua_islightuserdata(L, narg)) {
+	
+		return lua_touserdata(L,narg);
+	};
+	
+	return tolua_tousertype(L, narg, def);
+}
+
+extern int push_table_instance(lua_State* L, int lo);
+
+TOLUA_API void* tolua_tousertype (lua_State* L, int narg, void* def)
+{
+ if (lua_gettop(L)&lt;abs(narg))
+  return def;
+ else
+ {
+  void* u;
+  if (!lua_isuserdata(L, narg)) {
+	  if (!push_table_instance(L, narg)) return NULL;
+  };
+  u = lua_touserdata(L,narg);
+  return (u==NULL) ? NULL : *((void**)u); /* nil represents NULL */
+ }
+}
+
+TOLUA_API int tolua_tovalue (lua_State* L, int narg, int def)
+{
+ return lua_gettop(L)&lt;abs(narg) ? def : narg;
+}
+
+TOLUA_API int tolua_toboolean (lua_State* L, int narg, int def)
+{
+ return lua_gettop(L)&lt;abs(narg) ?  def : lua_toboolean(L,narg);
+}
+
+TOLUA_API lua_Number tolua_tofieldnumber (lua_State* L, int lo, int index, lua_Number def)
+{
+ double v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? def : lua_tonumber(L,-1);
+ lua_pop(L,1);
+ return v;
+}
+
+TOLUA_API const char* tolua_tofieldstring
+(lua_State* L, int lo, int index, const char* def)
+{
+ const char* v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? def : lua_tostring(L,-1);
+ lua_pop(L,1);
+ return v;
+}
+
+TOLUA_API void* tolua_tofielduserdata (lua_State* L, int lo, int index, void* def)
+{
+ void* v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? def : lua_touserdata(L,-1);
+ lua_pop(L,1);
+ return v;
+}
+
+TOLUA_API void* tolua_tofieldusertype (lua_State* L, int lo, int index, void* def)
+{
+ void* v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? def : (*(void **)(lua_touserdata(L, -1))); /* lua_unboxpointer(L,-1); */
+ lua_pop(L,1);
+ return v;
+}
+
+TOLUA_API int tolua_tofieldvalue (lua_State* L, int lo, int index, int def)
+{
+ int v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? def : lo;
+ lua_pop(L,1);
+ return v;
+}
+
+TOLUA_API int tolua_getfieldboolean (lua_State* L, int lo, int index, int def)
+{
+ int v;
+ lua_pushnumber(L,index);
+ lua_gettable(L,lo);
+ v = lua_isnil(L,-1) ? 0 : lua_toboolean(L,-1);
+ lua_pop(L,1);
+ return v;
+}

Modified: trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -448,7 +448,23 @@
     char chat_string[256];
     if (getConsoleInputString(chat_string)) {
         if(strcmp(chat_string, &quot;&quot;) != 0)
+        {
+            lua_State *L = ScriptManager::getLuavm();
+            lua_getglobal(L, &quot;onUserMessage&quot;);
+            if ( lua_isfunction(L, -1) )
+            {
+                lua_pushstring(L, chat_string);
+                if ( lua_pcall(L, 1, 0, 0) != 0 )
+                {
+                    LOGGER.warning(&quot;error running function `onChatMessageEntered': %s\n&quot;,lua_tostring(L, -1));
+                }
+            }
+            else
+            {
+                lua_pop(L, 1);
+            }
             ChatInterface::sendCurrentMessage( chat_string );
+        }
         keyboard_input_mode = _keyboard_input_mode_command;
         ConsoleInterface::setInputStringStatus(false);             
     }
@@ -607,8 +623,8 @@
     {
         if ( (!selection_box_active)
              &amp;&amp; ( manual_fire_state == true
-                 || KeyboardInterface::getKeyState( SDLK_LCTRL )
-                 || KeyboardInterface::getKeyState( SDLK_RCTRL )
+//                 || KeyboardInterface::getKeyState( SDLK_LCTRL )
+//                 || KeyboardInterface::getKeyState( SDLK_RCTRL )
                 )
            )
         {
@@ -740,8 +756,8 @@
 
             case _cursor_enemy_unit:
                  if ( manual_fire_state != true
-                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_LCTRL )
-                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_RCTRL )
+//                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_LCTRL )
+//                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_RCTRL )
                      )
                  {
                      sendAttackCommand(world_pos);

Modified: trunk/netpanzer/src/NetPanzer/Core/main.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/main.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Core/main.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -280,13 +280,8 @@
 int netpanzer_main(int argc, char** argv)
 {
     ScriptManager::initialize();
-    
-    ScriptManager::runStr(&quot;LuaInitialize&quot;,&quot;print('Lua is working just fine');&quot;);
 
-    Palette::registerScript(); // here for the moment;
-
     global_engine_state = new GlobalEngineState();
-
     global_engine_state-&gt;game_manager = initialise(argc, argv);
 
     ScriptManager::runFile(&quot;unused&quot;,&quot;scripts/initialize.lua&quot;);

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/ConsoleInterface.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -24,6 +24,7 @@
 #include &quot;Core/CoreTypes.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
 #include &quot;2D/Surface.hpp&quot;
+#include &quot;Util/Log.hpp&quot;
 
 
 class ConsoleLine
@@ -77,6 +78,11 @@
     static void postMessage( IntColor msgColor, bool hasFlag, FlagID flag, const char *format, ... )
         __attribute__(( format(printf, 4, 5) ));
 
+    static void post( IntColor msgColor, bool hasFlag, FlagID flag, const char *msg )
+    {
+        postMessage( msgColor, hasFlag ,flag, &quot;%s&quot;, msg);
+    }
+
     /* Input String Methods */
     static void setInputStringStatus( bool on_off );
     static void resetInputString( char *prompt );

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -327,7 +327,6 @@
 //    GameControlRulesDaemon::setStateServerInProgress();
     GameControlRulesDaemon::setStateServerLoadingMap();
     NetworkState::setNetworkStatus( _network_state_server );
-
 }
 
 void PlayerGameManager::quitGame()

Deleted: trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -1,115 +0,0 @@
-/*
-Copyright (C) 2008 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
- * Created on October 8, 2008, 10:53 PM
- */
-
-#include &quot;ScriptHelper.hpp&quot;
-#include &quot;Util/Log.hpp&quot;
-
-int
-ScriptHelper::get_byte (lua_State *L, void *v)
-{
-    lua_pushnumber(L, *(unsigned char*)v);
-    return 1;
-}
-
-int
-ScriptHelper::set_byte (lua_State *L, void *v)
-{
-    *(unsigned char*)v = luaL_checkint(L, 3);
-    return 0;
-}
-
-int
-ScriptHelper::get_int (lua_State *L, void *v)
-{
-    lua_pushnumber(L, *(int*)v);
-    return 1;
-}
-
-int
-ScriptHelper::set_int (lua_State *L, void *v)
-{
-    *(int*)v = luaL_checkint(L, 3);
-    return 0;
-}
-
-int
-ScriptHelper::get_number (lua_State *L, void *v)
-{
-    lua_pushnumber(L, *(lua_Number*)v);
-    return 1;
-}
-
-int
-ScriptHelper::set_number (lua_State *L, void *v)
-{
-    *(lua_Number*)v = luaL_checknumber(L, 3);
-    return 0;
-}
-
-int
-ScriptHelper::get_string (lua_State *L, void *v)
-{
-    lua_pushstring(L, (char*)v );
-    return 1;
-}
-    
-int
-ScriptHelper::staticVarCall(lua_State *L)
-{
-    /* for get: stack has userdata, index, lightuserdata */
-    /* for set: stack has userdata, index, value, lightuserdata */
-    ScriptVarBindRecord * m = (ScriptVarBindRecord *)lua_touserdata(L, -1);  /* member info */
-    lua_pop(L, 1);                               /* drop lightuserdata */
-    luaL_checktype(L, 1, LUA_TUSERDATA);
-    return m-&gt;func(L, (void *)(m-&gt;data));
-}
-
-int
-ScriptHelper::index_handler (lua_State *L)
-{
-    /* stack has userdata, index */
-    lua_pushvalue(L, 2);                     /* dup index */
-    lua_rawget(L, lua_upvalueindex(1));      /* lookup member by name */
-    if (!lua_islightuserdata(L, -1))
-    {
-        lua_pop(L, 1);                         /* drop value */
-        lua_pushvalue(L, 2);                   /* dup index */
-        lua_gettable(L, lua_upvalueindex(2));  /* else try methods */
-        if (lua_isnil(L, -1))                  /* invalid member */
-        {
-            luaL_error(L, &quot;cannot get member '%s'&quot;, lua_tostring(L, 2));
-        }
-        return 1;
-    }
-    return staticVarCall(L);                      /* call get function */
-}
-
-int
-ScriptHelper::newindex_handler (lua_State *L)
-{
-    /* stack has userdata, index, value */
-    lua_pushvalue(L, 2);                     /* dup index */
-    lua_rawget(L, lua_upvalueindex(1));      /* lookup member by name */
-    if (!lua_islightuserdata(L, -1))         /* invalid member */
-    {
-        luaL_error(L, &quot;cannot set member '%s'&quot;, lua_tostring(L, 2));
-    }
-    return staticVarCall(L);                      /* call set function */
-}

Deleted: trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/ScriptHelper.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -1,68 +0,0 @@
-/*
-Copyright (C) 2008 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
- * Created on October 8, 2008, 10:48 PM
- */
-
-#ifndef _SCRIPTHELPER_HPP
-#define	_SCRIPTHELPER_HPP
-
-#include &quot;lua/lua.hpp&quot;
-
-#define GETSVTYPE_BYTE ScriptHelper::get_byte
-#define SETSVTYPE_BYTE ScriptHelper::set_byte
-#define GETSVTYPE_INT ScriptHelper::get_int
-#define SETSVTYPE_INT ScriptHelper::set_int
-#define GETSVTYPE_NUMBER ScriptHelper::get_number
-#define SETSVTYPE_NUMBER ScriptHelper::set_number
-#define GETSVTYPE_STRING ScriptHelper::get_string
-//#define SETSVTYPE_STRING ScriptHelper::set_string
-
-typedef int (*ScriptBindFunction) (lua_State *L, void *v);
-
-/* member info for get and set handlers */
-typedef const struct s_ScriptVarBindRecord
-{
-    const char *name;        /* var name */
-    ScriptBindFunction func; /* get or set function for type of data */
-    void * data;             /* pointer to your data */
-}  ScriptVarBindRecord;
-
-class ScriptHelper
-{
-public:
-    static int get_byte (lua_State *L, void *v);
-    static int set_byte (lua_State *L, void *v);
-
-    static int get_int (lua_State *L, void *v);
-    static int set_int (lua_State *L, void *v);
-
-    static int get_number (lua_State *L, void *v);
-    static int set_number (lua_State *L, void *v);
-
-    static int get_string (lua_State *L, void *v);
-    
-private:
-    friend class ScriptManager;
-    
-    static int staticVarCall(lua_State *L);
-    static int index_handler (lua_State *L);
-    static int newindex_handler (lua_State *L);
-};
-
-#endif	/* _SCRIPTHELPER_HPP */
-

Modified: trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -22,6 +22,8 @@
 #include &quot;ScriptManager.hpp&quot;
 #include &quot;Util/FileSystem.hpp&quot;
 
+#include &quot;bindings/NetPanzerBindings.hpp&quot;
+
 lua_State * ScriptManager::luavm = 0;
 
 void
@@ -34,7 +36,10 @@
         {
             luaL_openlibs(luavm);
         }
+        tolua_NetPanzer_open(luavm);
+
     }
+
 }
     
 void
@@ -54,37 +59,6 @@
 }
     
 void
-ScriptManager::bindStaticVariables(const char * objectName,
-                                   const char * metaName,
-                                   ScriptVarBindRecord * getters,
-                                   ScriptVarBindRecord * setters)
-{
-    luaL_newmetatable(luavm, metaName);
-    int metatable = lua_gettop(luavm);
-
-    lua_pushliteral(luavm, &quot;__index&quot;);
-    lua_pushvalue(luavm, metatable);  /* upvalue index 1 */
-    bindStaticVars(getters);     /* fill metatable with getters */
-    lua_pushcclosure(luavm, ScriptHelper::index_handler, 1);
-    lua_rawset(luavm, metatable);     /* metatable.__index = index_handler */
-
-    lua_pushliteral(luavm, &quot;__newindex&quot;);
-    lua_newtable(luavm);              /* table for members you can set */
-    bindStaticVars(setters);     /* fill with setters */
-    lua_pushcclosure(luavm, ScriptHelper::newindex_handler, 1);
-    lua_rawset(luavm, metatable);     /* metatable.__newindex = newindex_handler */
-
-    lua_pop(luavm, 1);                /* drop metatable */
-
-    // we don't save the address of new data
-    void * t = lua_newuserdata(luavm,sizeof(void*));
-    (void)t;
-    luaL_getmetatable(luavm, metaName);
-    lua_setmetatable(luavm,-2);
-    lua_setglobal(luavm,objectName);
-}
-    
-void
 ScriptManager::runStr(const char * runname, const char * str)
 {
     luaL_loadbuffer(luavm,str,strlen(str), runname);
@@ -107,14 +81,3 @@
         lua_pop(luavm,1);
     }
 }
-    
-void
-ScriptManager::bindStaticVars (ScriptVarBindRecord * recordlist)
-{
-    for (; recordlist-&gt;name; recordlist++)
-    {
-        lua_pushstring(luavm, recordlist-&gt;name);
-        lua_pushlightuserdata(luavm, (void*)recordlist);
-        lua_settable(luavm, -3);
-    }
-}

Modified: trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -21,7 +21,7 @@
 #ifndef _SCRIPTMANAGER_HPP
 #define	_SCRIPTMANAGER_HPP
 
-#include &quot;ScriptHelper.hpp&quot;
+#include &quot;lua/lua.hpp&quot;
 
 class ScriptManager
 {
@@ -30,20 +30,14 @@
     static void close();
     
     static void registerLib(const char * libname, const luaL_reg * functions);
-    
-    static void bindStaticVariables(const char * objectName,
-                                    const char * metaName,
-                                    ScriptVarBindRecord * getters,
-                                    ScriptVarBindRecord * setters);
-    
+        
     static void runStr(const char * runname, const char * str);
     
     // NOTE: runFile has to run after FileSystem has been initialized.
     static void runFile(const char * runname, const char * filename);
+    static lua_State* getLuavm() { return luavm; }
     
-private:
-    static void bindStaticVars (ScriptVarBindRecord * recordlist);
-        
+private:        
     static lua_State *luavm;
 };
 

Added: trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,2374 @@
+/*
+** Lua binding: NetPanzer
+** Generated automatically by tolua++-1.0.92 on Sun Dec 20 22:38:44 2009.
+*/
+
+#ifndef __cplusplus
+#include &quot;stdlib.h&quot;
+#endif
+#include &quot;string.h&quot;
+
+#include &quot;tolua++.h&quot;
+
+/* Exported function */
+TOLUA_API int  tolua_NetPanzer_open (lua_State* tolua_S);
+
+#include &quot;2D/Color.hpp&quot;
+#include &quot;2D/Palette.hpp&quot;
+#include &quot;Util/Log.hpp&quot;
+#include &quot;Interfaces/ConsoleInterface.hpp&quot;
+#include &quot;Classes/PlayerState.hpp&quot;
+#include &quot;Interfaces/PlayerInterface.hpp&quot;
+
+/* function to register type */
+static void tolua_reg_types (lua_State* tolua_S)
+{
+ tolua_usertype(tolua_S,&quot;Logger&quot;);
+ tolua_usertype(tolua_S,&quot;ConsoleInterface&quot;);
+ tolua_usertype(tolua_S,&quot;iXY&quot;);
+ tolua_usertype(tolua_S,&quot;Color&quot;);
+ tolua_usertype(tolua_S,&quot;PlayerState&quot;);
+ tolua_usertype(tolua_S,&quot;PlayerInterface&quot;);
+ tolua_usertype(tolua_S,&quot;Palette&quot;);
+}
+
+/* get function: unitAqua of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitAqua
+static int tolua_get_Color_unitAqua(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitAqua);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitAqua of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitAqua
+static int tolua_set_Color_unitAqua(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitAqua = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitYellow
+static int tolua_get_Color_unitYellow(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitYellow);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitYellow
+static int tolua_set_Color_unitYellow(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitYellow = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitRed
+static int tolua_get_Color_unitRed(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitRed);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitRed
+static int tolua_set_Color_unitRed(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitRed = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitBlue
+static int tolua_get_Color_unitBlue(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitBlue);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitBlue
+static int tolua_set_Color_unitBlue(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitBlue = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitDarkBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitDarkBlue
+static int tolua_get_Color_unitDarkBlue(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitDarkBlue);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitDarkBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitDarkBlue
+static int tolua_set_Color_unitDarkBlue(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitDarkBlue = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitLightGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitLightGreen
+static int tolua_get_Color_unitLightGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitLightGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitLightGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitLightGreen
+static int tolua_set_Color_unitLightGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitLightGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitGreen
+static int tolua_get_Color_unitGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitGreen
+static int tolua_set_Color_unitGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitBlueGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitBlueGray
+static int tolua_get_Color_unitBlueGray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitBlueGray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitBlueGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitBlueGray
+static int tolua_set_Color_unitBlueGray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitBlueGray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitDarkRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitDarkRed
+static int tolua_get_Color_unitDarkRed(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitDarkRed);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitDarkRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitDarkRed
+static int tolua_set_Color_unitDarkRed(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitDarkRed = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitBlack of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitBlack
+static int tolua_get_Color_unitBlack(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitBlack);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitBlack of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitBlack
+static int tolua_set_Color_unitBlack(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitBlack = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitDarkGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitDarkGreen
+static int tolua_get_Color_unitDarkGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitDarkGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitDarkGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitDarkGreen
+static int tolua_set_Color_unitDarkGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitDarkGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitWhite of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitWhite
+static int tolua_get_Color_unitWhite(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitWhite);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitWhite of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitWhite
+static int tolua_set_Color_unitWhite(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitWhite = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitLightOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitLightOrange
+static int tolua_get_Color_unitLightOrange(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitLightOrange);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitLightOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitLightOrange
+static int tolua_set_Color_unitLightOrange(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitLightOrange = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitOrange
+static int tolua_get_Color_unitOrange(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitOrange);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitOrange
+static int tolua_set_Color_unitOrange(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitOrange = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitGray
+static int tolua_get_Color_unitGray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitGray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitGray
+static int tolua_set_Color_unitGray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitGray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: unitDarkGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_unitDarkGray
+static int tolua_get_Color_unitDarkGray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::unitDarkGray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: unitDarkGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_unitDarkGray
+static int tolua_set_Color_unitDarkGray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::unitDarkGray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: black of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_black
+static int tolua_get_Color_black(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::black);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: black of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_black
+static int tolua_set_Color_black(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::black = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: blue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_blue
+static int tolua_get_Color_blue(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::blue);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: blue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_blue
+static int tolua_set_Color_blue(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::blue = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: brown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_brown
+static int tolua_get_Color_brown(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::brown);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: brown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_brown
+static int tolua_set_Color_brown(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::brown = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: cyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_cyan
+static int tolua_get_Color_cyan(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::cyan);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: cyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_cyan
+static int tolua_set_Color_cyan(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::cyan = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray
+static int tolua_get_Color_gray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray
+static int tolua_set_Color_gray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: green of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_green
+static int tolua_get_Color_green(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::green);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: green of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_green
+static int tolua_set_Color_green(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::green = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: magenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_magenta
+static int tolua_get_Color_magenta(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::magenta);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: magenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_magenta
+static int tolua_set_Color_magenta(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::magenta = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: orange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_orange
+static int tolua_get_Color_orange(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::orange);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: orange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_orange
+static int tolua_set_Color_orange(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::orange = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: pink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_pink
+static int tolua_get_Color_pink(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::pink);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: pink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_pink
+static int tolua_set_Color_pink(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::pink = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: red of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_red
+static int tolua_get_Color_red(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::red);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: red of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_red
+static int tolua_set_Color_red(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::red = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: white of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_white
+static int tolua_get_Color_white(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::white);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: white of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_white
+static int tolua_set_Color_white(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::white = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: yellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_yellow
+static int tolua_get_Color_yellow(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::yellow);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: yellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_yellow
+static int tolua_set_Color_yellow(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::yellow = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: tan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_tan
+static int tolua_get_Color_tan(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::tan);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: tan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_tan
+static int tolua_set_Color_tan(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::tan = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: chartreuse of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_chartreuse
+static int tolua_get_Color_chartreuse(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::chartreuse);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: chartreuse of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_chartreuse
+static int tolua_set_Color_chartreuse(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::chartreuse = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: cobaltGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_cobaltGreen
+static int tolua_get_Color_cobaltGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::cobaltGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: cobaltGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_cobaltGreen
+static int tolua_set_Color_cobaltGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::cobaltGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: emeraldGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_emeraldGreen
+static int tolua_get_Color_emeraldGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::emeraldGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: emeraldGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_emeraldGreen
+static int tolua_set_Color_emeraldGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::emeraldGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: forestGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_forestGreen
+static int tolua_get_Color_forestGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::forestGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: forestGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_forestGreen
+static int tolua_set_Color_forestGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::forestGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkOliveGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkOliveGreen
+static int tolua_get_Color_darkOliveGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkOliveGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkOliveGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkOliveGreen
+static int tolua_set_Color_darkOliveGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkOliveGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: terreVerte of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_terreVerte
+static int tolua_get_Color_terreVerte(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::terreVerte);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: terreVerte of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_terreVerte
+static int tolua_set_Color_terreVerte(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::terreVerte = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkBlue
+static int tolua_get_Color_darkBlue(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkBlue);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkBlue
+static int tolua_set_Color_darkBlue(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkBlue = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkBrown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkBrown
+static int tolua_get_Color_darkBrown(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkBrown);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkBrown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkBrown
+static int tolua_set_Color_darkBrown(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkBrown = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkCyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkCyan
+static int tolua_get_Color_darkCyan(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkCyan);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkCyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkCyan
+static int tolua_set_Color_darkCyan(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkCyan = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkGray
+static int tolua_get_Color_darkGray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkGray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkGray
+static int tolua_set_Color_darkGray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkGray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkGreen
+static int tolua_get_Color_darkGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkGreen
+static int tolua_set_Color_darkGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkMagenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkMagenta
+static int tolua_get_Color_darkMagenta(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkMagenta);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkMagenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkMagenta
+static int tolua_set_Color_darkMagenta(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkMagenta = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkOrange
+static int tolua_get_Color_darkOrange(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkOrange);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkOrange
+static int tolua_set_Color_darkOrange(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkOrange = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkPink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkPink
+static int tolua_get_Color_darkPink(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkPink);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkPink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkPink
+static int tolua_set_Color_darkPink(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkPink = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkRed
+static int tolua_get_Color_darkRed(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkRed);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkRed
+static int tolua_set_Color_darkRed(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkRed = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: darkYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_darkYellow
+static int tolua_get_Color_darkYellow(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::darkYellow);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: darkYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_darkYellow
+static int tolua_set_Color_darkYellow(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::darkYellow = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightBlue
+static int tolua_get_Color_lightBlue(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightBlue);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightBlue of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightBlue
+static int tolua_set_Color_lightBlue(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightBlue = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightBrown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightBrown
+static int tolua_get_Color_lightBrown(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightBrown);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightBrown of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightBrown
+static int tolua_set_Color_lightBrown(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightBrown = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightCyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightCyan
+static int tolua_get_Color_lightCyan(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightCyan);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightCyan of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightCyan
+static int tolua_set_Color_lightCyan(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightCyan = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightGray
+static int tolua_get_Color_lightGray(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightGray);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightGray of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightGray
+static int tolua_set_Color_lightGray(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightGray = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightGreen
+static int tolua_get_Color_lightGreen(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightGreen);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightGreen of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightGreen
+static int tolua_set_Color_lightGreen(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightGreen = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightMagenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightMagenta
+static int tolua_get_Color_lightMagenta(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightMagenta);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightMagenta of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightMagenta
+static int tolua_set_Color_lightMagenta(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightMagenta = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightOrange
+static int tolua_get_Color_lightOrange(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightOrange);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightOrange of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightOrange
+static int tolua_set_Color_lightOrange(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightOrange = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightPink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightPink
+static int tolua_get_Color_lightPink(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightPink);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightPink of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightPink
+static int tolua_set_Color_lightPink(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightPink = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightRed
+static int tolua_get_Color_lightRed(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightRed);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightRed of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightRed
+static int tolua_set_Color_lightRed(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightRed = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: lightYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_lightYellow
+static int tolua_get_Color_lightYellow(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::lightYellow);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: lightYellow of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_lightYellow
+static int tolua_set_Color_lightYellow(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::lightYellow = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray32 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray32
+static int tolua_get_Color_gray32(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray32);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray32 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray32
+static int tolua_set_Color_gray32(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray32 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray64 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray64
+static int tolua_get_Color_gray64(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray64);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray64 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray64
+static int tolua_set_Color_gray64(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray64 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray96 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray96
+static int tolua_get_Color_gray96(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray96);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray96 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray96
+static int tolua_set_Color_gray96(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray96 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray128 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray128
+static int tolua_get_Color_gray128(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray128);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray128 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray128
+static int tolua_set_Color_gray128(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray128 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray160 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray160
+static int tolua_get_Color_gray160(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray160);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray160 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray160
+static int tolua_set_Color_gray160(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray160 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray192 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray192
+static int tolua_get_Color_gray192(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray192);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray192 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray192
+static int tolua_set_Color_gray192(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray192 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gray224 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_get_Color_gray224
+static int tolua_get_Color_gray224(lua_State* tolua_S)
+{
+  tolua_pushnumber(tolua_S,(lua_Number)Color::gray224);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gray224 of class  Color */
+#ifndef TOLUA_DISABLE_tolua_set_Color_gray224
+static int tolua_set_Color_gray224(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  Color::gray224 = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: makeColor of class  Palette */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_Palette_makeColor00
+static int tolua_NetPanzer_Palette_makeColor00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;Palette&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,4,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,5,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  int r = ((int)  tolua_tonumber(tolua_S,2,0));
+  int g = ((int)  tolua_tonumber(tolua_S,3,0));
+  int b = ((int)  tolua_tonumber(tolua_S,4,0));
+  {
+   int tolua_ret = (int)  Palette::makeColor(r,g,b);
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'makeColor'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: log of class  Logger */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_Logger_log00
+static int tolua_NetPanzer_Logger_log00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;Logger&quot;,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Logger* self = (Logger*)  tolua_tousertype(tolua_S,1,0);
+  const char* str = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'log'&quot;, NULL);
+#endif
+  {
+   self-&gt;log(str);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'log'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: LOGGER */
+#ifndef TOLUA_DISABLE_tolua_get_LOGGER
+static int tolua_get_LOGGER(lua_State* tolua_S)
+{
+   tolua_pushusertype(tolua_S,(void*)&amp;LOGGER,&quot;Logger&quot;);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: post of class  ConsoleInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_ConsoleInterface_post00
+static int tolua_NetPanzer_ConsoleInterface_post00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;ConsoleInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isboolean(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,4,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,5,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,6,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+   int msgColor = ((  int)  tolua_tonumber(tolua_S,2,0));
+  bool hasFlag = ((bool)  tolua_toboolean(tolua_S,3,0));
+   int flag = ((  int)  tolua_tonumber(tolua_S,4,0));
+  const char* msg = ((const char*)  tolua_tostring(tolua_S,5,0));
+  {
+   ConsoleInterface::post(msgColor,hasFlag,flag,msg);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'post'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getID of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getID00
+static int tolua_NetPanzer_PlayerState_getID00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  PlayerState* self = (PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getID'&quot;, NULL);
+#endif
+  {
+    int tolua_ret = (  int)  self-&gt;getID();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getID'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getName of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getName00
+static int tolua_NetPanzer_PlayerState_getName00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getName'&quot;, NULL);
+#endif
+  {
+   const std::string tolua_ret = (const std::string)  self-&gt;getName();
+   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getName'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getKills of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getKills00
+static int tolua_NetPanzer_PlayerState_getKills00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getKills'&quot;, NULL);
+#endif
+  {
+   short tolua_ret = (short)  self-&gt;getKills();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getKills'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getLosses of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getLosses00
+static int tolua_NetPanzer_PlayerState_getLosses00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getLosses'&quot;, NULL);
+#endif
+  {
+   short tolua_ret = (short)  self-&gt;getLosses();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getLosses'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getObjectivesHeld of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getObjectivesHeld00
+static int tolua_NetPanzer_PlayerState_getObjectivesHeld00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getObjectivesHeld'&quot;, NULL);
+#endif
+  {
+   short tolua_ret = (short)  self-&gt;getObjectivesHeld();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getObjectivesHeld'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getStatus of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getStatus00
+static int tolua_NetPanzer_PlayerState_getStatus00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getStatus'&quot;, NULL);
+#endif
+  {
+   unsigned char tolua_ret = (unsigned char)  self-&gt;getStatus();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getStatus'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setFlag of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_setFlag00
+static int tolua_NetPanzer_PlayerState_setFlag00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  PlayerState* self = (PlayerState*)  tolua_tousertype(tolua_S,1,0);
+   int newflag = ((  int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'setFlag'&quot;, NULL);
+#endif
+  {
+   self-&gt;setFlag(newflag);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'setFlag'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getFlag of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getFlag00
+static int tolua_NetPanzer_PlayerState_getFlag00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getFlag'&quot;, NULL);
+#endif
+  {
+    int tolua_ret = (  int)  self-&gt;getFlag();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getFlag'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getTotal of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getTotal00
+static int tolua_NetPanzer_PlayerState_getTotal00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getTotal'&quot;, NULL);
+#endif
+  {
+   short tolua_ret = (short)  self-&gt;getTotal();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getTotal'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setColor of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_setColor00
+static int tolua_NetPanzer_PlayerState_setColor00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  PlayerState* self = (PlayerState*)  tolua_tousertype(tolua_S,1,0);
+   int index = ((  int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'setColor'&quot;, NULL);
+#endif
+  {
+   self-&gt;setColor(index);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'setColor'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getColor of class  PlayerState */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getColor00
+static int tolua_NetPanzer_PlayerState_getColor00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,&quot;const PlayerState&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const PlayerState* self = (const PlayerState*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'getColor'&quot;, NULL);
+#endif
+  {
+    int tolua_ret = (  int)  self-&gt;getColor();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getColor'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: isAllied of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_isAllied00
+static int tolua_NetPanzer_PlayerInterface_isAllied00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  unsigned short player = ((unsigned short)  tolua_tonumber(tolua_S,2,0));
+  unsigned short with_player = ((unsigned short)  tolua_tonumber(tolua_S,3,0));
+  {
+   bool tolua_ret = (bool)  PlayerInterface::isAllied(player,with_player);
+   tolua_pushboolean(tolua_S,(bool)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'isAllied'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: isSingleAllied of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_isSingleAllied00
+static int tolua_NetPanzer_PlayerInterface_isSingleAllied00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  unsigned short player = ((unsigned short)  tolua_tonumber(tolua_S,2,0));
+  unsigned short with_player = ((unsigned short)  tolua_tonumber(tolua_S,3,0));
+  {
+   bool tolua_ret = (bool)  PlayerInterface::isSingleAllied(player,with_player);
+   tolua_pushboolean(tolua_S,(bool)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'isSingleAllied'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getMaxPlayers of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_getMaxPlayers00
+static int tolua_NetPanzer_PlayerInterface_getMaxPlayers00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   unsigned short tolua_ret = (unsigned short)  PlayerInterface::getMaxPlayers();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getMaxPlayers'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getPlayer of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_getPlayer00
+static int tolua_NetPanzer_PlayerInterface_getPlayer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+   int player_index = ((  int)  tolua_tonumber(tolua_S,2,0));
+  {
+   PlayerState* tolua_ret = (PlayerState*)  PlayerInterface::getPlayer(player_index);
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;PlayerState&quot;);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getPlayer'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getLocalPlayer of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_getLocalPlayer00
+static int tolua_NetPanzer_PlayerInterface_getLocalPlayer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   PlayerState* tolua_ret = (PlayerState*)  PlayerInterface::getLocalPlayer();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;PlayerState&quot;);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getLocalPlayer'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getLocalPlayerIndex of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_getLocalPlayerIndex00
+static int tolua_NetPanzer_PlayerInterface_getLocalPlayerIndex00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   int tolua_ret = (int)  PlayerInterface::getLocalPlayerIndex();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getLocalPlayerIndex'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getActivePlayerCount of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_getActivePlayerCount00
+static int tolua_NetPanzer_PlayerInterface_getActivePlayerCount00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   int tolua_ret = (int)  PlayerInterface::getActivePlayerCount();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'getActivePlayerCount'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: countPlayers of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_countPlayers00
+static int tolua_NetPanzer_PlayerInterface_countPlayers00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   int tolua_ret = (int)  PlayerInterface::countPlayers();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'countPlayers'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: spawnPlayer of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_spawnPlayer00
+static int tolua_NetPanzer_PlayerInterface_spawnPlayer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&amp;tolua_err) || !tolua_isusertype(tolua_S,3,&quot;const iXY&quot;,0,&amp;tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+   int player_index = ((  int)  tolua_tonumber(tolua_S,2,0));
+  const iXY* location = ((const iXY*)  tolua_tousertype(tolua_S,3,0));
+  {
+   PlayerInterface::spawnPlayer(player_index,*location);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'spawnPlayer'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* Open function */
+TOLUA_API int tolua_NetPanzer_open (lua_State* tolua_S)
+{
+ tolua_open(tolua_S);
+ tolua_reg_types(tolua_S);
+ tolua_module(tolua_S,NULL,1);
+ tolua_beginmodule(tolua_S,NULL);
+  tolua_cclass(tolua_S,&quot;Color&quot;,&quot;Color&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;Color&quot;);
+   tolua_variable(tolua_S,&quot;unitAqua&quot;,tolua_get_Color_unitAqua,tolua_set_Color_unitAqua);
+   tolua_variable(tolua_S,&quot;unitYellow&quot;,tolua_get_Color_unitYellow,tolua_set_Color_unitYellow);
+   tolua_variable(tolua_S,&quot;unitRed&quot;,tolua_get_Color_unitRed,tolua_set_Color_unitRed);
+   tolua_variable(tolua_S,&quot;unitBlue&quot;,tolua_get_Color_unitBlue,tolua_set_Color_unitBlue);
+   tolua_variable(tolua_S,&quot;unitDarkBlue&quot;,tolua_get_Color_unitDarkBlue,tolua_set_Color_unitDarkBlue);
+   tolua_variable(tolua_S,&quot;unitLightGreen&quot;,tolua_get_Color_unitLightGreen,tolua_set_Color_unitLightGreen);
+   tolua_variable(tolua_S,&quot;unitGreen&quot;,tolua_get_Color_unitGreen,tolua_set_Color_unitGreen);
+   tolua_variable(tolua_S,&quot;unitBlueGray&quot;,tolua_get_Color_unitBlueGray,tolua_set_Color_unitBlueGray);
+   tolua_variable(tolua_S,&quot;unitDarkRed&quot;,tolua_get_Color_unitDarkRed,tolua_set_Color_unitDarkRed);
+   tolua_variable(tolua_S,&quot;unitBlack&quot;,tolua_get_Color_unitBlack,tolua_set_Color_unitBlack);
+   tolua_variable(tolua_S,&quot;unitDarkGreen&quot;,tolua_get_Color_unitDarkGreen,tolua_set_Color_unitDarkGreen);
+   tolua_variable(tolua_S,&quot;unitWhite&quot;,tolua_get_Color_unitWhite,tolua_set_Color_unitWhite);
+   tolua_variable(tolua_S,&quot;unitLightOrange&quot;,tolua_get_Color_unitLightOrange,tolua_set_Color_unitLightOrange);
+   tolua_variable(tolua_S,&quot;unitOrange&quot;,tolua_get_Color_unitOrange,tolua_set_Color_unitOrange);
+   tolua_variable(tolua_S,&quot;unitGray&quot;,tolua_get_Color_unitGray,tolua_set_Color_unitGray);
+   tolua_variable(tolua_S,&quot;unitDarkGray&quot;,tolua_get_Color_unitDarkGray,tolua_set_Color_unitDarkGray);
+   tolua_variable(tolua_S,&quot;black&quot;,tolua_get_Color_black,tolua_set_Color_black);
+   tolua_variable(tolua_S,&quot;blue&quot;,tolua_get_Color_blue,tolua_set_Color_blue);
+   tolua_variable(tolua_S,&quot;brown&quot;,tolua_get_Color_brown,tolua_set_Color_brown);
+   tolua_variable(tolua_S,&quot;cyan&quot;,tolua_get_Color_cyan,tolua_set_Color_cyan);
+   tolua_variable(tolua_S,&quot;gray&quot;,tolua_get_Color_gray,tolua_set_Color_gray);
+   tolua_variable(tolua_S,&quot;green&quot;,tolua_get_Color_green,tolua_set_Color_green);
+   tolua_variable(tolua_S,&quot;magenta&quot;,tolua_get_Color_magenta,tolua_set_Color_magenta);
+   tolua_variable(tolua_S,&quot;orange&quot;,tolua_get_Color_orange,tolua_set_Color_orange);
+   tolua_variable(tolua_S,&quot;pink&quot;,tolua_get_Color_pink,tolua_set_Color_pink);
+   tolua_variable(tolua_S,&quot;red&quot;,tolua_get_Color_red,tolua_set_Color_red);
+   tolua_variable(tolua_S,&quot;white&quot;,tolua_get_Color_white,tolua_set_Color_white);
+   tolua_variable(tolua_S,&quot;yellow&quot;,tolua_get_Color_yellow,tolua_set_Color_yellow);
+   tolua_variable(tolua_S,&quot;tan&quot;,tolua_get_Color_tan,tolua_set_Color_tan);
+   tolua_variable(tolua_S,&quot;chartreuse&quot;,tolua_get_Color_chartreuse,tolua_set_Color_chartreuse);
+   tolua_variable(tolua_S,&quot;cobaltGreen&quot;,tolua_get_Color_cobaltGreen,tolua_set_Color_cobaltGreen);
+   tolua_variable(tolua_S,&quot;emeraldGreen&quot;,tolua_get_Color_emeraldGreen,tolua_set_Color_emeraldGreen);
+   tolua_variable(tolua_S,&quot;forestGreen&quot;,tolua_get_Color_forestGreen,tolua_set_Color_forestGreen);
+   tolua_variable(tolua_S,&quot;darkOliveGreen&quot;,tolua_get_Color_darkOliveGreen,tolua_set_Color_darkOliveGreen);
+   tolua_variable(tolua_S,&quot;terreVerte&quot;,tolua_get_Color_terreVerte,tolua_set_Color_terreVerte);
+   tolua_variable(tolua_S,&quot;darkBlue&quot;,tolua_get_Color_darkBlue,tolua_set_Color_darkBlue);
+   tolua_variable(tolua_S,&quot;darkBrown&quot;,tolua_get_Color_darkBrown,tolua_set_Color_darkBrown);
+   tolua_variable(tolua_S,&quot;darkCyan&quot;,tolua_get_Color_darkCyan,tolua_set_Color_darkCyan);
+   tolua_variable(tolua_S,&quot;darkGray&quot;,tolua_get_Color_darkGray,tolua_set_Color_darkGray);
+   tolua_variable(tolua_S,&quot;darkGreen&quot;,tolua_get_Color_darkGreen,tolua_set_Color_darkGreen);
+   tolua_variable(tolua_S,&quot;darkMagenta&quot;,tolua_get_Color_darkMagenta,tolua_set_Color_darkMagenta);
+   tolua_variable(tolua_S,&quot;darkOrange&quot;,tolua_get_Color_darkOrange,tolua_set_Color_darkOrange);
+   tolua_variable(tolua_S,&quot;darkPink&quot;,tolua_get_Color_darkPink,tolua_set_Color_darkPink);
+   tolua_variable(tolua_S,&quot;darkRed&quot;,tolua_get_Color_darkRed,tolua_set_Color_darkRed);
+   tolua_variable(tolua_S,&quot;darkYellow&quot;,tolua_get_Color_darkYellow,tolua_set_Color_darkYellow);
+   tolua_variable(tolua_S,&quot;lightBlue&quot;,tolua_get_Color_lightBlue,tolua_set_Color_lightBlue);
+   tolua_variable(tolua_S,&quot;lightBrown&quot;,tolua_get_Color_lightBrown,tolua_set_Color_lightBrown);
+   tolua_variable(tolua_S,&quot;lightCyan&quot;,tolua_get_Color_lightCyan,tolua_set_Color_lightCyan);
+   tolua_variable(tolua_S,&quot;lightGray&quot;,tolua_get_Color_lightGray,tolua_set_Color_lightGray);
+   tolua_variable(tolua_S,&quot;lightGreen&quot;,tolua_get_Color_lightGreen,tolua_set_Color_lightGreen);
+   tolua_variable(tolua_S,&quot;lightMagenta&quot;,tolua_get_Color_lightMagenta,tolua_set_Color_lightMagenta);
+   tolua_variable(tolua_S,&quot;lightOrange&quot;,tolua_get_Color_lightOrange,tolua_set_Color_lightOrange);
+   tolua_variable(tolua_S,&quot;lightPink&quot;,tolua_get_Color_lightPink,tolua_set_Color_lightPink);
+   tolua_variable(tolua_S,&quot;lightRed&quot;,tolua_get_Color_lightRed,tolua_set_Color_lightRed);
+   tolua_variable(tolua_S,&quot;lightYellow&quot;,tolua_get_Color_lightYellow,tolua_set_Color_lightYellow);
+   tolua_variable(tolua_S,&quot;gray32&quot;,tolua_get_Color_gray32,tolua_set_Color_gray32);
+   tolua_variable(tolua_S,&quot;gray64&quot;,tolua_get_Color_gray64,tolua_set_Color_gray64);
+   tolua_variable(tolua_S,&quot;gray96&quot;,tolua_get_Color_gray96,tolua_set_Color_gray96);
+   tolua_variable(tolua_S,&quot;gray128&quot;,tolua_get_Color_gray128,tolua_set_Color_gray128);
+   tolua_variable(tolua_S,&quot;gray160&quot;,tolua_get_Color_gray160,tolua_set_Color_gray160);
+   tolua_variable(tolua_S,&quot;gray192&quot;,tolua_get_Color_gray192,tolua_set_Color_gray192);
+   tolua_variable(tolua_S,&quot;gray224&quot;,tolua_get_Color_gray224,tolua_set_Color_gray224);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;Palette&quot;,&quot;Palette&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;Palette&quot;);
+   tolua_function(tolua_S,&quot;makeColor&quot;,tolua_NetPanzer_Palette_makeColor00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;Logger&quot;,&quot;Logger&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;Logger&quot;);
+   tolua_function(tolua_S,&quot;log&quot;,tolua_NetPanzer_Logger_log00);
+  tolua_endmodule(tolua_S);
+  tolua_variable(tolua_S,&quot;LOGGER&quot;,tolua_get_LOGGER,NULL);
+  tolua_cclass(tolua_S,&quot;ConsoleInterface&quot;,&quot;ConsoleInterface&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;ConsoleInterface&quot;);
+   tolua_function(tolua_S,&quot;post&quot;,tolua_NetPanzer_ConsoleInterface_post00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;PlayerState&quot;,&quot;PlayerState&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;PlayerState&quot;);
+   tolua_function(tolua_S,&quot;getID&quot;,tolua_NetPanzer_PlayerState_getID00);
+   tolua_function(tolua_S,&quot;getName&quot;,tolua_NetPanzer_PlayerState_getName00);
+   tolua_function(tolua_S,&quot;getKills&quot;,tolua_NetPanzer_PlayerState_getKills00);
+   tolua_function(tolua_S,&quot;getLosses&quot;,tolua_NetPanzer_PlayerState_getLosses00);
+   tolua_function(tolua_S,&quot;getObjectivesHeld&quot;,tolua_NetPanzer_PlayerState_getObjectivesHeld00);
+   tolua_function(tolua_S,&quot;getStatus&quot;,tolua_NetPanzer_PlayerState_getStatus00);
+   tolua_function(tolua_S,&quot;setFlag&quot;,tolua_NetPanzer_PlayerState_setFlag00);
+   tolua_function(tolua_S,&quot;getFlag&quot;,tolua_NetPanzer_PlayerState_getFlag00);
+   tolua_function(tolua_S,&quot;getTotal&quot;,tolua_NetPanzer_PlayerState_getTotal00);
+   tolua_function(tolua_S,&quot;setColor&quot;,tolua_NetPanzer_PlayerState_setColor00);
+   tolua_function(tolua_S,&quot;getColor&quot;,tolua_NetPanzer_PlayerState_getColor00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;PlayerInterface&quot;,&quot;PlayerInterface&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;PlayerInterface&quot;);
+   tolua_function(tolua_S,&quot;isAllied&quot;,tolua_NetPanzer_PlayerInterface_isAllied00);
+   tolua_function(tolua_S,&quot;isSingleAllied&quot;,tolua_NetPanzer_PlayerInterface_isSingleAllied00);
+   tolua_function(tolua_S,&quot;getMaxPlayers&quot;,tolua_NetPanzer_PlayerInterface_getMaxPlayers00);
+   tolua_function(tolua_S,&quot;getPlayer&quot;,tolua_NetPanzer_PlayerInterface_getPlayer00);
+   tolua_function(tolua_S,&quot;getLocalPlayer&quot;,tolua_NetPanzer_PlayerInterface_getLocalPlayer00);
+   tolua_function(tolua_S,&quot;getLocalPlayerIndex&quot;,tolua_NetPanzer_PlayerInterface_getLocalPlayerIndex00);
+   tolua_function(tolua_S,&quot;getActivePlayerCount&quot;,tolua_NetPanzer_PlayerInterface_getActivePlayerCount00);
+   tolua_function(tolua_S,&quot;countPlayers&quot;,tolua_NetPanzer_PlayerInterface_countPlayers00);
+   tolua_function(tolua_S,&quot;spawnPlayer&quot;,tolua_NetPanzer_PlayerInterface_spawnPlayer00);
+  tolua_endmodule(tolua_S);
+ tolua_endmodule(tolua_S);
+ return 1;
+}
+
+
+#if defined(LUA_VERSION_NUM) &amp;&amp; LUA_VERSION_NUM &gt;= 501
+ TOLUA_API int luaopen_NetPanzer (lua_State* tolua_S) {
+ return tolua_NetPanzer_open(tolua_S);
+};
+#endif
+

Added: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/colors.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/colors.pkg	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/colors.pkg	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,86 @@
+$#include &quot;2D/Color.hpp&quot;
+$#include &quot;2D/Palette.hpp&quot;
+
+typedef int IntColor;
+
+class Color
+{
+    static IntColor unitAqua;
+    static IntColor unitYellow;
+    static IntColor unitRed;
+    static IntColor unitBlue;
+    static IntColor unitDarkBlue;
+    static IntColor unitLightGreen;
+    static IntColor unitGreen;
+    static IntColor unitBlueGray;
+    static IntColor unitDarkRed;
+    static IntColor unitBlack;
+    static IntColor unitDarkGreen;
+    static IntColor unitWhite;
+    static IntColor unitLightOrange;
+    static IntColor unitOrange;
+    static IntColor unitGray;
+    static IntColor unitDarkGray;
+
+    // Normal Colors.
+    static IntColor black;
+    static IntColor blue;
+    static IntColor brown;
+    static IntColor cyan;
+    static IntColor gray;
+    static IntColor green;
+    static IntColor magenta;
+    static IntColor orange;
+    static IntColor pink;
+    static IntColor red;
+    static IntColor white;
+    static IntColor yellow;
+
+    // Color specifically for netPanzer.
+    static IntColor tan;
+    static IntColor chartreuse;
+    static IntColor cobaltGreen;
+    static IntColor emeraldGreen;
+    static IntColor forestGreen;
+    static IntColor darkOliveGreen;
+    static IntColor terreVerte;
+
+    // Dark Colors.
+    static IntColor darkBlue;
+    static IntColor darkBrown;
+    static IntColor darkCyan;
+    static IntColor darkGray;
+    static IntColor darkGreen;
+    static IntColor darkMagenta;
+    static IntColor darkOrange;
+    static IntColor darkPink;
+    static IntColor darkRed;
+    static IntColor darkYellow;
+
+    // Light Colors.
+    static IntColor lightBlue;
+    static IntColor lightBrown;
+    static IntColor lightCyan;
+    static IntColor lightGray;
+    static IntColor lightGreen;
+    static IntColor lightMagenta;
+    static IntColor lightOrange;
+    static IntColor lightPink;
+    static IntColor lightRed;
+    static IntColor lightYellow;
+
+    // Gray scales.
+    static IntColor gray32;
+    static IntColor gray64;
+    static IntColor gray96;
+    static IntColor gray128;
+    static IntColor gray160;
+    static IntColor gray192;
+    static IntColor gray224;
+
+};
+
+class Palette
+{
+    static int makeColor(int r, int g, int b);
+};
\ No newline at end of file

Added: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/consoleinterface.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/consoleinterface.pkg	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/consoleinterface.pkg	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,16 @@
+$#include &quot;Interfaces/ConsoleInterface.hpp&quot;
+
+typedef int IntColor;
+typedef int FlagID;
+
+class ConsoleInterface
+{
+    static void post( IntColor msgColor, bool hasFlag, FlagID flag, const char *msg);
+
+    /* Input String Methods */
+    //static void setInputStringStatus( bool on_off );
+    //static void resetInputString( char *prompt );
+    //static void addChar(int newChar);
+    //static void addExtendedChar(int newExtendedChar);
+    //static void getInputString( char *string );
+};

Added: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/log.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/log.pkg	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/log.pkg	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,8 @@
+$#include &quot;Util/Log.hpp&quot;
+
+class Logger
+{
+    void log(const char * str);
+};
+
+tolua_readonly Logger LOGGER;
\ No newline at end of file

Added: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,4 @@
+$pfile &quot;colors.pkg&quot;
+$pfile &quot;log.pkg&quot;
+$pfile &quot;consoleinterface.pkg&quot;
+$pfile &quot;players.pkg&quot;

Added: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg	2009-12-20 15:33:47 UTC (rev 1151)
@@ -0,0 +1,46 @@
+$#include &quot;Classes/PlayerState.hpp&quot;
+$#include &quot;Interfaces/PlayerInterface.hpp&quot;
+
+typedef int Uint16;
+typedef int FlagID;
+typedef int IntColor;
+typedef int Uint32;
+
+class PlayerState
+{
+    Uint16 getID();
+    const std::string&amp; getName() const;
+    short getKills() const;
+    short getLosses() const;
+    short getObjectivesHeld() const;
+
+    unsigned char getStatus() const;
+
+    void setFlag(FlagID newflag);
+    FlagID getFlag() const;
+    short getTotal() const;
+
+    void setColor( Uint32 index );
+    IntColor getColor() const;
+};
+
+class PlayerInterface
+{
+    static bool isAllied(unsigned short player, unsigned short with_player);
+    static bool isSingleAllied(unsigned short player, unsigned short with_player);
+
+    static unsigned short getMaxPlayers( );
+
+    static PlayerState* getPlayer(Uint16 player_index);
+
+    static PlayerState* getLocalPlayer();
+
+    static Uint16 getLocalPlayerIndex();
+
+    static int getActivePlayerCount();
+
+    static int countPlayers();
+
+    static void spawnPlayer( Uint16 player_index, const iXY &amp;location );
+};
+

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/View.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/View.hpp	2009-12-19 03:46:39 UTC (rev 1150)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/View.hpp	2009-12-20 15:33:47 UTC (rev 1151)
@@ -139,6 +139,26 @@
     void fillRect(iRect bounds, const IntColor color);
 
     virtual void onComponentClicked(Component *c) { (void)c; }
+
+    // View Status Functions.
+    void setDisplayStatusBar(const bool &amp;newStatus);
+    void setBordered        (const bool &amp;newStatus);
+    void setAllowMove       (const bool &amp;newStatus);
+    void setActive          (const bool &amp;newStatus);
+
+    // SearchName, Title, and SubTitle functions.
+    void  setSearchName(const char *searchName);
+    void  setTitle(const char *title);
+    void  setSubTitle(const char *subTitle);
+
+    void showStatus(const char *string);
+
+    void resize(const iXY &amp;size);
+    inline void resize(const int &amp;x, const int &amp;y)
+    {
+        resize(iXY(x, y));
+    }
+
     
 protected:
     virtual void     actionPerformed(mMouseEvent )
@@ -164,16 +184,6 @@
     void        activate  ();
     void        deactivate();
 
-    // View Status Functions.
-    void setDisplayStatusBar(const bool &amp;newStatus);
-    void setBordered        (const bool &amp;newStatus);
-    void setAllowMove       (const bool &amp;newStatus);
-    void setActive          (const bool &amp;newStatus);
-
-    // SearchName, Title, and SubTitle functions.
-    void  setSearchName(const char *searchName);
-    void  setTitle(const char *title);
-    void  setSubTitle(const char *subTitle);
     void  drawTitle();
 
     // Input Field Functions
@@ -183,7 +193,6 @@
 
     /////////////////////////////////
     void draw();
-    void showStatus(const char *string);
     void drawStatus();
     virtual void checkResolution(iXY oldResolution, iXY newResolution);
     void checkArea(iXY viewarea);
@@ -212,12 +221,6 @@
     virtual void mouseExit(const iXY &amp;pos);
     //virtual void keyUp();
 
-    void resize(const iXY &amp;size);
-    inline void resize(const int &amp;x, const int &amp;y)
-    {
-        resize(iXY(x, y));
-    }
-
     virtual void processEvents();
 
     int moveAreaHeight;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000178.html">[Netpanzer-cvs] r1150 - in trunk/netpanzer/src/NetPanzer:	Interfaces Units
</A></li>
	<LI>Next message: <A HREF="000180.html">[Netpanzer-cvs] r1152 - in trunk/netpanzer: pics/particles/lights	scripts src/Lib/ArrayUtil src/NetPanzer/Bot	src/NetPanzer/Classes src/NetPanzer/Classes/AI	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units	src/NetPanzer/Views/Components src/NetPanzer/Views/Game	src/NetPanzer/Weapons
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#179">[ date ]</a>
              <a href="thread.html#179">[ thread ]</a>
              <a href="subject.html#179">[ subject ]</a>
              <a href="author.html#179">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
