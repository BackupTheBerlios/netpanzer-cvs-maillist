<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1152 - in trunk/netpanzer: pics/particles/lights	scripts src/Lib/ArrayUtil src/NetPanzer/Bot	src/NetPanzer/Classes src/NetPanzer/Classes/AI	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units	src/NetPanzer/Views/Components src/NetPanzer/Views/Game	src/NetPanzer/Weapons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1152%20-%20in%20trunk/netpanzer%3A%20pics/particles/lights%0A%09scripts%20src/Lib/ArrayUtil%20src/NetPanzer/Bot%0A%09src/NetPanzer/Classes%20src/NetPanzer/Classes/AI%0A%09src/NetPanzer/Classes/Network%20src/NetPanzer/Core%0A%09src/NetPanzer/Interfaces%20src/NetPanzer/Network%0A%09src/NetPanzer/Objectives%20src/NetPanzer/PowerUps%0A%09src/NetPanzer/Scripts%20src/NetPanzer/Scripts/bindings%0A%09src/NetPanzer/Scripts/toluapkg%20src/NetPanzer/Units%0A%09src/NetPanzer/Views/Components%20src/NetPanzer/Views/Game%0A%09src/NetPanzer/Weapons&In-Reply-To=%3C200912271451.nBREpQ1q016877%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000179.html">
   <LINK REL="Next"  HREF="000181.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1152 - in trunk/netpanzer: pics/particles/lights	scripts src/Lib/ArrayUtil src/NetPanzer/Bot	src/NetPanzer/Classes src/NetPanzer/Classes/AI	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units	src/NetPanzer/Views/Components src/NetPanzer/Views/Game	src/NetPanzer/Weapons</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1152%20-%20in%20trunk/netpanzer%3A%20pics/particles/lights%0A%09scripts%20src/Lib/ArrayUtil%20src/NetPanzer/Bot%0A%09src/NetPanzer/Classes%20src/NetPanzer/Classes/AI%0A%09src/NetPanzer/Classes/Network%20src/NetPanzer/Core%0A%09src/NetPanzer/Interfaces%20src/NetPanzer/Network%0A%09src/NetPanzer/Objectives%20src/NetPanzer/PowerUps%0A%09src/NetPanzer/Scripts%20src/NetPanzer/Scripts/bindings%0A%09src/NetPanzer/Scripts/toluapkg%20src/NetPanzer/Units%0A%09src/NetPanzer/Views/Components%20src/NetPanzer/Views/Game%0A%09src/NetPanzer/Weapons&In-Reply-To=%3C200912271451.nBREpQ1q016877%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1152 - in trunk/netpanzer: pics/particles/lights	scripts src/Lib/ArrayUtil src/NetPanzer/Bot	src/NetPanzer/Classes src/NetPanzer/Classes/AI	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Network	src/NetPanzer/Objectives src/NetPanzer/PowerUps	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units	src/NetPanzer/Views/Components src/NetPanzer/Views/Game	src/NetPanzer/Weapons">kromxp at mail.berlios.de
       </A><BR>
    <I>Sun Dec 27 15:51:26 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000179.html">[Netpanzer-cvs] r1151 - in trunk/netpanzer: . scripts src/Lib	src/Lib/2D src/Lib/Util src/Lib/toluapp src/NetPanzer/Classes	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Views/Components
</A></li>
        <LI>Next message: <A HREF="000181.html">[Netpanzer-cvs] r1153 - in trunk/netpanzer: scripts	src/NetPanzer/Bot src/NetPanzer/Classes	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Scripts	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2009-12-27 15:50:29 +0100 (Sun, 27 Dec 2009)
New Revision: 1152

Removed:
   trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
Modified:
   trunk/netpanzer/pics/particles/lights/flash2.png
   trunk/netpanzer/scripts/initialize.lua
   trunk/netpanzer/src/Lib/ArrayUtil/BitArray.cpp
   trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp
   trunk/netpanzer/src/NetPanzer/Bot/BotManager.hpp
   trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
   trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp
   trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
   trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp
   trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.hpp
   trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
   trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp
   trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.hpp
   trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
   trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp
   trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg
   trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg
   trunk/netpanzer/src/NetPanzer/Units/Unit.cpp
   trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
   trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp
   trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp
Log:
- UnitInterface is once more static, the previous idea I had was bad.
- Added scripting and server management from the client. In client game try to say &quot;/help&quot; or &quot;/listcommands&quot;. It is still unfinished but somethings can be done, kicking players, adding bots, swiching maps, etc.


Modified: trunk/netpanzer/pics/particles/lights/flash2.png
===================================================================
(Binary files differ)

Modified: trunk/netpanzer/scripts/initialize.lua
===================================================================
--- trunk/netpanzer/scripts/initialize.lua	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/scripts/initialize.lua	2009-12-27 14:50:29 UTC (rev 1152)
@@ -1,19 +1,158 @@
 
 LOGGER:log(&quot;Script initialization&quot;);
 
-function onUserMessage(msg)
-    local msgx = &quot;Wants to send message: '&quot; .. msg .. &quot;'&quot;;
-    LOGGER:log(msgx);
-    if msg == &quot;/info&quot; then
-        ConsoleInterface:post( Color.cyan, false, 0, &quot;It is info message&quot;);
+LOGGER:log(&quot;gametype is &quot; .. gameconfig.gametype);
+
+UserCommands =
+{
+    say_help = &quot;Says something to all players&quot;,
+    say = function(param)
+        if param then
+            ChatInterface:say(param);
+        end
+    end,
+
+    teamsay_help = &quot;Says something to team players&quot;,
+    teamsay = function(param)
+        if param then
+            ChatInterface:teamsay(param);
+        end
+    end,
+
+    server_help = &quot;Sends the command to the server, no need to add '/' in command&quot;;
+    server = function(param)
+        if param then
+            ChatInterface:say('/' .. param);
+        end
+    end,
+
+    listcommands_help = &quot;List all the commands&quot;;
+    listcommands = function(param)
+        local out;
+        for k,v in pairs(UserCommands) do
+            if type(v) == &quot;function&quot; then
+                if out then
+                    out = out .. &quot;, &quot; .. k;
+                else
+                    out = k;
+                end
+            end
+        end
+        ConsoleInterface:post( Color.cyan, false, 0, out);
+    end,
+
+    _help = &quot;Type /help &lt;wanted_command&gt; or /listcommands&quot;,
+    help_help = &quot;Provides this kind of help&quot;,
+    help = function(param)
+        local ht = UserCommands[param .. &quot;_help&quot;];
+        if ht then
+            ConsoleInterface:post( Color.cyan, false, 0, param .. &quot;: &quot; .. ht);
+        else
+            ConsoleInterface:post( Color.cyan, false, 0, &quot;Help not found for &quot; .. param .. &quot;. Use /listcommands&quot;);
+        end
+    end,
+
+    quit_help = &quot;Quits NetPanzer.&quot;,
+    quit = function(param)
+        GameManager:exitNetPanzer();
+    end,
+
+    disconnect_help = &quot;Disconnects from current server.&quot;,
+    disconnect = function(param)
+        GameManager:quitNetPanzerGame();
+    end,
+
+    info = function(param)
         ConsoleInterface:post( Color.cyan, false, 0, &quot;You are player: &quot; .. PlayerInterface:getLocalPlayerIndex());
-        ps = PlayerInterface:getLocalPlayer();
+        local ps = PlayerInterface:getLocalPlayer();
         ConsoleInterface:post( Color.cyan, true, ps:getFlag(), &quot;Your name is &quot; .. ps:getName());
         ConsoleInterface:post( Color.cyan, false, 0, &quot;Your id is &quot; .. ps:getID());
         ConsoleInterface:post( Color.cyan, false, 0, &quot;Your have &quot; .. ps:getObjectivesHeld() .. &quot; bases&quot;);
+    end,
 
+    testrules = function(param)
+        test_game_rules();
+    end
+};
+
+function onUserMessage(msg)
+    local cmd,arg = msg:match('^/(%w+) *(.*)');
+    if cmd then
+        local func = UserCommands[cmd];
+        if type(func) == &quot;function&quot; then
+            func(arg);
+        end
     else
-        ConsoleInterface:post( Color.cyan, false, 0, msgx);
+        ChatInterface:say(msg);
     end
+end
 
-end
\ No newline at end of file
+-- modes: 0=objective, 1=frag limit, 2=time limit
+function test_game_rules()
+    if gameconfig.gametype == 2 then
+        ConsoleInterface:post( Color.cyan, false, 0, &quot;Game is time limit&quot;);
+    end
+end
+
+ServerCommands =
+{
+    say = function(param, player)
+        if param then
+            ChatInterface:serversay(param);
+        end
+    end,
+
+    kick = function(param, player)
+        if param then
+            GameManager:kickPlayer(param);
+        end
+    end,
+
+    addbot = function(param, player)
+        GameManager:addBot();
+    end,
+
+    removebots = function(param, player)
+        GameManager:removeAllBots();
+    end,
+
+    map = function(param, player)
+        local ok = GameManager:changeMap(param);
+        if ok then
+            ChatInterface:serversayTo(player, 'Switching map to &quot;' .. param .. '&quot;');
+        else
+            ChatInterface:serversayTo(player, 'Map &quot;' .. param .. '&quot; doesn\'t exists');
+        end
+    end,
+
+    listcommands = function(param, player)
+        local out;
+        for k,v in pairs(ServerCommands) do
+            if type(v) == &quot;function&quot; then
+                if out then
+                    out = out .. &quot;, &quot; .. k;
+                else
+                    out = k;
+                end
+            end
+        end
+        ChatInterface:serversayTo(player, out);
+    end,
+
+    testrules = function(param)
+        test_game_rules();
+    end
+};
+
+function serverHandleMessage(msg, player)
+    local cmd,arg = msg:match('^/(%w+) *(.*)');
+    if cmd then
+        local func = ServerCommands[cmd];
+        if func and type(func) == &quot;function&quot; then
+            func(arg, player);
+        end
+--        ConsoleInterface:post( Color.cyan, false, 0, 'received command &quot;' .. msg .. '&quot; from player ' .. player);
+        return false;
+    end
+    return true;
+end

Modified: trunk/netpanzer/src/Lib/ArrayUtil/BitArray.cpp
===================================================================
--- trunk/netpanzer/src/Lib/ArrayUtil/BitArray.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/Lib/ArrayUtil/BitArray.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -40,6 +40,7 @@
 
 BitArray::BitArray( unsigned long x_size, unsigned long y_size )
 {
+    array = 0;
     initialize( x_size, y_size );
 }
 

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -72,28 +72,10 @@
 void
 BotManager::removeBot(Uint16 playerid)
 {
-    for (BotList::iterator i = bot_list.begin(); i != bot_list.end(); i++)
+    for (BotList::iterator i = bot_list.begin(); i != bot_list.end(); ++i)
     {
         if ( (*i)-&gt;botPlayerId == playerid )
         {
-            PlayerState * player = PlayerInterface::getPlayer(playerid);
-
-            ObjectiveInterface::disownPlayerObjectives( playerid );
-
-            global_game_state-&gt;unit_manager-&gt;destroyPlayerUnits( playerid );
-
-            ResourceManagerReleaseFlagMessage releasemsg;
-            releasemsg.setFlagID(player-&gt;getFlag());
-            ResourceManager::releaseFlag(player-&gt;getFlag());
-
-            PlayerInterface::disconnectPlayerCleanup( playerid );
-
-            NetworkServer::broadcastMessage(&amp;releasemsg, sizeof(releasemsg));
-
-            SystemConnectAlert msg;
-            msg.set( playerid, _connect_alert_mesg_disconnect);
-            NetworkServer::broadcastMessage(&amp;msg, sizeof(msg));
-            
             delete (*i);
             bot_list.erase(i);
             break;
@@ -101,19 +83,6 @@
     }
 }
 
-void
-BotManager::removeAllBots()
-{
-    BotList::iterator i = bot_list.begin();
-    while ( i != bot_list.end() )
-    {
-        // removeBot will erase the item from list
-        removeBot((*i)-&gt;botPlayerId);
-        i = bot_list.begin();
-    }
-    // bot_list already cleared
-}
-
 bool
 BotManager::isBot(Uint16 playerid)
 {

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotManager.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotManager.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -28,7 +28,6 @@
 public:
     static Uint16 addBot();
     static void removeBot(Uint16 playerid);
-    static void removeAllBots();
     static bool isBot(Uint16 playerid);
     static void simBots();
     

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -59,7 +59,7 @@
 
             // manual fire on closest enemy
             Unit *enemyUnit;
-            if (global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryClosestEnemyUnitInRange(&amp;enemyUnit,
+            if (UnitBucketArray::queryClosestEnemyUnitInRange(&amp;enemyUnit,
                         unit-&gt;unit_state.location, unit-&gt;unit_state.weapon_range, playerIndex))
             {
                 manualFire(unit, enemyUnit-&gt;unit_state.location);
@@ -82,7 +82,7 @@
 {
     if (m_timer.count())
     {
-        int unitCount = global_game_state-&gt;unit_manager-&gt;getUnitCount(botPlayerId);
+        int unitCount = UnitInterface::getPlayerUnitCount(botPlayerId);
         if (unitCount &gt; 0)
         {
             m_timer.changePeriod(5.0 / unitCount);
@@ -99,14 +99,16 @@
 Unit *
 BotPlayer::getRandomUnit(int playerIndex)
 {
-    const std::vector&lt;Unit*&gt;&amp; units
-        = global_game_state-&gt;unit_manager-&gt;getPlayerUnits(playerIndex);
+    const std::vector&lt;Unit*&gt;* units
+        = UnitInterface::getPlayerUnits(playerIndex);
 
-    if(units.size() == 0)
+    if ( ! units || units-&gt;size() == 0 )
+    {
         return 0;
-    
-    size_t unitIndex = rand() % units.size();
-    return units[unitIndex];
+    }
+
+    size_t unitIndex = rand() % units-&gt;size();
+    return (*units)[unitIndex];
 }
 
 //-----------------------------------------------------------------

Modified: trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -228,7 +228,7 @@
 
     movement_val = getMovementValue( succ-&gt;map_loc );
     if ( movement_val != 0xFF
-         &amp;&amp; global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(succ-&gt;map_loc) == true
+         &amp;&amp; UnitInterface::unitOccupiesLoc(succ-&gt;map_loc) == true
          &amp;&amp; succ-&gt;map_loc != goal_node.map_loc )
     {
         movement_val = 200;

Modified: trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -24,7 +24,6 @@
 
 #include &quot;ArrayUtil/BitArray.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Classes/AI/PathList.hpp&quot;
 
 enum { _path_request_full, _path_request_update };

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -45,6 +45,7 @@
 #include &quot;Resources/ResourceManagerMessages.hpp&quot;
 
 #include &quot;Network/MessageClassHandler.hpp&quot;
+#include &quot;Interfaces/GameManager.hpp&quot;
 
 typedef std::list&lt;ServerClientListData*&gt; ClientList;
 
@@ -161,7 +162,7 @@
         if( (*i)-&gt;client_socket == client )
         {
             client_list.push_back(*i);
-            client_list.erase(i);
+            connecting_clients.erase(i);
             break;
         }
         i++;
@@ -205,22 +206,38 @@
 void
 NetworkServer::dropClient(Uint16 playerid)
 {
-    if ( BotManager::isBot(playerid) )
+    ClientList::iterator i = client_list.begin();
+    while( i != client_list.end() &amp;&amp; (*i)-&gt;client_socket-&gt;getPlayerIndex() != playerid )
     {
-        BotManager::removeBot(playerid);
+        ++i;
     }
-    else
+
+    if ( i != client_list.end() )
     {
-        ClientList::iterator i = client_list.begin();
-        while( i != client_list.end() &amp;&amp; (*i)-&gt;client_socket-&gt;getPlayerIndex() != playerid )
+        // XXX hack
+        onClientDisconected((*i)-&gt;client_socket, &quot;dropped&quot;);
+    }
+}
+
+void
+NetworkServer::removePlayerSocket(const Uint16 player_id)
+{
+    ClientList::iterator i;
+    for ( i = client_list.begin(); i != client_list.end(); ++i)
+    {
+        if ( (*i)-&gt;client_socket-&gt;getPlayerIndex() == player_id )
         {
-            ++i;
+            (*i)-&gt;wannadie = true;
+            return;
         }
+    }
 
-        if ( i != client_list.end() )
+    for ( i = connecting_clients.begin(); i != connecting_clients.end(); ++i)
+    {
+        if ( (*i)-&gt;client_socket-&gt;getPlayerIndex() == player_id )
         {
-            // XXX hack
-            onClientDisconected((*i)-&gt;client_socket, &quot;dropped&quot;);
+            (*i)-&gt;wannadie = true;
+            return;
         }
     }
 }
@@ -331,23 +348,6 @@
 
 }
 
-ClientSocket *
-NetworkServer::getClientSocketByPlayerIndex ( Uint16 index )
-{
-    ClientList::iterator i = client_list.begin();
-    while ( i != client_list.end() )
-    {
-        if ( ! (*i)-&gt;wannadie
-             &amp;&amp; (*i)-&gt;client_socket-&gt;getPlayerIndex() == index )
-        {
-            return (*i)-&gt;client_socket;
-        }
-        i++;
-    }
-
-    return NULL;
-}
-
 std::string
 NetworkServer::getIP(Uint16 player_index)
 {
@@ -386,8 +386,6 @@
         LOGGER.debug(&quot;NetworkServer::onClientDisconected player was connecting&quot;);
     }
 
-
-
 //    if ( NetworkInterface::receive_queue.isReady() )
 //    {
 //        unsigned long frontsave = NetworkInterface::receive_queue.front;
@@ -449,32 +447,23 @@
                                       player-&gt;getName().c_str());
         }
 
-        ObjectiveInterface::disownPlayerObjectives( player_index );
 
-        global_game_state-&gt;unit_manager-&gt;destroyPlayerUnits( player_index );
+        GameManager::disconnectPlayerCleanUp(player_index);
 
-        ResourceManagerReleaseFlagMessage releasemsg;
-        releasemsg.setFlagID(player-&gt;getFlag());
-        ResourceManager::releaseFlag(player-&gt;getFlag());
-
-        PlayerInterface::disconnectPlayerCleanup( player_index );
-
-        broadcastMessage(&amp;releasemsg, sizeof(releasemsg));
-
-        if ( sendalert )
-        {
-            SystemConnectAlert msg;
-            if ( cleandisconnect )
-            {
-                msg.set( player_index, _connect_alert_mesg_disconnect);
-            }
-            else
-            {
-                msg.set( player_index, _connect_alert_mesg_client_drop );
-            }
-
-            broadcastMessage(&amp;msg, sizeof(msg));
-        }
+//        if ( sendalert )
+//        {
+//            SystemConnectAlert msg;
+//            if ( cleandisconnect )
+//            {
+//                msg.set( player_index, _connect_alert_mesg_disconnect);
+//            }
+//            else
+//            {
+//                msg.set( player_index, _connect_alert_mesg_client_drop );
+//            }
+//
+//            broadcastMessage(&amp;msg, sizeof(msg));
+//        }
     }
 }
 

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -52,6 +52,7 @@
     static bool addClientToSendList( ClientSocket * client );
     static void cleanUpClientList();
     static void dropClient(Uint16 playerid);
+    static void removePlayerSocket(const Uint16 player_id);
 
     static void openSession();
     static void hostSession();
@@ -64,8 +65,6 @@
         
     static void sendRemaining();
     
-    static ClientSocket * getClientSocketByPlayerIndex ( Uint16 index );
-
     static std::string getIP(Uint16 player_index);
 
 protected:

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -28,9 +28,9 @@
 UnitSync::UnitSync(ClientSocket * c)
     : client(c), count(0), unitid(0), unitstosync(0), lastunit(0)
 {
-    unitstosync = global_game_state-&gt;unit_manager-&gt;getTotalUnitCount();
+    unitstosync = UnitInterface::getTotalUnitCount();
     if ( unitstosync ) {
-        lastunit = global_game_state-&gt;unit_manager-&gt;getUnits().rbegin()-&gt;first;
+        lastunit = UnitInterface::getUnits()-&gt;rbegin()-&gt;first;
     }
 }
 
@@ -47,9 +47,9 @@
 
 bool UnitSync::sendNextUnit()
 {
-    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
-    UnitInterface::Units::const_iterator i = units.lower_bound(unitid);
-    if(i == units.end() || i-&gt;first &gt; lastunit ) {
+    const UnitInterface::Units* units = UnitInterface::getUnits();
+    UnitInterface::Units::const_iterator i = units-&gt;lower_bound(unitid);
+    if(i == units-&gt;end() || i-&gt;first &gt; lastunit ) {
         return false;
     }
     

Modified: trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -17,80 +17,112 @@
 */
 
 #include &quot;Classes/PlacementMatrix.hpp&quot;
+#include &quot;Types/iXY.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 
-void PlacementMatrix::reset( iXY ini_map_loc )
+enum { _placement_state_base_case,
+       _placement_state_top_run,
+       _placement_state_right_run,
+       _placement_state_bottom_run,
+       _placement_state_left_run
+     };
+
+static unsigned char placement_state = 0;
+static long run_length = 0;
+static long run_counter = 0;
+static iXY* current_offset = 0;
+static iXY* current_loc = 0;
+static iXY* ini_loc = 0;
+
+void PlacementMatrix::reset( const iXY&amp; ini_map_loc )
 {
-    ini_loc = ini_map_loc;
-    current_offset = iXY( 0, 0 );
-    current_loc =	ini_loc;
+    if ( ! ini_loc )
+    {
+        ini_loc = new iXY();
+    }
+    *ini_loc = ini_map_loc;
+
+    if ( ! current_offset )
+    {
+        current_offset = new iXY();
+    }
+    current_offset-&gt;zero();
+
+    if ( ! current_loc )
+    {
+        current_loc = new iXY();
+    }
+    *current_loc = ini_map_loc;
+
     run_length = 0;
     run_counter = 0;
     placement_state = _placement_state_base_case;
 }
 
-bool PlacementMatrix::verifyLocation( iXY &amp;loc )
+bool verifyLocation( iXY &amp;loc )
 {
     long x_offset, y_offset;
     iXY succ;
     unsigned long direction_index;
 
     if ( MapInterface::getMovementValue(loc) &gt;= 0xFF
-        || global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(loc) == true )
+        || UnitInterface::unitOccupiesLoc(loc) == true )
     {
         return(false);
     }
 
 
-    for ( direction_index = 0; direction_index &lt; 9; direction_index++ ) {
-        switch( direction_index ) {
-        case 0: {
-                x_offset =  0; y_offset =  0;
-            }
-            break;
-        case 1: {
-                x_offset =  1; y_offset =  0;
-            }
-            break;
-        case 2: {
-                x_offset =  1; y_offset = -1;
-            }
-            break;
-        case 3: {
-                x_offset =  0; y_offset = -1;
-            }
-            break;
-        case 4: {
-                x_offset = -1; y_offset = -1;
-            }
-            break;
-        case 5: {
-                x_offset = -1; y_offset =  0;
-            }
-            break;
-        case 6: {
-                x_offset = -1; y_offset =  1;
-            }
-            break;
-        case 7: {
-                x_offset =  0; y_offset =  1;
-            }
-            break;
-        case 8: {
-                x_offset =  1; y_offset =  1;
-            }
-            break;
-        default:
-            assert(false);
-            return false;
+    for ( direction_index = 0; direction_index &lt; 9; direction_index++ )
+    {
+        switch( direction_index )
+        {
+            case 0: {
+                    x_offset =  0; y_offset =  0;
+                }
+                break;
+            case 1: {
+                    x_offset =  1; y_offset =  0;
+                }
+                break;
+            case 2: {
+                    x_offset =  1; y_offset = -1;
+                }
+                break;
+            case 3: {
+                    x_offset =  0; y_offset = -1;
+                }
+                break;
+            case 4: {
+                    x_offset = -1; y_offset = -1;
+                }
+                break;
+            case 5: {
+                    x_offset = -1; y_offset =  0;
+                }
+                break;
+            case 6: {
+                    x_offset = -1; y_offset =  1;
+                }
+                break;
+            case 7: {
+                    x_offset =  0; y_offset =  1;
+                }
+                break;
+            case 8: {
+                    x_offset =  1; y_offset =  1;
+                }
+                break;
+            default:
+                assert(false);
+                return false;
         } // ** switch
 
         succ.x = loc.x + (x_offset);
         succ.y = loc.y + (y_offset);
 
         if ( MapInterface::getMovementValue(succ) &lt; 0xFF
-             &amp;&amp; global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(succ) == false )
+             &amp;&amp; UnitInterface::unitOccupiesLoc(succ) == false )
         {
             return true;
         }
@@ -100,113 +132,136 @@
     return false;
 }
 
-
 bool PlacementMatrix::getNextEmptyLoc( iXY *loc )
 {
     bool end_cycle = false;
 
-    do {
-        switch( placement_state ) {
-        case _placement_state_base_case : {
-                placement_state = _placement_state_top_run;
-                current_offset.x -= 2;
-                current_offset.y -= 2;
-                current_loc = ini_loc + current_offset;
-                run_length += 4;
+    do
+    {
+        switch( placement_state )
+        {
+            case _placement_state_base_case : {
+                    placement_state = _placement_state_top_run;
+                    current_offset-&gt;x -= 2;
+                    current_offset-&gt;y -= 2;
+                    *current_loc = *ini_loc + *current_offset;
+                    run_length += 4;
 
-                if ( verifyLocation( ini_loc ) == true ) {
-                    *loc = ini_loc;
-                    return( true );
+                    if ( verifyLocation( *ini_loc ) == true ) {
+                        *loc = *ini_loc;
+                        return( true );
+                    }
+
                 }
+                break;
 
-            }
-            break;
-
-        case _placement_state_top_run : {
-                if ( run_counter &gt;= run_length ) {
+            case _placement_state_top_run :
+            {
+                if ( run_counter &gt;= run_length )
+                {
                     run_counter = 0;
                     placement_state = _placement_state_right_run;
-                } else
-                    if ( verifyLocation( current_loc ) == true ) {
-                        *loc = current_loc;
+                }
+                else if ( verifyLocation( *current_loc ) == true )
+                {
+                    *loc = *current_loc;
 
-                        run_counter += 2;
-                        current_loc.x += 2;
+                    run_counter += 2;
+                    current_loc-&gt;x += 2;
 
-                        return( true );
-                    } else {
-                        current_loc.x += 2;
-                        run_counter += 2;
-                    }
+                    return( true );
+                }
+                else
+                {
+                    current_loc-&gt;x += 2;
+                    run_counter += 2;
+                }
+                break;
             }
-            break;
 
-        case _placement_state_right_run : {
-                if ( run_counter &gt;= run_length ) {
+            case _placement_state_right_run :
+            {
+                if ( run_counter &gt;= run_length )
+                {
                     run_counter = 0;
                     placement_state = _placement_state_bottom_run;
-                } else
-                    if ( verifyLocation( current_loc ) == true ) {
-                        *loc = current_loc;
+                }
+                else if ( verifyLocation( *current_loc ) == true )
+                {
+                    *loc = *current_loc;
 
-                        run_counter += 2;
-                        current_loc.y += 2;
+                    run_counter += 2;
+                    current_loc-&gt;y += 2;
 
-                        return( true );
-                    } else {
-                        current_loc.y += 2;
-                        run_counter += 2;
-                    }
+                    return( true );
+
+                }
+                else
+                {
+                    current_loc-&gt;y += 2;
+                    run_counter += 2;
+                }
+                break;
             }
-            break;
 
-        case _placement_state_bottom_run : {
-                if ( run_counter &gt;= run_length ) {
+            case _placement_state_bottom_run :
+            {
+                if ( run_counter &gt;= run_length )
+                {
                     run_counter = 0;
                     placement_state = _placement_state_left_run;
-                } else
-                    if ( verifyLocation( current_loc ) == true ) {
-                        *loc = current_loc;
+                }
+                else if ( verifyLocation( *current_loc ) == true )
+                {
+                    *loc = *current_loc;
 
-                        run_counter += 2;
-                        current_loc.x -= 2;
+                    run_counter += 2;
+                    current_loc-&gt;x -= 2;
 
-                        return( true );
-                    } else {
-                        current_loc.x -= 2;
-                        run_counter += 2;
-                    }
+                    return( true );
+
+                }
+                else
+                {
+                    current_loc-&gt;x -= 2;
+                    run_counter += 2;
+                }
+                break;
             }
-            break;
 
-        case _placement_state_left_run : {
-                if ( run_counter &gt;= run_length ) {
-                    if ( current_offset.x &gt; -50 ) {
+            case _placement_state_left_run :
+            {
+                if ( run_counter &gt;= run_length )
+                {
+                    if ( current_offset-&gt;x &gt; -50 )
+                    {
                         run_counter = 0;
-                        current_offset.x -= 2;
-                        current_offset.y -= 2;
-                        current_loc = ini_loc + current_offset;
+                        current_offset-&gt;x -= 2;
+                        current_offset-&gt;y -= 2;
+                        *current_loc = *ini_loc + *current_offset;
                         run_length += 4;
                         placement_state = _placement_state_top_run;
-                    } else {
+                    }
+                    else
+                    {
                         return( false );
                     }
-                } else
-                    if ( verifyLocation( current_loc ) == true ) {
-                        *loc = current_loc;
+                }
+                else if ( verifyLocation( *current_loc ) == true )
+                {
+                    *loc = *current_loc;
 
-                        run_counter += 2;
-                        current_loc.y -= 2;
+                    run_counter += 2;
+                    current_loc-&gt;y -= 2;
 
-                        return( true );
-                    } else {
-                        current_loc.y -= 2;
-                        run_counter += 2;
-                    }
+                    return( true );
+
+                } else {
+                    current_loc-&gt;y -= 2;
+                    run_counter += 2;
+                }
+                break;
             }
-            break;
-
-
         } // ** switch
     } while( end_cycle == false );
 

Modified: trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -18,38 +18,13 @@
 #ifndef _PLACEMENTMATRIX_HPP
 #define _PLACEMENTMATRIX_HPP
 
-#include &quot;Types/iXY.hpp&quot;
+class iXY;
 
 class PlacementMatrix
 {
-protected:
-    enum { _placement_state_base_case,
-           _placement_state_top_run,
-           _placement_state_right_run,
-           _placement_state_bottom_run,
-           _placement_state_left_run
-         };
-
-    unsigned char placement_state;
-    long run_length;
-    long run_counter;
-    iXY current_offset;
-    iXY current_loc;
-    iXY ini_loc;
-
-    bool verifyLocation( iXY &amp;loc );
-
-protected:
-    //long level;
-    //long direction;
-    //iXY ini_loc;
-
 public:
-    void reset( iXY ini_map_loc );
-
-    bool getNextEmptyLoc( iXY *loc );
-
-
+    static void reset( const iXY&amp; ini_map_loc );
+    static bool getNextEmptyLoc( iXY *loc );
 };
 
 #endif // ** _PLACEMENTMATRIX_HPP

Modified: trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -30,7 +30,7 @@
     deselect();
     unit_list.clear();
 
-    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(unit_list, point,
+    UnitBucketArray::queryPlayerUnitsAt(unit_list, point,
                                         PlayerInterface::getLocalPlayerIndex());
 
     select();
@@ -45,7 +45,7 @@
 {
     deselect();
 
-    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(unit_list, point,
+    UnitBucketArray::queryPlayerUnitsAt(unit_list, point,
                                         PlayerInterface::getLocalPlayerIndex());
 
     select();
@@ -59,7 +59,7 @@
 bool SelectionList::selectBounded(iRect bounds, bool addunits)
 {
     std::vector&lt;UnitID&gt; tempunits;
-    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(tempunits, bounds,
+    UnitBucketArray::queryPlayerUnitsInWorldRect(tempunits, bounds,
                                        PlayerInterface::getLocalPlayerIndex() );
     
     if ( ! tempunits.size() )
@@ -96,17 +96,17 @@
 
     std::vector&lt;UnitID&gt; temp_list;
 
-    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(temp_list, point, player_id);
+    UnitBucketArray::queryPlayerUnitsAt(temp_list, point, player_id);
     
     if ( temp_list.empty() )
         return false;
         
-    unsigned char t=global_game_state-&gt;unit_manager-&gt;getUnit(temp_list[0])-&gt;unit_state.unit_type;
+    unsigned char t=UnitInterface::getUnit(temp_list[0])-&gt;unit_state.unit_type;
     temp_list.clear();
     
     iRect wr;
     WorldViewInterface::getViewWindow(&amp;wr);
-    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(temp_list, wr, player_id );
+    UnitBucketArray::queryPlayerUnitsInWorldRect(temp_list, wr, player_id );
     
     int p = temp_list.size();
     if ( !p )
@@ -114,7 +114,7 @@
 
     p--;
     do {
-        if ( global_game_state-&gt;unit_manager-&gt;getUnit(temp_list[p])-&gt;unit_state.unit_type == t)
+        if ( UnitInterface::getUnit(temp_list[p])-&gt;unit_state.unit_type == t)
             unit_list.push_back(temp_list[p]);
     } while (p--);
 
@@ -140,7 +140,7 @@
     id_list_size = unit_list.size();
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
+        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = true;
         }
@@ -157,7 +157,7 @@
     id_list_size = unit_list.size();
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
+        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = false;
         }
@@ -177,7 +177,7 @@
     deselect();
     do {
 
-        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ unit_cycle_index ] );
+        unit = UnitInterface::getUnit( unit_list[ unit_cycle_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = true;
         }
@@ -215,7 +215,7 @@
     Unit *unit;
 
     if ( unit_list.size() &gt; 0 ) {
-        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ 0 ] );
+        unit = UnitInterface::getUnit( unit_list[ 0 ] );
         if( unit != 0 ) {
             return unit-&gt;unit_state.unit_type;
         } else {
@@ -239,7 +239,7 @@
     }
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
+        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             return;
         }

Modified: trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -156,7 +156,7 @@
     }
 	
 	//Unit * unit = UnitInterface::queryNonPlayerUnitAtWorld( loc, PlayerInterface::getLocalPlayerIndex() );
-    Unit * unit = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitAtMapLoc( map_loc );
+    Unit * unit = UnitBucketArray::queryUnitAtMapLoc( map_loc );
 	if ( unit )
 	{
         if ( unit-&gt;player-&gt;getID() == PlayerInterface::getLocalPlayerIndex() )
@@ -322,9 +322,9 @@
 void
 WorldInputCmdProcessor::jumpLastAttackedUnit()
 {
-    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
-    for(UnitInterface::Units::const_iterator i = units.begin();
-            i != units.end(); ++i)
+    const UnitInterface::Units* units = UnitInterface::getUnits();
+    for(UnitInterface::Units::const_iterator i = units-&gt;begin();
+            i != units-&gt;end(); ++i)
     {
         Unit* unit = i-&gt;second;
         if(unit-&gt;player != PlayerInterface::getLocalPlayer())
@@ -446,7 +446,8 @@
 WorldInputCmdProcessor::keyboardInputModeChatMesg()
 {
     char chat_string[256];
-    if (getConsoleInputString(chat_string)) {
+    if (getConsoleInputString(chat_string))
+    {
         if(strcmp(chat_string, &quot;&quot;) != 0)
         {
             lua_State *L = ScriptManager::getLuavm();
@@ -456,14 +457,14 @@
                 lua_pushstring(L, chat_string);
                 if ( lua_pcall(L, 1, 0, 0) != 0 )
                 {
-                    LOGGER.warning(&quot;error running function `onChatMessageEntered': %s\n&quot;,lua_tostring(L, -1));
+                    LOGGER.warning(&quot;error running function 'onUserMessage': %s\n&quot;,lua_tostring(L, -1));
                 }
             }
             else
             {
                 lua_pop(L, 1);
+                ChatInterface::sendCurrentMessage( chat_string );
             }
-            ChatInterface::sendCurrentMessage( chat_string );
         }
         keyboard_input_mode = _keyboard_input_mode_command;
         ConsoleInterface::setInputStringStatus(false);             
@@ -621,12 +622,7 @@
 
     if (event.event == MouseEvent::EVENT_DOWN)
     {
-        if ( (!selection_box_active)
-             &amp;&amp; ( manual_fire_state == true
-//                 || KeyboardInterface::getKeyState( SDLK_LCTRL )
-//                 || KeyboardInterface::getKeyState( SDLK_RCTRL )
-                )
-           )
+        if ( (!selection_box_active) &amp;&amp; (manual_fire_state == true) )
         {
             sendManualFireCommand( world_pos );
             return;
@@ -739,7 +735,7 @@
                 current_selection_list_index = 0xFFFF;
                 if (working_list.unit_list.size() &gt; 0)
                 {
-                    Unit *unit = global_game_state-&gt;unit_manager-&gt;getUnit(
+                    Unit *unit = UnitInterface::getUnit(
                             working_list.unit_list[0]);
                     if(unit)
                         unit-&gt;soundSelected();
@@ -755,10 +751,7 @@
                 break;
 
             case _cursor_enemy_unit:
-                 if ( manual_fire_state != true
-//                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_LCTRL )
-//                        &amp;&amp; !KeyboardInterface::getKeyState( SDLK_RCTRL )
-                     )
+                 if ( manual_fire_state != true )
                  {
                      sendAttackCommand(world_pos);
                  }
@@ -803,7 +796,7 @@
     iXY map_pos;
     PlacementMatrix matrix;
 
-    LOGGER.warning(&quot;Wants to move to world %d,%d&quot;, world_pos.x, world_pos.y);
+//    LOGGER.warning(&quot;Wants to move to world %d,%d&quot;, world_pos.x, world_pos.y);
     unsigned long id_list_index;
     size_t id_list_size;
     Unit *unit_ptr;
@@ -816,21 +809,21 @@
         return;
 
     MapInterface::pointXYtoMapXY( world_pos, &amp;map_pos );
-    LOGGER.warning(&quot;Wants to move to map %d,%d&quot;, map_pos.x, map_pos.y);
+//    LOGGER.warning(&quot;Wants to move to map %d,%d&quot;, map_pos.x, map_pos.y);
     matrix.reset( map_pos );
 
     NetMessageEncoder encoder(true);
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit(working_list.unit_list[ id_list_index ]);
+        unit_ptr = UnitInterface::getUnit(working_list.unit_list[ id_list_index ]);
         if ( unit_ptr != 0 ) {
             if ( unit_ptr-&gt;unit_state.select == true ) {
                 matrix.getNextEmptyLoc( &amp;map_pos );
-                LOGGER.warning(&quot;Unit %d move from %d, %d to %d,%d&quot;,
-                               unit_ptr-&gt;id,
-                               unit_ptr-&gt;unit_state.location.x/32,
-                               unit_ptr-&gt;unit_state.location.y/32,
-                               map_pos.x, map_pos.y);
+//                LOGGER.warning(&quot;Unit %d move from %d, %d to %d,%d&quot;,
+//                               unit_ptr-&gt;id,
+//                               unit_ptr-&gt;unit_state.location.x/32,
+//                               unit_ptr-&gt;unit_state.location.y/32,
+//                               map_pos.x, map_pos.y);
                 comm_mesg.comm_request.setHeader(unit_ptr-&gt;id);
 
                 comm_mesg.comm_request.setMoveToLoc( map_pos );
@@ -860,7 +853,7 @@
 
     if ( working_list.isSelected() == true )
     {
-        target_ptr = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitAtWorld(world_pos,
+        target_ptr = UnitBucketArray::queryNonPlayerUnitAtWorld(world_pos,
                                         PlayerInterface::getLocalPlayerIndex());
 
         if ( ! target_ptr ) // there was nothing there
@@ -877,7 +870,7 @@
 
         for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ )
         {
-            unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit( working_list.unit_list[ id_list_index ] );
+            unit_ptr = UnitInterface::getUnit( working_list.unit_list[ id_list_index ] );
             if ( unit_ptr != 0 )
             {
                 if ( unit_ptr-&gt;unit_state.select == true )
@@ -913,7 +906,7 @@
         NetMessageEncoder encoder(true);
 
         for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-            unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit( working_list.unit_list[ id_list_index ] );
+            unit_ptr = UnitInterface::getUnit( working_list.unit_list[ id_list_index ] );
 
             if ( unit_ptr != 0 ) {
                 if ( unit_ptr-&gt;unit_state.select == true ) {
@@ -936,7 +929,7 @@
 void
 WorldInputCmdProcessor::sendAllianceRequest(const iXY&amp; world_pos, bool make_break)
 {
-    Unit *target_ptr = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitAtWorld(world_pos,
+    Unit *target_ptr = UnitBucketArray::queryNonPlayerUnitAtWorld(world_pos,
                                         PlayerInterface::getLocalPlayerIndex());
 
     if ( target_ptr )
@@ -975,21 +968,28 @@
 WorldInputCmdProcessor::getConsoleInputString(char *input_string)
 {
     int key_char;
-    while (KeyboardInterface::getChar(key_char)) {
+    while (KeyboardInterface::getChar(key_char))
+    {
         // Check for extended code.
-        if (key_char == 0) {
-            if (KeyboardInterface::getChar(key_char)) {
+        if (key_char == 0)
+        {
+            if (KeyboardInterface::getChar(key_char))
+            {
                 ConsoleInterface::addExtendedChar(key_char);
-                if ((key_char == SDLK_RETURN) ) {
+                if ((key_char == SDLK_RETURN) )
+                {
                     enter_key_hit_count++;
-                    if (enter_key_hit_count == 2) {
+                    if (enter_key_hit_count == 2)
+                    {
 			KeyboardInterface::setTextMode(false);
                         ConsoleInterface::getInputString( input_string );
                         return true;
                     }
                 }
             }
-        } else {
+        }
+        else
+        {
             ConsoleInterface::addChar(key_char);
         }
 
@@ -1113,7 +1113,7 @@
     // Vote direction
     bool firstunit = true;
     for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
-        Unit* unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit(working_list.unit_list[id_list_index]);
+        Unit* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
 
         if(unit_ptr == 0)
             continue;

Modified: trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -23,5 +23,5 @@
 
 GlobalGameState::GlobalGameState()
         : tile_set(0), world_map(0), spawn_list(0),
-          unit_manager(0), unit_profile_interface(0)
+          unit_profile_interface(0)
 {}

Modified: trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -23,7 +23,6 @@
 class WorldMap;
 class SpawnList;
 class UnitProfileInterface;
-class UnitInterface;
 
 class GlobalGameState
 {
@@ -33,7 +32,6 @@
     TileSet * tile_set;
     WorldMap * world_map;
     SpawnList * spawn_list;
-    UnitInterface * unit_manager;
     UnitProfileInterface * unit_profile_interface;
 };
 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -276,9 +276,7 @@
 {
     PlayerInterface::initialize(gameconfig-&gt;maxplayers); // can pas
 
-    UnitInterface * uin = new UnitInterface();
-    uin-&gt;initialize(gameconfig-&gt;maxunits); // uses map
-    global_game_state-&gt;unit_manager = uin;
+    UnitInterface::initialize(gameconfig-&gt;maxunits);
 
     PathScheduler::initialize(); // uses map
     PowerUpInterface::resetLogic(); // depends on map loaded
@@ -298,10 +296,7 @@
 {
     PlayerInterface::reset();
 
-    if ( global_game_state-&gt;unit_manager )
-    {
-        global_game_state-&gt;unit_manager-&gt;reset();
-    }
+    UnitInterface::reset();
 
     PathScheduler::initialize();
     PowerUpInterface::resetLogic();
@@ -316,13 +311,8 @@
 {
     PlayerInterface::cleanUp();
 
-    if ( global_game_state-&gt;unit_manager )
-    {
-        delete global_game_state-&gt;unit_manager;
-        global_game_state-&gt;unit_manager = 0;
-    }
-
-//    UnitInterface::cleanUp();
+    UnitInterface::cleanUp();
+    
     PathScheduler::cleanUp();
     //ObjectiveInterface::cleanUp();
 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -34,20 +34,27 @@
 ChatMesgRequest ChatInterface::current_chat_mesg;
 void (* ChatInterface::addChatString)( const char *message_text ) = 0;
 
-void ChatInterface::chatMessageRequest(const NetMessage* message)
+void ChatInterface::chatMessageRequest(const NetPacket* packet)
 {
     bool post_on_server = false;
     ChatMesg chat_mesg;
-    const ChatMesgRequest* chat_request = (const ChatMesgRequest*) message;
+    const ChatMesgRequest* chat_request = (const ChatMesgRequest*) packet-&gt;getNetMessage();
 
-    if(chat_request-&gt;message_scope != _chat_mesg_scope_server
-            &amp;&amp; chat_request-&gt;getSourcePlayerIndex() 
-            &gt;= PlayerInterface::getMaxPlayers())
+    if (   chat_request-&gt;message_scope != _chat_mesg_scope_server
+        &amp;&amp; chat_request-&gt;getSourcePlayerIndex() != packet-&gt;fromPlayer )
     {
-        LOGGER.warning(&quot;Invalid chatMessageRequest&quot;);
+        LOGGER.warning(&quot;Chat message cheat from player %d&quot;, packet-&gt;fromPlayer);
         return;
     }
 
+    if (   chat_request-&gt;message_scope == _chat_mesg_scope_server
+        &amp;&amp; NetworkState::getNetworkStatus() == _network_state_server
+        &amp;&amp; packet-&gt;fromClient )
+    {
+        LOGGER.warning(&quot;Chat server message cheat from player %d&quot;, packet-&gt;fromPlayer);
+        return;
+    }
+
     chat_mesg.setSourcePlayerIndex(chat_request-&gt;getSourcePlayerIndex());
     chat_mesg.message_scope = chat_request-&gt;message_scope;
     snprintf(chat_mesg.message_text, sizeof(chat_mesg.message_text), &quot;%s&quot;,
@@ -55,8 +62,37 @@
 
     if( chat_request-&gt;message_scope == _chat_mesg_scope_all )
     {
-        NetworkServer::broadcastMessage(&amp;chat_mesg, sizeof(ChatMesg));
-        post_on_server = true;
+            lua_State *L = ScriptManager::getLuavm();
+            lua_getglobal(L, &quot;serverHandleMessage&quot;);
+            if ( lua_isfunction(L, -1) )
+            {
+                lua_pushstring(L, chat_mesg.message_text);
+                lua_pushinteger(L, packet-&gt;fromPlayer );
+                if ( lua_pcall(L, 2, 1, 0) != 0 )
+                {
+                    LOGGER.warning(&quot;error running function 'serverHandleMessage': %s\n&quot;,lua_tostring(L, -1));
+                }
+
+                if ( lua_isboolean(L,-1) )
+                {
+                    bool want_broadcast = lua_toboolean(L, -1);
+                    lua_pop(L,1);
+                    if ( want_broadcast )
+                    {
+                        NetworkServer::broadcastMessage(&amp;chat_mesg, sizeof(ChatMesg));
+                        post_on_server = true;
+                    }
+                }
+            }
+            else
+            {
+                lua_pop(L, 1);
+                NetworkServer::broadcastMessage(&amp;chat_mesg, sizeof(ChatMesg));
+                post_on_server = true;
+            }
+
+//        NetworkServer::broadcastMessage(&amp;chat_mesg, sizeof(ChatMesg));
+//        post_on_server = true;
     }
     else if( chat_request-&gt;message_scope == _chat_mesg_scope_alliance )
     {
@@ -143,10 +179,10 @@
     }
 }
 
-void ChatInterface::chatMessage(const NetMessage* message)
+void ChatInterface::chatMessage(const NetPacket* packet)
 {
     unsigned short local_player_index;
-    const ChatMesg *chat_mesg = (const ChatMesg*) message;
+    const ChatMesg *chat_mesg = (const ChatMesg*) packet-&gt;getNetMessage();
 
     if(chat_mesg-&gt;message_scope != _chat_mesg_scope_server 
             &amp;&amp; chat_mesg-&gt;getSourcePlayerIndex() 
@@ -195,20 +231,21 @@
             player_state-&gt;getName().c_str(), chat_mesg-&gt;message_text );
 }
 
-void ChatInterface::processChatMessages(const NetMessage* message)
+void ChatInterface::processChatMessages(const NetPacket* packet)
 {
-    switch(message-&gt;message_id) {
+    switch(packet-&gt;getNetMessage()-&gt;message_id) {
         case _net_message_id_chat_mesg_req:
-            chatMessageRequest(message);
+            chatMessageRequest(packet);
             break;
 
         case _net_message_id_chat_mesg:
-            chatMessage(message);
+            chatMessage(packet);
             break;
 
         default:
             LOGGER.warning(&quot;Received unknown chat message (id %d-%d)&quot;,
-                    message-&gt;message_class, message-&gt;message_id);
+                            packet-&gt;getNetMessage()-&gt;message_class,
+                            packet-&gt;getNetMessage()-&gt;message_id);
     }
 }
 
@@ -302,3 +339,56 @@
         sendCurrentMessage(msg);
     }
 }
+
+void
+ChatInterface::say(const char *message)
+{
+    ChatMesgRequest cmsg;
+    cmsg.setSourcePlayerIndex(PlayerInterface::getLocalPlayerIndex());
+    strncpy( cmsg.message_text, message, 149 );
+    cmsg.message_text[ 149 ] = 0;
+    cmsg.message_scope = _chat_mesg_scope_all;
+    NetworkClient::sendMessage(&amp;cmsg, sizeof(cmsg));
+}
+
+void
+ChatInterface::teamsay(const char* message)
+{
+    ChatMesgRequest cmsg;
+    cmsg.setSourcePlayerIndex(PlayerInterface::getLocalPlayerIndex());
+    strncpy( cmsg.message_text, message, 149 );
+    cmsg.message_text[ 149 ] = 0;
+    cmsg.message_scope = _chat_mesg_scope_alliance;
+    NetworkClient::sendMessage(&amp;cmsg, sizeof(cmsg));
+}
+
+void
+ChatInterface::serversay(const char* message)
+{
+    ChatMesgRequest cmsg;
+    cmsg.setSourcePlayerIndex(PlayerInterface::getLocalPlayerIndex());
+    strncpy( cmsg.message_text, message, 149 );
+    cmsg.message_text[ 149 ] = 0;
+    cmsg.message_scope = _chat_mesg_scope_server;
+//    NetworkServer::broadcastMessage(&amp;cmsg, sizeof(cmsg));
+    NetworkClient::sendMessage(&amp;cmsg, sizeof(cmsg));
+}
+
+void
+ChatInterface::serversayTo(const Uint16 player, const char* message)
+{
+    if ( player == PlayerInterface::getLocalPlayerIndex() )
+    {
+        ConsoleInterface::postMessage(Color::unitAqua, false, 0, &quot;Server: %s&quot;, message );
+    }
+    else
+    {
+        ChatMesgRequest cmsg;
+        cmsg.setSourcePlayerIndex(PlayerInterface::getLocalPlayerIndex());
+        strncpy( cmsg.message_text, message, 149 );
+        cmsg.message_text[ 149 ] = 0;
+        cmsg.message_scope = _chat_mesg_scope_server;
+        NetworkServer::sendMessage(player, &amp;cmsg, sizeof(cmsg));
+    }
+}
+

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/ChatInterface.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -19,6 +19,8 @@
 #define _CHATINTERFACE_HPP
 
 #include &quot;Classes/Network/ChatNetMessage.hpp&quot;
+#include &quot;Core/CoreTypes.hpp&quot;
+class NetPacket;
 
 class ChatInterface
 {
@@ -26,12 +28,17 @@
     static ChatMesgRequest current_chat_mesg;
     static void (* addChatString)( const char *message_text );
 
-    static void chatMessageRequest(const NetMessage* message);
-    static void chatMessage(const NetMessage* message);
+    static void chatMessageRequest(const NetPacket* packet);
+    static void chatMessage(const NetPacket* packet);
 
 public:
-    static void processChatMessages(const NetMessage* message);
+    static void processChatMessages(const NetPacket* packet);
 
+    static void say(const char * message);
+    static void teamsay(const char * message);
+    static void serversay(const char * message);
+    static void serversayTo(const Uint16 player, const char * message);
+
     // ** ChatView Interface Methods
     static void setNewMessageCallBack( void (* addStringCallBack)( const char *message_text ) );
     static void setMessageScopeAll();

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -148,13 +148,12 @@
                 break;
             }
             case ServerCommand::MAPCHANGE:
-                if(!MapsManager::existsMap(command.argument)) {
+                if ( ! GameManager::changeMap(command.argument.c_str()) )
+                {
                     std::cout &lt;&lt; &quot;map '&quot; &lt;&lt; command.argument
-                        &lt;&lt; &quot;' doesn't exist.&quot; &lt;&lt; std::endl;
+                              &lt;&lt; &quot;' doesn't exist.&quot; &lt;&lt; std::endl;
                     break;
                 }
-            
-                GameControlRulesDaemon::forceMapChange(command.argument);
                 std::cout &lt;&lt; &quot;Preparing mapchange...&quot; &lt;&lt; std::endl;
                 break;
             case ServerCommand::KICK:
@@ -166,12 +165,12 @@
                     std::cout &lt;&lt; &quot;Unknown player.&quot; &lt;&lt; std::endl;
                     break;
                 }
-                NetworkServer::dropClient(id);
+                GameManager::kickPlayer(id);
                 break;
             }
             case ServerCommand::ADDBOT:
             {
-                Uint16 botid = BotManager::addBot();
+                Uint16 botid = GameManager::addBot();
                 if ( botid != 0xffff )
                 {
                     std::cout &lt;&lt; &quot;Added bot with player id &quot; &lt;&lt; botid &lt;&lt; std::endl;
@@ -179,7 +178,7 @@
                 break;
             }
             case ServerCommand::REMOVEBOTS:
-                BotManager::removeAllBots();
+                GameManager::removeAllBots();
                 break;
         }
         commandqueue.pop();

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -104,6 +104,7 @@
 //-----------------------------------------------------------------
 void GameControlRulesDaemon::setStateServerLoadingMap()
 {
+    map_cycle_fsm_server_endgame_timer.changePeriod( 0.0f );
     GameControlRulesDaemon::map_cycle_fsm_server_state = _map_cycle_server_state_cycle_next_map;
 }
 //-----------------------------------------------------------------
@@ -436,10 +437,7 @@
             }
             break;
         case _map_cycle_client_state_in_progress:
-//            if ( global_game_state-&gt;unit_manager )
-//            {
-                global_game_state-&gt;unit_manager-&gt;updateUnitStatus();
-//            }
+            UnitInterface::updateUnitStatus();
 
             ProjectileInterface::updateStatus();
             ObjectiveInterface::updateObjectiveStatus();
@@ -483,7 +481,6 @@
                 NetworkServer::broadcastMessage(&amp;view_control, sizeof(SystemViewControl));
 
                 map_cycle_fsm_server_endgame_timer.changePeriod( _MAP_CYCLE_ENDGAME_WAIT_PERIOD );
-                map_cycle_fsm_server_endgame_timer.reset();
 
                 map_cycle_fsm_server_state = _map_cycle_server_state_cycle_next_map;
             }
@@ -568,7 +565,7 @@
 
         case _map_cycle_server_state_respawn_players :
             {
-                if ( ! global_game_state-&gt;unit_manager )
+                if ( ! UnitInterface::getUnits() )
                 {
                     ConsoleInterface::postMessage(Color::white, false, 0, &quot;Reinitializing game logic.&quot;);
                     global_engine_state-&gt;game_manager-&gt;reinitializeGameLogic();
@@ -606,10 +603,7 @@
             break;
 
         case _map_cycle_server_state_in_progress:
-//            if ( global_game_state-&gt;unit_manager )
-//            {
-                global_game_state-&gt;unit_manager-&gt;updateUnitStatus();
-//            }
+            UnitInterface::updateUnitStatus();
 
             ProjectileInterface::updateStatus();
             ObjectiveInterface::updateObjectiveStatus();
@@ -714,7 +708,7 @@
             for ( unsigned short player = 0; player &lt; PlayerInterface::getMaxPlayers(); player++ )
             {
                 if ( PlayerInterface::getPlayer(player)-&gt;getStatus() == _player_state_active
-                     &amp;&amp; global_game_state-&gt;unit_manager-&gt;getUnitCount( player ) &gt; 0 )
+                     &amp;&amp; UnitInterface::getPlayerUnitCount( player ) &gt; 0 )
                 {
                     players_alive++;
                 }
@@ -744,7 +738,7 @@
         for ( unsigned short player = 0; player &lt; PlayerInterface::getMaxPlayers(); player++ )
         {
             if ( PlayerInterface::getPlayer(player)-&gt;getStatus() == _player_state_active
-                 &amp;&amp; global_game_state-&gt;unit_manager-&gt;getUnitCount( player ) == 0 )
+                 &amp;&amp; UnitInterface::getPlayerUnitCount( player ) == 0 )
             {
                 GameManager::spawnPlayer(player);
             }

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -48,7 +48,6 @@
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
 
 #include &quot;Classes/ScreenSurface.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Classes/WorldInputCmdProcessor.hpp&quot;
 #include &quot;Classes/SpriteSorter.hpp&quot;
 #include &quot;Classes/Network/ClientConnectDaemon.hpp&quot;
@@ -100,8 +99,11 @@
 #include &quot;Util/FileSystem.hpp&quot;
 
 #include &quot;Bot/Bot.hpp&quot;
+#include &quot;Bot/BotManager.hpp&quot;
 
 #include &quot;Classes/SpawnList.hpp&quot;
+#include &quot;Resources/ResourceManager.hpp&quot;
+#include &quot;Resources/ResourceManagerMessages.hpp&quot;
 
 #define _MAX_INITIALIZE_PROCS (10)
 #define _MAX_DEDICATED_INITIALIZE_PROCS (8)
@@ -230,7 +232,7 @@
 }
 
 // ******************************************************************
-void GameManager::spawnPlayer( Uint16 player )
+void GameManager::spawnPlayer( const Uint16 player )
 {
     global_engine_state-&gt;sound_manager-&gt;stopTankIdle();
 
@@ -239,20 +241,19 @@
 
     PlayerInterface::spawnPlayer( player, spawn_point );
 
-    //** Change the location of the view camera to the spawn point **
-    iXY world_loc;
-    MapInterface::mapXYtoPointXY( spawn_point, &amp;world_loc );
-    if ( PlayerInterface::getLocalPlayerIndex() == player )
+    global_engine_state-&gt;sound_manager-&gt;playTankIdle();
+}
+
+void GameManager::spawnPlayerAt( const Uint16 player, const iXY&amp; location )
+{
+    if (   location.x &gt;=0 &amp;&amp; location.y &gt;=0
+        &amp;&amp; location.x &lt; global_game_state-&gt;world_map-&gt;getWidth()
+        &amp;&amp; location.y &lt; global_game_state-&gt;world_map-&gt;getHeight() )
     {
-        WorldViewInterface::setCameraPosition( world_loc );
+        global_engine_state-&gt;sound_manager-&gt;stopTankIdle();
+        PlayerInterface::spawnPlayer( player, location );
+        global_engine_state-&gt;sound_manager-&gt;playTankIdle();
     }
-    else
-    {
-        SystemSetPlayerView set_view(world_loc.x, world_loc.y);
-        NetworkServer::sendMessage(player, &amp;set_view, sizeof(SystemSetPlayerView));
-    }
-
-    global_engine_state-&gt;sound_manager-&gt;playTankIdle();
 }
 
 void GameManager::respawnAllPlayers()
@@ -273,6 +274,82 @@
     }
 }
 
+void GameManager::disconnectPlayerCleanUp(const Uint16 player)
+{
+    destroyPlayerUnits(player);
+    disownPlayerObjectives(player);
+
+    PlayerState* player_st = PlayerInterface::getPlayer(player);
+
+    ResourceManagerReleaseFlagMessage releasemsg;
+    releasemsg.setFlagID(player_st-&gt;getFlag());
+    ResourceManager::releaseFlag(player_st-&gt;getFlag());
+    NetworkServer::broadcastMessage(&amp;releasemsg, sizeof(releasemsg));
+
+    PlayerInterface::disconnectPlayerCleanup( player );
+
+    SystemConnectAlert msg;
+    msg.set( player, _connect_alert_mesg_disconnect);
+    NetworkServer::broadcastMessage(&amp;msg, sizeof(msg));
+}
+
+void GameManager::kickPlayer(const Uint16 player)
+{
+    if ( player &lt; PlayerInterface::getMaxPlayers() )
+    {
+        if ( BotManager::isBot(player) )
+        {
+            BotManager::removeBot(player);
+        }
+        else
+        {
+            NetworkServer::removePlayerSocket(player);
+        }
+        disconnectPlayerCleanUp(player);
+    }
+}
+
+void GameManager::destroyPlayerUnits(const Uint16 player)
+{
+    UnitInterface::destroyPlayerUnits(player);
+}
+
+void GameManager::disownPlayerObjectives(const Uint16 player)
+{
+    if ( player &lt; PlayerInterface::getMaxPlayers() )
+    {
+        ObjectiveInterface::disownPlayerObjectives(player);
+    }
+}
+
+Uint16 GameManager::addBot()
+{
+    return BotManager::addBot();
+}
+
+void GameManager::removeAllBots()
+{
+    for (Uint16 player=0; player&lt;PlayerInterface::getMaxPlayers(); ++player)
+    {
+        if ( BotManager::isBot(player) )
+        {
+            BotManager::removeBot(player);
+            disconnectPlayerCleanUp(player);
+        }
+    }
+}
+
+bool GameManager::changeMap(const char* map_name)
+{
+    if ( !MapsManager::existsMap(map_name) )
+    {
+        return false;
+    }
+
+    GameControlRulesDaemon::forceMapChange(map_name);
+    return true;
+}
+
 // ******************************************************************
 
 void GameManager::netMessageSetView(const NetMessage* message)

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -38,23 +38,34 @@
 class GameManager
 {
 public:
+    // ** Game Rules Methods
+    static void spawnPlayer( const Uint16 player );
+    static void spawnPlayerAt( const Uint16 player, const iXY&amp; position );
+    static void respawnAllPlayers();
+
+    static void kickPlayer( const Uint16 player );
+    static void destroyPlayerUnits( const Uint16 player );
+    static void disownPlayerObjectives( const Uint16 player );
+
+    static Uint16 addBot();
+    static void removeAllBots();
+
+    static void exitNetPanzer();
+    static void quitNetPanzerGame();
+
+    static bool changeMap(const char * map_name);
+
+    static void disconnectPlayerCleanUp( const Uint16 player );
+
     static void dedicatedLoadGameMap(const char *map_file_path );
     static void loadGameMap(const char *map_file_path);
 
-    // ** Game Rules Methods
-    static void spawnPlayer( Uint16 player );
-    static void respawnAllPlayers();
-
     static void shutdownParticleSystems();
 
     static bool startClientGameSetup(const NetMessage* message, int *result_code);
     static void clientGameSetup();
     static ConnectMesgServerGameSettings* getServerGameSetup();
 
-    static void exitNetPanzer();
-
-    static void quitNetPanzerGame();
-
     static void setNetPanzerGameOptions();
 
     static void requestNetworkPing();

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -21,6 +21,9 @@
 
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
+#include &quot;Interfaces/MapInterface.hpp&quot;
+#include &quot;Interfaces/WorldViewInterface.hpp&quot;
+#include &quot;Classes/Network/SystemNetMessage.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Objectives/ObjectiveInterface.hpp&quot;
 #include &quot;Interfaces/ConsoleInterface.hpp&quot;
@@ -92,16 +95,6 @@
     mutex = 0;
 }
 
-void PlayerInterface::lock()
-{
-    SDL_mutexP(mutex);
-}
-
-void PlayerInterface::unLock()
-{
-    SDL_mutexV(mutex);
-}
-
 void PlayerInterface::setKill(PlayerState* by_player, PlayerState* on_player,
         UnitType unit_type)
 {
@@ -198,7 +191,7 @@
 int PlayerInterface::getActivePlayerCount()
 {
     unsigned long player_index;
-    int count = 0;;
+    int count = 0;
 
     for ( player_index = 0; player_index &lt; max_players; player_index++ ) {
         if ( player_lists[ player_index ].getStatus() == _player_state_active ) {
@@ -261,10 +254,22 @@
         SDL_mutexP(mutex);
         if ( player_lists[player_index].getStatus() != _player_state_free )
         {
-            global_game_state-&gt;unit_manager-&gt;spawnPlayerUnits( location,
+            UnitInterface::spawnPlayerUnits( location,
                                              player_index,
                                              player_lists[ player_index ].unit_config
                                            );
+            
+            iXY world_loc;
+            MapInterface::mapXYtoPointXY( location, &amp;world_loc );
+            if ( getLocalPlayerIndex() == player_index )
+            {
+                WorldViewInterface::setCameraPosition( world_loc );
+            }
+            else
+            {
+                SystemSetPlayerView set_view(world_loc.x, world_loc.y);
+                NetworkServer::sendMessage(player_index, &amp;set_view, sizeof(SystemSetPlayerView));
+            }
         } // ** if _player_state_active
         SDL_mutexV(mutex);
     }
@@ -651,7 +656,7 @@
 
         PlayerStateSync player_state_update(player_state-&gt;getNetworkPlayerState());
         
-		SDL_mutexV(mutex);
+        SDL_mutexV(mutex);
 
         NetworkServer::broadcastMessage(&amp;player_state_update, sizeof(PlayerStateSync));
     }

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -45,9 +45,6 @@
 
     static void cleanUp();
 
-    static void lock();
-    static void unLock();
-
     static void setKill(PlayerState* by_player, PlayerState* on_player,
             UnitType unit_type );
 

Modified: trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -92,7 +92,7 @@
         switch ( p-&gt;getNetMessage()-&gt;message_id )
         {
             case _net_message_id_term_unit_cmd:
-                global_game_state-&gt;unit_manager-&gt;processNetPacket(p);
+                UnitInterface::processNetPacket(p);
                 break;
             case _net_message_id_term_unit_gen:
             case _net_message_id_term_output_loc:
@@ -129,26 +129,16 @@
     }
 };
 
-class ToUnitHandler : public MessageClassHandler
-{
-public:
-    ToUnitHandler() {}
-    void handlePacket(const NetPacket *p)
-    {
-        global_game_state-&gt;unit_manager-&gt;processNetMessage(p-&gt;getNetMessage());
-    }
-};
-
 static ToMessageHandler systemhandler(&amp;GameManager::processSystemMessage);
 static ToPacketHandler serverconnecthandler(&amp;ServerConnectDaemon::processNetPacket);
 static ToMessageHandler clientconnecthandler(&amp;ClientConnectDaemon::processNetMessage);
 static ToMessageHandler resourcehandler(&amp;ResourceManager::processResourceMessage);
 static ToMessageHandler playerhandler(&amp;PlayerInterface::processNetMessage);
-static ToUnitHandler unithandler;
+static ToMessageHandler unithandler(&amp;UnitInterface::processNetMessage);
 static ToMessageHandler objectivehandler(&amp;ObjectiveInterface::processNetMessages);
-static ToMessageHandler gamecontrolhandler(GameControlRulesDaemon::processNetMessage);
+static ToMessageHandler gamecontrolhandler(&amp;GameControlRulesDaemon::processNetMessage);
 static ToMessageHandler poweruphandler(&amp;PowerUpInterface::processNetMessages);
-static ToMessageHandler chathandler(&amp;ChatInterface::processChatMessages);
+static ToPacketHandler chathandler(&amp;ChatInterface::processChatMessages);
 
 void
 MessageRouter::initialize(bool isServer)

Modified: trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -32,6 +32,7 @@
 #include &quot;Classes/Network/UnitNetMessage.hpp&quot;
 #include &quot;Classes/Network/ObjectiveNetMessage.hpp&quot;
 #include &quot;Classes/UnitMessageTypes.hpp&quot;
+#include &quot;Classes/PlacementMatrix.hpp&quot;
 
 Outpost::Outpost( ObjectiveID ID, iXY location, BoundBox area )
         : Objective( ID, location, area )
@@ -128,7 +129,7 @@
         if ( objective_state.occupation_status == _occupation_status_occupied )
         {
             std::vector&lt;UnitID&gt; playerunits;
-            global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(playerunits,
+            UnitBucketArray::queryPlayerUnitsInWorldRect(playerunits,
                                     bounding_area,
                                     objective_state.occupying_player-&gt;getID() );
 
@@ -137,17 +138,14 @@
                 return;
             }
 
-            global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitsInWorldRect(unitsInArea,
+            UnitBucketArray::queryNonPlayerUnitsInWorldRect(unitsInArea,
                                     bounding_area,
                                     objective_state.occupying_player-&gt;getID() );
 
         }
         else
         {
-            if ( global_game_state-&gt;unit_manager )
-            {
-                global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitsInWorldRect( unitsInArea, bounding_area );
-            }
+            UnitBucketArray::queryUnitsInWorldRect( unitsInArea, bounding_area );
         }
 
         if ( ! unitsInArea.empty() )
@@ -186,7 +184,7 @@
                 iXY gen_loc;
                 gen_loc = outpost_map_loc + unit_generation_loc;
 
-                unit = global_game_state-&gt;unit_manager-&gt;createUnit(unit_generation_type,
+                unit = UnitInterface::createUnit(unit_generation_type,
                         gen_loc, objective_state.occupying_player-&gt;getID());
 
                 if ( unit != 0 )
@@ -207,7 +205,7 @@
 
                     ai_command.setHeader( unit-&gt;id);
                     ai_command.setMoveToLoc( loc );
-                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;ai_command );
+                    UnitInterface::sendMessage( &amp;ai_command );
                 }
             } // ** if
         } // ** if

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -28,6 +28,7 @@
 #include &quot;Interfaces/ConsoleInterface.hpp&quot;
 #include &quot;Units/UnitProfileInterface.hpp&quot;
 
+#include &quot;Classes/PlacementMatrix.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
 #include &quot;Classes/Network/UnitNetMessage.hpp&quot;
@@ -61,7 +62,7 @@
 
         placement_matrix.getNextEmptyLoc( &amp;spawn_loc );
 
-        new_unit = global_game_state-&gt;unit_manager-&gt;createUnit(bonus_unit_type,
+        new_unit = UnitInterface::createUnit(bonus_unit_type,
                                              spawn_loc,
                                              unit-&gt;player-&gt;getID() );
 

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -19,7 +19,6 @@
 #include &quot;PowerUps/PowerUp.hpp&quot;
 #include &quot;Core/GlobalGameState.hpp&quot;
 
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
@@ -83,9 +82,9 @@
     if ( NetworkState::status == _network_state_server
          &amp;&amp; life_cycle_state == _power_up_lifecycle_state_active )
     {
-        if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(map_loc) )
+        if ( UnitInterface::unitOccupiesLoc(map_loc) )
         {
-            Unit * unit = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitAtMapLoc(map_loc);
+            Unit * unit = UnitBucketArray::queryUnitAtMapLoc(map_loc);
             if ( unit )
             {
                 onHit( unit );

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -117,7 +117,7 @@
 {
     UMesgSelfDestruct self_destruct;
     self_destruct.setHeader( unit_id );
-    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;self_destruct );
+    UnitInterface::sendMessage( &amp;self_destruct );
 }
 
 

Modified: trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Scripts/ScriptManager.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -73,8 +73,9 @@
 void
 ScriptManager::runFile(const char * runname, const char * filename)
 {
-    luaL_loadfile(luavm, filesystem::getRealName(filename).c_str());
-    int error=lua_pcall(luavm,0,0,0);
+//    luaL_loadfile(luavm, filesystem::getRealName(filename).c_str());
+//    int error=lua_pcall(luavm,0,0,0);
+    int error = luaL_dofile(luavm, filesystem::getRealName(filename).c_str());
     if (error)
     {
         printf(&quot;error is: %s\n&quot;,lua_tostring(luavm,-1));

Modified: trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Scripts/bindings/NetPanzerBindings.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: NetPanzer
-** Generated automatically by tolua++-1.0.92 on Sun Dec 20 22:38:44 2009.
+** Generated automatically by tolua++-1.0.92 on Sun Dec 27 14:13:08 2009.
 */
 
 #ifndef __cplusplus
@@ -13,25 +13,216 @@
 /* Exported function */
 TOLUA_API int  tolua_NetPanzer_open (lua_State* tolua_S);
 
+#include &quot;Types/iXY.hpp&quot;
 #include &quot;2D/Color.hpp&quot;
 #include &quot;2D/Palette.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
 #include &quot;Interfaces/ConsoleInterface.hpp&quot;
 #include &quot;Classes/PlayerState.hpp&quot;
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
+#include &quot;Interfaces/GameConfig.hpp&quot;
+#include &quot;Interfaces/ChatInterface.hpp&quot;
+#include &quot;Interfaces/GameManager.hpp&quot;
 
+/* function to release collected object via destructor */
+#ifdef __cplusplus
+
+static int tolua_collect_iXY (lua_State* tolua_S)
+{
+ iXY* self = (iXY*) tolua_tousertype(tolua_S,1,0);
+	Mtolua_delete(self);
+	return 0;
+}
+#endif
+
+
 /* function to register type */
 static void tolua_reg_types (lua_State* tolua_S)
 {
  tolua_usertype(tolua_S,&quot;Logger&quot;);
+ tolua_usertype(tolua_S,&quot;ChatInterface&quot;);
+ tolua_usertype(tolua_S,&quot;PlayerState&quot;);
+ tolua_usertype(tolua_S,&quot;Palette&quot;);
  tolua_usertype(tolua_S,&quot;ConsoleInterface&quot;);
- tolua_usertype(tolua_S,&quot;iXY&quot;);
+ tolua_usertype(tolua_S,&quot;GameManager&quot;);
+ tolua_usertype(tolua_S,&quot;GameConfig&quot;);
  tolua_usertype(tolua_S,&quot;Color&quot;);
- tolua_usertype(tolua_S,&quot;PlayerState&quot;);
  tolua_usertype(tolua_S,&quot;PlayerInterface&quot;);
- tolua_usertype(tolua_S,&quot;Palette&quot;);
+ tolua_usertype(tolua_S,&quot;iXY&quot;);
 }
 
+/* get function: x of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_get_iXY_x
+static int tolua_get_iXY_x(lua_State* tolua_S)
+{
+  iXY* self = (iXY*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'x'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;x);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: x of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_set_iXY_x
+static int tolua_set_iXY_x(lua_State* tolua_S)
+{
+  iXY* self = (iXY*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'x'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;x = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: y of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_get_iXY_y
+static int tolua_get_iXY_y(lua_State* tolua_S)
+{
+  iXY* self = (iXY*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'y'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;y);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: y of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_set_iXY_y
+static int tolua_set_iXY_y(lua_State* tolua_S)
+{
+  iXY* self = (iXY*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'y'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;y = ((int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: new of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_iXY_new00
+static int tolua_NetPanzer_iXY_new00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;iXY&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   iXY* tolua_ret = (iXY*)  Mtolua_new((iXY)());
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;iXY&quot;);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'new'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: new_local of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_iXY_new00_local
+static int tolua_NetPanzer_iXY_new00_local(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;iXY&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   iXY* tolua_ret = (iXY*)  Mtolua_new((iXY)());
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;iXY&quot;);
+    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'new'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: new of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_iXY_new01
+static int tolua_NetPanzer_iXY_new01(lua_State* tolua_S)
+{
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;iXY&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+ {
+  int newx = ((int)  tolua_tonumber(tolua_S,2,0));
+  int newy = ((int)  tolua_tonumber(tolua_S,3,0));
+  {
+   iXY* tolua_ret = (iXY*)  Mtolua_new((iXY)(newx,newy));
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;iXY&quot;);
+  }
+ }
+ return 1;
+tolua_lerror:
+ return tolua_NetPanzer_iXY_new00(tolua_S);
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: new_local of class  iXY */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_iXY_new01_local
+static int tolua_NetPanzer_iXY_new01_local(lua_State* tolua_S)
+{
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;iXY&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+ {
+  int newx = ((int)  tolua_tonumber(tolua_S,2,0));
+  int newy = ((int)  tolua_tonumber(tolua_S,3,0));
+  {
+   iXY* tolua_ret = (iXY*)  Mtolua_new((iXY)(newx,newy));
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,&quot;iXY&quot;);
+    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
+  }
+ }
+ return 1;
+tolua_lerror:
+ return tolua_NetPanzer_iXY_new00_local(tolua_S);
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* get function: unitAqua of class  Color */
 #ifndef TOLUA_DISABLE_tolua_get_Color_unitAqua
 static int tolua_get_Color_unitAqua(lua_State* tolua_S)
@@ -1823,39 +2014,6 @@
 }
 #endif //#ifndef TOLUA_DISABLE
 
-/* method: setFlag of class  PlayerState */
-#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_setFlag00
-static int tolua_NetPanzer_PlayerState_setFlag00(lua_State* tolua_S)
-{
-#ifndef TOLUA_RELEASE
- tolua_Error tolua_err;
- if (
-     !tolua_isusertype(tolua_S,1,&quot;PlayerState&quot;,0,&amp;tolua_err) ||
-     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
-     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
- )
-  goto tolua_lerror;
- else
-#endif
- {
-  PlayerState* self = (PlayerState*)  tolua_tousertype(tolua_S,1,0);
-   int newflag = ((  int)  tolua_tonumber(tolua_S,2,0));
-#ifndef TOLUA_RELEASE
-  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in function 'setFlag'&quot;, NULL);
-#endif
-  {
-   self-&gt;setFlag(newflag);
-  }
- }
- return 0;
-#ifndef TOLUA_RELEASE
- tolua_lerror:
- tolua_error(tolua_S,&quot;#ferror in function 'setFlag'.&quot;,&amp;tolua_err);
- return 0;
-#endif
-}
-#endif //#ifndef TOLUA_DISABLE
-
 /* method: getFlag of class  PlayerState */
 #ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerState_getFlag00
 static int tolua_NetPanzer_PlayerState_getFlag00(lua_State* tolua_S)
@@ -1985,6 +2143,60 @@
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: lockPlayerStats of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_lockPlayerStats00
+static int tolua_NetPanzer_PlayerInterface_lockPlayerStats00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   PlayerInterface::lockPlayerStats();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'lockPlayerStats'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: unlockPlayerStats of class  PlayerInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_unlockPlayerStats00
+static int tolua_NetPanzer_PlayerInterface_unlockPlayerStats00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   PlayerInterface::unlockPlayerStats();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'unlockPlayerStats'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: isAllied of class  PlayerInterface */
 #ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_isAllied00
 static int tolua_NetPanzer_PlayerInterface_isAllied00(lua_State* tolua_S)
@@ -2219,37 +2431,581 @@
 }
 #endif //#ifndef TOLUA_DISABLE
 
-/* method: spawnPlayer of class  PlayerInterface */
-#ifndef TOLUA_DISABLE_tolua_NetPanzer_PlayerInterface_spawnPlayer00
-static int tolua_NetPanzer_PlayerInterface_spawnPlayer00(lua_State* tolua_S)
+/* get function: gametype of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_get_GameConfig_gametype
+static int tolua_get_GameConfig_gametype(lua_State* tolua_S)
 {
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
 #ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'gametype'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;gametype);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gametype of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_set_GameConfig_gametype
+static int tolua_set_GameConfig_gametype(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'gametype'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;gametype = ((  int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: timelimit of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_get_GameConfig_timelimit
+static int tolua_get_GameConfig_timelimit(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'timelimit'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;timelimit);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: timelimit of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_set_GameConfig_timelimit
+static int tolua_set_GameConfig_timelimit(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'timelimit'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;timelimit = ((  int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: fraglimit of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_get_GameConfig_fraglimit
+static int tolua_get_GameConfig_fraglimit(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'fraglimit'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;fraglimit);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: fraglimit of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_set_GameConfig_fraglimit
+static int tolua_set_GameConfig_fraglimit(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'fraglimit'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;fraglimit = ((  int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: objectiveoccupationpercentage of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_get_GameConfig_objectiveoccupationpercentage
+static int tolua_get_GameConfig_objectiveoccupationpercentage(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'objectiveoccupationpercentage'&quot;,NULL);
+#endif
+  tolua_pushnumber(tolua_S,(lua_Number)self-&gt;objectiveoccupationpercentage);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: objectiveoccupationpercentage of class  GameConfig */
+#ifndef TOLUA_DISABLE_tolua_set_GameConfig_objectiveoccupationpercentage
+static int tolua_set_GameConfig_objectiveoccupationpercentage(lua_State* tolua_S)
+{
+  GameConfig* self = (GameConfig*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!self) tolua_error(tolua_S,&quot;invalid 'self' in accessing variable 'objectiveoccupationpercentage'&quot;,NULL);
+  if (!tolua_isnumber(tolua_S,2,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  self-&gt;objectiveoccupationpercentage = ((  int)  tolua_tonumber(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: gameconfig */
+#ifndef TOLUA_DISABLE_tolua_get_gameconfig_ptr
+static int tolua_get_gameconfig_ptr(lua_State* tolua_S)
+{
+   tolua_pushusertype(tolua_S,(void*)gameconfig,&quot;GameConfig&quot;);
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* set function: gameconfig */
+#ifndef TOLUA_DISABLE_tolua_set_gameconfig_ptr
+static int tolua_set_gameconfig_ptr(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+  tolua_Error tolua_err;
+  if (!tolua_isusertype(tolua_S,2,&quot;GameConfig&quot;,0,&amp;tolua_err))
+   tolua_error(tolua_S,&quot;#vinvalid type in variable assignment.&quot;,&amp;tolua_err);
+#endif
+  gameconfig = ((GameConfig*)  tolua_tousertype(tolua_S,2,0))
+;
+ return 0;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: say of class  ChatInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_ChatInterface_say00
+static int tolua_NetPanzer_ChatInterface_say00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (
-     !tolua_isusertable(tolua_S,1,&quot;PlayerInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isusertable(tolua_S,1,&quot;ChatInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const char* message_text = ((const char*)  tolua_tostring(tolua_S,2,0));
+  {
+   ChatInterface::say(message_text);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'say'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: teamsay of class  ChatInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_ChatInterface_teamsay00
+static int tolua_NetPanzer_ChatInterface_teamsay00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;ChatInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const char* message_text = ((const char*)  tolua_tostring(tolua_S,2,0));
+  {
+   ChatInterface::teamsay(message_text);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'teamsay'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: serversay of class  ChatInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_ChatInterface_serversay00
+static int tolua_NetPanzer_ChatInterface_serversay00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;ChatInterface&quot;,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const char* message_text = ((const char*)  tolua_tostring(tolua_S,2,0));
+  {
+   ChatInterface::serversay(message_text);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'serversay'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: serversayTo of class  ChatInterface */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_ChatInterface_serversayTo00
+static int tolua_NetPanzer_ChatInterface_serversayTo00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;ChatInterface&quot;,0,&amp;tolua_err) ||
      !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
-     (tolua_isvaluenil(tolua_S,3,&amp;tolua_err) || !tolua_isusertype(tolua_S,3,&quot;const iXY&quot;,0,&amp;tolua_err)) ||
+     !tolua_isstring(tolua_S,3,0,&amp;tolua_err) ||
      !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
  )
   goto tolua_lerror;
  else
 #endif
  {
-   int player_index = ((  int)  tolua_tonumber(tolua_S,2,0));
-  const iXY* location = ((const iXY*)  tolua_tousertype(tolua_S,3,0));
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  const char* message_text = ((const char*)  tolua_tostring(tolua_S,3,0));
   {
-   PlayerInterface::spawnPlayer(player_index,*location);
+   ChatInterface::serversayTo(player,message_text);
   }
  }
  return 0;
 #ifndef TOLUA_RELEASE
  tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'serversayTo'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: spawnPlayer of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_spawnPlayer00
+static int tolua_NetPanzer_GameManager_spawnPlayer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  {
+   GameManager::spawnPlayer(player);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
  tolua_error(tolua_S,&quot;#ferror in function 'spawnPlayer'.&quot;,&amp;tolua_err);
  return 0;
 #endif
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: spawnPlayerAt of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_spawnPlayerAt00
+static int tolua_NetPanzer_GameManager_spawnPlayerAt00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&amp;tolua_err) || !tolua_isusertype(tolua_S,3,&quot;const iXY&quot;,0,&amp;tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  const iXY* position = ((const iXY*)  tolua_tousertype(tolua_S,3,0));
+  {
+   GameManager::spawnPlayerAt(player,*position);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'spawnPlayerAt'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: respawnAllPlayers of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_respawnAllPlayers00
+static int tolua_NetPanzer_GameManager_respawnAllPlayers00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   GameManager::respawnAllPlayers();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'respawnAllPlayers'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: kickPlayer of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_kickPlayer00
+static int tolua_NetPanzer_GameManager_kickPlayer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  {
+   GameManager::kickPlayer(player);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'kickPlayer'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: destroyPlayerUnits of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_destroyPlayerUnits00
+static int tolua_NetPanzer_GameManager_destroyPlayerUnits00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  {
+   GameManager::destroyPlayerUnits(player);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'destroyPlayerUnits'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: disownPlayerObjectives of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_disownPlayerObjectives00
+static int tolua_NetPanzer_GameManager_disownPlayerObjectives00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const int player = ((const int)  tolua_tonumber(tolua_S,2,0));
+  {
+   GameManager::disownPlayerObjectives(player);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'disownPlayerObjectives'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: addBot of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_addBot00
+static int tolua_NetPanzer_GameManager_addBot00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   int tolua_ret = (int)  GameManager::addBot();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'addBot'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: removeAllBots of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_removeAllBots00
+static int tolua_NetPanzer_GameManager_removeAllBots00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   GameManager::removeAllBots();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'removeAllBots'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: exitNetPanzer of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_exitNetPanzer00
+static int tolua_NetPanzer_GameManager_exitNetPanzer00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   GameManager::exitNetPanzer();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'exitNetPanzer'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: quitNetPanzerGame of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_quitNetPanzerGame00
+static int tolua_NetPanzer_GameManager_quitNetPanzerGame00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   GameManager::quitNetPanzerGame();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'quitNetPanzerGame'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: changeMap of class  GameManager */
+#ifndef TOLUA_DISABLE_tolua_NetPanzer_GameManager_changeMap00
+static int tolua_NetPanzer_GameManager_changeMap00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,&quot;GameManager&quot;,0,&amp;tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&amp;tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  const char* map_name = ((const char*)  tolua_tostring(tolua_S,2,0));
+  {
+   bool tolua_ret = (bool)  GameManager::changeMap(map_name);
+   tolua_pushboolean(tolua_S,(bool)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,&quot;#ferror in function 'changeMap'.&quot;,&amp;tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* Open function */
 TOLUA_API int tolua_NetPanzer_open (lua_State* tolua_S)
 {
@@ -2257,6 +3013,21 @@
  tolua_reg_types(tolua_S);
  tolua_module(tolua_S,NULL,1);
  tolua_beginmodule(tolua_S,NULL);
+  #ifdef __cplusplus
+  tolua_cclass(tolua_S,&quot;iXY&quot;,&quot;iXY&quot;,&quot;&quot;,tolua_collect_iXY);
+  #else
+  tolua_cclass(tolua_S,&quot;iXY&quot;,&quot;iXY&quot;,&quot;&quot;,NULL);
+  #endif
+  tolua_beginmodule(tolua_S,&quot;iXY&quot;);
+   tolua_variable(tolua_S,&quot;x&quot;,tolua_get_iXY_x,tolua_set_iXY_x);
+   tolua_variable(tolua_S,&quot;y&quot;,tolua_get_iXY_y,tolua_set_iXY_y);
+   tolua_function(tolua_S,&quot;new&quot;,tolua_NetPanzer_iXY_new00);
+   tolua_function(tolua_S,&quot;new_local&quot;,tolua_NetPanzer_iXY_new00_local);
+   tolua_function(tolua_S,&quot;.call&quot;,tolua_NetPanzer_iXY_new00_local);
+   tolua_function(tolua_S,&quot;new&quot;,tolua_NetPanzer_iXY_new01);
+   tolua_function(tolua_S,&quot;new_local&quot;,tolua_NetPanzer_iXY_new01_local);
+   tolua_function(tolua_S,&quot;.call&quot;,tolua_NetPanzer_iXY_new01_local);
+  tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,&quot;Color&quot;,&quot;Color&quot;,&quot;&quot;,NULL);
   tolua_beginmodule(tolua_S,&quot;Color&quot;);
    tolua_variable(tolua_S,&quot;unitAqua&quot;,tolua_get_Color_unitAqua,tolua_set_Color_unitAqua);
@@ -2343,7 +3114,6 @@
    tolua_function(tolua_S,&quot;getLosses&quot;,tolua_NetPanzer_PlayerState_getLosses00);
    tolua_function(tolua_S,&quot;getObjectivesHeld&quot;,tolua_NetPanzer_PlayerState_getObjectivesHeld00);
    tolua_function(tolua_S,&quot;getStatus&quot;,tolua_NetPanzer_PlayerState_getStatus00);
-   tolua_function(tolua_S,&quot;setFlag&quot;,tolua_NetPanzer_PlayerState_setFlag00);
    tolua_function(tolua_S,&quot;getFlag&quot;,tolua_NetPanzer_PlayerState_getFlag00);
    tolua_function(tolua_S,&quot;getTotal&quot;,tolua_NetPanzer_PlayerState_getTotal00);
    tolua_function(tolua_S,&quot;setColor&quot;,tolua_NetPanzer_PlayerState_setColor00);
@@ -2351,6 +3121,8 @@
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,&quot;PlayerInterface&quot;,&quot;PlayerInterface&quot;,&quot;&quot;,NULL);
   tolua_beginmodule(tolua_S,&quot;PlayerInterface&quot;);
+   tolua_function(tolua_S,&quot;lockPlayerStats&quot;,tolua_NetPanzer_PlayerInterface_lockPlayerStats00);
+   tolua_function(tolua_S,&quot;unlockPlayerStats&quot;,tolua_NetPanzer_PlayerInterface_unlockPlayerStats00);
    tolua_function(tolua_S,&quot;isAllied&quot;,tolua_NetPanzer_PlayerInterface_isAllied00);
    tolua_function(tolua_S,&quot;isSingleAllied&quot;,tolua_NetPanzer_PlayerInterface_isSingleAllied00);
    tolua_function(tolua_S,&quot;getMaxPlayers&quot;,tolua_NetPanzer_PlayerInterface_getMaxPlayers00);
@@ -2359,8 +3131,36 @@
    tolua_function(tolua_S,&quot;getLocalPlayerIndex&quot;,tolua_NetPanzer_PlayerInterface_getLocalPlayerIndex00);
    tolua_function(tolua_S,&quot;getActivePlayerCount&quot;,tolua_NetPanzer_PlayerInterface_getActivePlayerCount00);
    tolua_function(tolua_S,&quot;countPlayers&quot;,tolua_NetPanzer_PlayerInterface_countPlayers00);
-   tolua_function(tolua_S,&quot;spawnPlayer&quot;,tolua_NetPanzer_PlayerInterface_spawnPlayer00);
   tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;GameConfig&quot;,&quot;GameConfig&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;GameConfig&quot;);
+   tolua_variable(tolua_S,&quot;gametype&quot;,tolua_get_GameConfig_gametype,tolua_set_GameConfig_gametype);
+   tolua_variable(tolua_S,&quot;timelimit&quot;,tolua_get_GameConfig_timelimit,tolua_set_GameConfig_timelimit);
+   tolua_variable(tolua_S,&quot;fraglimit&quot;,tolua_get_GameConfig_fraglimit,tolua_set_GameConfig_fraglimit);
+   tolua_variable(tolua_S,&quot;objectiveoccupationpercentage&quot;,tolua_get_GameConfig_objectiveoccupationpercentage,tolua_set_GameConfig_objectiveoccupationpercentage);
+  tolua_endmodule(tolua_S);
+  tolua_variable(tolua_S,&quot;gameconfig&quot;,tolua_get_gameconfig_ptr,tolua_set_gameconfig_ptr);
+  tolua_cclass(tolua_S,&quot;ChatInterface&quot;,&quot;ChatInterface&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;ChatInterface&quot;);
+   tolua_function(tolua_S,&quot;say&quot;,tolua_NetPanzer_ChatInterface_say00);
+   tolua_function(tolua_S,&quot;teamsay&quot;,tolua_NetPanzer_ChatInterface_teamsay00);
+   tolua_function(tolua_S,&quot;serversay&quot;,tolua_NetPanzer_ChatInterface_serversay00);
+   tolua_function(tolua_S,&quot;serversayTo&quot;,tolua_NetPanzer_ChatInterface_serversayTo00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,&quot;GameManager&quot;,&quot;GameManager&quot;,&quot;&quot;,NULL);
+  tolua_beginmodule(tolua_S,&quot;GameManager&quot;);
+   tolua_function(tolua_S,&quot;spawnPlayer&quot;,tolua_NetPanzer_GameManager_spawnPlayer00);
+   tolua_function(tolua_S,&quot;spawnPlayerAt&quot;,tolua_NetPanzer_GameManager_spawnPlayerAt00);
+   tolua_function(tolua_S,&quot;respawnAllPlayers&quot;,tolua_NetPanzer_GameManager_respawnAllPlayers00);
+   tolua_function(tolua_S,&quot;kickPlayer&quot;,tolua_NetPanzer_GameManager_kickPlayer00);
+   tolua_function(tolua_S,&quot;destroyPlayerUnits&quot;,tolua_NetPanzer_GameManager_destroyPlayerUnits00);
+   tolua_function(tolua_S,&quot;disownPlayerObjectives&quot;,tolua_NetPanzer_GameManager_disownPlayerObjectives00);
+   tolua_function(tolua_S,&quot;addBot&quot;,tolua_NetPanzer_GameManager_addBot00);
+   tolua_function(tolua_S,&quot;removeAllBots&quot;,tolua_NetPanzer_GameManager_removeAllBots00);
+   tolua_function(tolua_S,&quot;exitNetPanzer&quot;,tolua_NetPanzer_GameManager_exitNetPanzer00);
+   tolua_function(tolua_S,&quot;quitNetPanzerGame&quot;,tolua_NetPanzer_GameManager_quitNetPanzerGame00);
+   tolua_function(tolua_S,&quot;changeMap&quot;,tolua_NetPanzer_GameManager_changeMap00);
+  tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  return 1;
 }

Modified: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/netpanzer.pkg	2009-12-27 14:50:29 UTC (rev 1152)
@@ -1,3 +1,4 @@
+$pfile &quot;base_types.pkg&quot;
 $pfile &quot;colors.pkg&quot;
 $pfile &quot;log.pkg&quot;
 $pfile &quot;consoleinterface.pkg&quot;
@@ -2 +3,4 @@
 $pfile &quot;players.pkg&quot;
+$pfile &quot;config.pkg&quot;
+$pfile &quot;chat.pkg&quot;
+$pfile &quot;gamemanager.pkg&quot;
\ No newline at end of file

Modified: trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg
===================================================================
--- trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Scripts/toluapkg/players.pkg	2009-12-27 14:50:29 UTC (rev 1152)
@@ -16,7 +16,7 @@
 
     unsigned char getStatus() const;
 
-    void setFlag(FlagID newflag);
+    //void setFlag(FlagID newflag);
     FlagID getFlag() const;
     short getTotal() const;
 
@@ -26,6 +26,9 @@
 
 class PlayerInterface
 {
+    static void lockPlayerStats();
+    static void unlockPlayerStats();
+
     static bool isAllied(unsigned short player, unsigned short with_player);
     static bool isSingleAllied(unsigned short player, unsigned short with_player);
 
@@ -40,7 +43,5 @@
     static int getActivePlayerCount();
 
     static int countPlayers();
-
-    static void spawnPlayer( Uint16 player_index, const iXY &amp;location );
 };
 

Modified: trunk/netpanzer/src/NetPanzer/Units/Unit.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Unit.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -24,12 +24,12 @@
 
 #include &lt;string.h&gt;
 #include &quot;Util/Log.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Units/Unit.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
 #include &quot;Interfaces/PathScheduler.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Classes/PlayerState.hpp&quot;
+#include &quot;Classes/PlacementMatrix.hpp&quot;
 #include &quot;Weapons/ProjectileInterface.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Units/UnitProfileInterface.hpp&quot;
@@ -65,7 +65,6 @@
     _ai_command_idle,
     _ai_command_move_to_loc,
     _ai_command_attack_unit,
-    _ai_command_manual_move,
     _ai_command_defend_hold
 };
 
@@ -75,8 +74,7 @@
     _aiFsmMoveToLoc_check_goal,
     _aiFsmMoveToLoc_next_move,
     _aiFsmMoveToLoc_move_wait,
-    _aiFsmMoveToLoc_wait_clear_loc,
-    _aiFsmMoveToLoc_check_fsm_transition
+    _aiFsmMoveToLoc_wait_clear_loc
 };
 
 enum
@@ -87,7 +85,6 @@
     _aiFsmAttackUnit_next_move,
     _aiFsmAttackUnit_move_wait,
     _aiFsmAttackUnit_wait_clear_loc,
-    _aiFsmAttackUnit_check_fsm_transition,
     _aiFsmAttackUnit_check_path_deviation
 };
 
@@ -99,13 +96,6 @@
 
 enum
 {
-    _aiFsmManualMove_next_move,
-    _aiFsmManualMove_move_wait,
-    _aiFsmManualMove_check_fsm_transition
-};
-
-enum
-{
     _external_event_null,
     _external_event_pending_unit_destruct
 };
@@ -122,10 +112,9 @@
     _rotate_stop_move
 };
 
-Unit::Unit(PlayerState* ownplayer, UnitInterface * unit_manager, unsigned char utype, UnitID uid, iXY initial_loc)
+Unit::Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc)
     : player(ownplayer), id(uid)
 {
-    my_manager = unit_manager;
     smolderWait    = 0.0f;
     smolderWaitMin = 0.0f;
 
@@ -138,7 +127,7 @@
     MapInterface::mapXYtoPointXY(initial_loc, &amp;loc);
 
     unit_state.location = loc;
-    global_game_state-&gt;unit_manager-&gt;markUnitLoc( initial_loc );
+//    UnitInterface::markUnitLoc( initial_loc );
     fsm_timer.changeRate( 10 );
     unit_state_timer.changeRate( 10 );
     setAiFsmDefendHold();
@@ -151,8 +140,6 @@
     body_anim_shadow.setDrawModeBlend(128); // dark a lot
     turret_anim_shadow.setDrawModeBlend(128); // dark a lot
 
-    path_generated = false;
-    critical_ai_section = false;
     ai_fsm_transition_complete = false;
     
     reload_counter = 0;
@@ -266,7 +253,7 @@
 
             DestructUnitOpcode destruct_opcode;
             destruct_opcode.setUnitID(id);
-            my_manager-&gt;sendOpcode(&amp;destruct_opcode);
+            UnitInterface::sendOpcode(&amp;destruct_opcode);
         }
         else
         {
@@ -543,7 +530,6 @@
         fsmMoveMapSquare_movement_type = _rotate_stop_move;
 
     fsm_active_list[ _control_move_map_square ] = true;
-    critical_ai_section = true;
 
     if ( NetworkState::status == _network_state_server )
     {
@@ -557,7 +543,7 @@
         move_opcode.loc_y_offset = (signed char) loc_offset.y;
         if ( move_opcode_sent == true )
         {
-            my_manager-&gt;sendOpcode(&amp;move_opcode);
+            UnitInterface::sendOpcode(&amp;move_opcode);
         }
     }
 
@@ -572,7 +558,7 @@
     {
         if ( opcode_move_timer.count() )
         {
-            my_manager-&gt;sendOpcode(&amp;move_opcode);
+            UnitInterface::sendOpcode(&amp;move_opcode);
             move_opcode_sent = true;
         }
     }
@@ -586,11 +572,10 @@
                 if ( fsmMove() )
                 {
                     fsm_active_list[ _control_move_map_square ] = false;
-                    critical_ai_section = false;
 
                     if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                     {
-                        my_manager-&gt;sendOpcode(&amp;move_opcode);
+                        UnitInterface::sendOpcode(&amp;move_opcode);
                         move_opcode_sent = true;
                     }
                     
@@ -606,11 +591,10 @@
             if ( fsmMove() )
             {
                 fsm_active_list[ _control_move_map_square ] = false;
-                critical_ai_section = false;
 
                 if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                 {
-                    my_manager-&gt;sendOpcode(&amp;move_opcode);
+                    UnitInterface::sendOpcode(&amp;move_opcode);
                     move_opcode_sent = true;
                 }
 
@@ -640,7 +624,7 @@
     {
         TurretTrackPointOpcode track_point_opcode(id, 0, true);
         track_point_opcode.setTarget(target);
-        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
     }
 
 }
@@ -654,7 +638,7 @@
     if ( NetworkState::status == _network_state_server )
     {
         TurretTrackPointOpcode track_point_opcode(id, 0, false);
-        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
     }
 }
 
@@ -664,7 +648,7 @@
     {
         TurretTrackPointOpcode track_point_opcode(id, _unit_opcode_flag_sync, true);
         track_point_opcode.setTarget(fsmTurretTrackPoint_target);
-        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
+        UnitInterface::sendOpcode( &amp;track_point_opcode );
     }
 }
 
@@ -698,7 +682,7 @@
     {
         TurretTrackTargetOpcode track_target_opcode(id, 0, true);
         track_target_opcode.setTargetUnitID(target_id);
-        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -710,7 +694,7 @@
     if ( NetworkState::status == _network_state_server )
     {
         TurretTrackTargetOpcode track_target_opcode(id, 0, false);
-        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -721,7 +705,7 @@
     {
         TurretTrackTargetOpcode track_target_opcode(id, _unit_opcode_flag_sync, true);
         track_target_opcode.setTargetUnitID(fsmTurretTrackTarget_target_id);
-        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
+        UnitInterface::sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -735,7 +719,7 @@
     Unit *target_unit_ptr;
     iXY direction_vector;
 
-    target_unit_ptr = my_manager-&gt;getUnit( fsmTurretTrackTarget_target_id );
+    target_unit_ptr = UnitInterface::getUnit( fsmTurretTrackTarget_target_id );
 
     if ( target_unit_ptr != 0 )
     {
@@ -823,7 +807,7 @@
     UnitState *target_unit_state;
     iXY range_vector;
 
-    target_unit_ptr = my_manager-&gt;getUnit( fsmGunneryTarget_target_id );
+    target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
     if ( target_unit_ptr == 0 )
     {
         clearFsmGunneryTarget();
@@ -877,47 +861,40 @@
 
 void Unit::aiFsmMoveToLoc()
 {
-    bool end_cycle = false;
 //LOGGER.warning(&quot;Unit %d move&quot;, id);
+
+    if ( external_ai_event == _external_event_pending_unit_destruct  )
+    {
+        if ( aiFsmMoveToLoc_state == _aiFsmMoveToLoc_move_wait )
+        {
+            // two positions are used on the unit blackboard, clear both
+            UnitInterface::unmarkUnitLoc(aiFsmMoveToLoc_prev_loc);
+            UnitInterface::unmarkUnitLoc(aiFsmMoveToLoc_next_loc);
+        }
+        
+        aiFsmMoveToLoc_OnExitCleanUp();
+        external_ai_event = _external_event_null;
+        ai_command_state = _ai_command_idle;
+        return;
+    }
+    else if ( pending_AI_comm == true &amp;&amp; aiFsmMoveToLoc_state != _aiFsmMoveToLoc_move_wait )
+    {
+        ai_fsm_transition_complete = true;
+        aiFsmMoveToLoc_OnExitCleanUp();
+        return;
+    }
+
+    bool end_cycle = false;
     do
     {
         switch ( aiFsmMoveToLoc_state )
         {
-
             // *************************************************************
             case _aiFsmMoveToLoc_path_generate :
             {
-//LOGGER.warning(&quot;path_generate&quot;);
-                // QueryPath: Has a path been generated for unit ?
-                path_generated = PathScheduler::queryPath(id);
-
-
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                if ( PathScheduler::queryPath(id) )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
-
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( path_generated == true )
-                {
                     // Rule QueryPath: is true move to next state
-                    LOG( (&quot;Path Successfully Generated&quot;) );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
                 }
                 else
@@ -931,27 +908,16 @@
 
             case _aiFsmMoveToLoc_check_goal :
             {
-//LOGGER.warning(&quot;check_goal&quot;);
-                //  GoalReached: Has the goal been reached ?
                 if ( ruleMoveToLoc_GoalReached() == true )
                 {
-//LOGGER.warning(&quot;check_goal -&gt; goal_reached&quot;);
-                    // Rule GoalReached : is true
-                    // Action : Exit fsm
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_prev_loc );
-
                     aiFsmMoveToLoc_OnExitCleanUp();
                     setAiFsmDefendHold();
-
                     end_cycle = true;
                 }
                 else
                 {
                     if ( aiFsmMoveToLoc_path_not_finished == false )
                     {
-//LOGGER.warning(&quot;check_goal -&gt; path_not_finished&quot;);
                         //  Rule: GoalReached is false AND Unit is at the end of path
                         //  Action : Request path generation to goal
                         iXY start;
@@ -966,7 +932,6 @@
                     }
                     else
                     {
-//LOGGER.warning(&quot;check_goal -&gt; path_finished&quot;);
                         // Rule GoalReached: is false
                         // Action: Get next move;
                         aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
@@ -979,30 +944,24 @@
 
             case _aiFsmMoveToLoc_next_move :
             {
-//LOGGER.warning(&quot;next_move&quot;);
                 // CurrentPathComplete: is Unit at the end of the current path
                 aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
                 MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
-//LOGGER.warning(&quot;Unit:moving to %d,%d&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
 
                 if ( !aiFsmMoveToLoc_path_not_finished )
                 {
-//LOGGER.warning(&quot;next_move -&gt; path_finished&quot;);
                     // Rule: CurrentPathComplete is true
                     // Action : check if unit is at the goal
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
                 }
                 else
                 {
-//LOGGER.warning(&quot;next_move -&gt; path_not_finished&quot;);
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
-                    aiFsmMoveToLoc_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    // Save the current position
+                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmMoveToLoc_prev_loc );
 
-                    //aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
-                    aiFsmMoveToLoc_wait_timer.reset();
+                    aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
                 }
             }
@@ -1012,59 +971,28 @@
 
             case _aiFsmMoveToLoc_wait_clear_loc :
             {
-//LOGGER.warning(&quot;wait_clear_loc&quot;);
-
-                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                if ( UnitInterface::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                } // NextSquareOccupied: does the next square contain a abstruction
-                else if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
-                {
-//LOGGER.warning(&quot;wait_clear_loc -&gt; unit occupy loc %d,%d&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
-
-                    // Rule: NextSquareOccupied is true
-                    // Action: Check Wait Timer
-
+                    // There is something in the next position, wait to see if it moves
                     if ( aiFsmMoveToLoc_wait_timer.count() )
                     {
-                        // Rule: NextSquareOccupied is true AND WaitTimer is finished
-                        // Action: Preform path update
+                        // It didn't move generate other path
                         if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
                         {
-//LOGGER.warning(&quot;wait_clear_loc -&gt; unit occupy loc do repath&quot;);
+                            PlacementMatrix::reset( aiFsmMoveToLoc_goal );
+                            PlacementMatrix::getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
 
-                            my_manager-&gt;unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
-                            my_manager-&gt;unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
-
                             PathRequest path_request;
+                            // XXX from current position to goal, full
                             path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
                             PathScheduler::requestPath( path_request );
-                            aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
                         }
                         else
                         {
-//LOGGER.warning(&quot;wait_clear_loc -&gt; Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
-//                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
-//                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
                             PathRequest path_request;
+                            // XXX from current position to goal, update
                             path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_update );
                             PathScheduler::requestPath( path_request );
-                            // XXX the more times timeout the longer will take next time
-                            aiFsmMoveToLoc_wait_timer.changePeriod( aiFsmMoveToLoc_wait_timer.getPeriod() * 2.0f );
                         }
 
                         aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
@@ -1074,12 +1002,11 @@
                 }
                 else
                 {
-//LOGGER.warning(&quot;wait_clear_loc -&gt; is empty&quot;);
                     // Rule: NextSquareOccupied is false
                     // Action: Begin move to next square
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_next_loc );
+                    // XXX should mark the next loc to reserve it for me.
+                    UnitInterface::markUnitLoc( aiFsmMoveToLoc_next_loc );
                     setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
-//LOGGER.warning(&quot;Unit:moving to %d,%d moved&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
 
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
                     aiFsmMoveToLoc_wait_timer.changePeriod( 0.8f );
@@ -1092,58 +1019,19 @@
 
             case _aiFsmMoveToLoc_move_wait :
             {
-//LOGGER.warning(&quot;move_wait&quot;);
                 // MoveFinished : has the low level fsm finshed
                 if ( fsm_active_list[ _control_move_map_square ] == false )
                 {
-//LOGGER.warning(&quot;move_wait -&gt; finished&quot;);
-                    // Rule: MoveFinished is true
-                    // Action: Check for a pending transition
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
-                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
-                    end_cycle = true;
-                }
-                else
-                {
-                    end_cycle = true;
-                } // ** else
-
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmMoveToLoc_check_fsm_transition :
-            {
-//LOGGER.warning(&quot;check_fsm_transition&quot;);
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmMoveToLoc_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else
-                {
+                    // Move finished, check goal.
+                    // Remove the unit from the previous position
+                    UnitInterface::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
                 }
-
+                end_cycle = true;
             }
             break;
-            
+
         } // ** switch
-        
     } while (end_cycle == false);
 }
 
@@ -1155,13 +1043,12 @@
 
 void Unit::aiFsmAttackUnit()
 {
-    bool end_cycle = false;
 
     UnitState *target_unit_state = 0;
     iXY range_vector;
 
     Unit* target_unit_ptr
-        = my_manager-&gt;getUnit( aiFsmAttackUnit_target_ID );
+        = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
     if ( target_unit_ptr == 0 )
     {
         aiFsmAttackUnit_target_destroyed = true;
@@ -1189,6 +1076,28 @@
         }
     }
 
+    if ( external_ai_event == _external_event_pending_unit_destruct )
+    {
+        if ( aiFsmAttackUnit_state == _aiFsmAttackUnit_move_wait )
+        {
+            // two positions are used on the unit blackboard, clear both
+            UnitInterface::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+            UnitInterface::unmarkUnitLoc( aiFsmAttackUnit_next_loc );
+        }
+        
+        aiFsmAttackUnit_OnExitCleanUp();
+        external_ai_event = _external_event_null;
+        ai_command_state = _ai_command_idle;
+        return;
+    }
+    else if ( pending_AI_comm == true &amp;&amp; aiFsmAttackUnit_state != _aiFsmAttackUnit_move_wait )
+    {
+        ai_fsm_transition_complete = true;
+        aiFsmAttackUnit_OnExitCleanUp();
+        return;
+    }
+
+    bool end_cycle = false;
     do
     {
         switch ( aiFsmAttackUnit_state )
@@ -1197,33 +1106,8 @@
 
             case _aiFsmAttackUnit_path_generate :
             {
-                // QueryPath: Has a path been generated for unit ?
-                path_generated = PathScheduler::queryPath(id);
-
-                if ( external_ai_event == _external_event_pending_unit_destruct )
+                if ( PathScheduler::queryPath(id) )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-
-                    iXY current_map_loc;
-                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
-
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( path_generated == true )
-                {
                     // Rule QueryPath: is true move to next state
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
                 }
@@ -1245,9 +1129,6 @@
                 {
                     // Rule: RangeVector &lt; WeaponRange, unit is in range
                     // Action: Remain in position
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
                     end_cycle = true;
                 }
@@ -1280,26 +1161,8 @@
             {
                 range_vector = target_unit_state-&gt;location - unit_state.location;
 
-                if ( external_ai_event == _external_event_pending_unit_destruct )
+                if ( range_vector.mag2() &lt; unit_state.weapon_range )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( range_vector.mag2() &lt; unit_state.weapon_range )
-                {
                     // Rule: RangeVector &lt; WeaponRange, unit is in range
                     // Action: Remain in position
                     end_cycle = true;
@@ -1331,9 +1194,9 @@
                 {
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
-                    aiFsmAttackUnit_prev_loc = unit_state.location;
-                    MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    // Save current location
+                    MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmAttackUnit_prev_loc );
+
                     aiFsmAttackUnit_wait_timer.changePeriod( 0.8f );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_wait_clear_loc;
                 }
@@ -1344,37 +1207,18 @@
 
             case _aiFsmAttackUnit_wait_clear_loc :
             {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
+                if ( UnitInterface::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
-                {
                     if ( aiFsmAttackUnit_wait_timer.count() )
                     {
                         if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
                         {
-                            my_manager-&gt;unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
-                            my_manager-&gt;unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
+                            PlacementMatrix::reset( aiFsmAttackUnit_target_goal_loc );
+                            PlacementMatrix::getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
 
                             PathRequest path_request;
                             path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
                             PathScheduler::requestPath( path_request );
-
                         }
                         else
                         {
@@ -1390,7 +1234,7 @@
                 }
                 else
                 {
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_next_loc );
+                    UnitInterface::markUnitLoc( aiFsmAttackUnit_next_loc );
                     setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
                 }
@@ -1403,8 +1247,8 @@
             {
                 if ( fsm_active_list[ _control_move_map_square ] == false )
                 {
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
+                    UnitInterface::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
                 }
                 end_cycle = true;
             }
@@ -1412,38 +1256,6 @@
 
             // *************************************************************
 
-            case _aiFsmAttackUnit_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    ai_fsm_transition_complete = true;
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else if (  aiFsmAttackUnit_target_destroyed == true )
-                {
-                    setAiFsmDefendHold();
-                    aiFsmAttackUnit_OnExitCleanUp();
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
-                }
-            }
-            break;
-            // *************************************************************
-
             case _aiFsmAttackUnit_check_path_deviation :
             {
                 iXY deviation_vector;
@@ -1457,6 +1269,7 @@
                     MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
 
                     PathRequest path_request;
+                    // XXX move from current position to target unit position, full
                     path_request.set( id, aiFsmAttackUnit_next_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
                     PathScheduler::requestPath( path_request );
 
@@ -1492,116 +1305,60 @@
 
 void Unit::aiFsmDefendHold()
 {
-    bool end_cycle = false;
-
+    if ( external_ai_event == _external_event_pending_unit_destruct )
+    {
+        // External Event: This unit is about to be deleted
+        // Action : Exit fsm gracefully
+        clearFsmGunneryTarget();
+        external_ai_event = _external_event_null;
+        ai_command_state = _ai_command_idle;
+        return;
+    }
+    else if ( pending_AI_comm == true )
+    {
+        // External Event: A new AI command is pending
+        // Action: Allow command transition to occur
+        clearFsmGunneryTarget();
+        ai_fsm_transition_complete = true;
+        return;
+    }
+    
     Unit  *target_unit_ptr;
-    UnitState *target_unit_state;
-
-    iXY range_vector;
-
+    bool end_cycle = false;
     do
     {
         switch ( aiFsmDefendHold_state )
         {
             case _aiFsmDefendHold_search_for_enemy :
             {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
+                if ( aiFsmDefendHold_search_timer.count() )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else if ( aiFsmDefendHold_search_timer.count() )
-                {
-                    if (my_manager-&gt;unit_bucket_array.queryClosestEnemyUnitInRange(
+                    if ( UnitBucketArray::queryClosestEnemyUnitInRange(
                                 &amp;target_unit_ptr, unit_state.location, unit_state.weapon_range,
-                                player-&gt;getID() ) )
+                                player-&gt;getID()) )
                     {
-                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                        range_vector = target_unit_state-&gt;location - unit_state.location;
-                        if ( range_vector.mag2() &lt;= unit_state.defend_range )
+                        if ( (target_unit_ptr-&gt;unit_state.location - unit_state.location).mag2() &lt;= unit_state.defend_range )
                         {
                             aiFsmDefendHold_target_ID = target_unit_ptr-&gt;id;
                             setFsmGunneryTarget( aiFsmDefendHold_target_ID );
                             aiFsmDefendHold_state = _aiFsmDefendHold_attack_enemy;
-                            end_cycle = true;
                         }
-                        else
-                        {
-                            end_cycle = true;
-                        }
-                    } // **  quearyClosestEnemyUnit
-                    else
-                    {
-                        end_cycle = true;
                     }
-
-                } // ** aiFsmDefendHold_search_timer.count()
-                else
-                {
-                    end_cycle = true;
                 }
+                end_cycle = true;
             }
             break;
 
             case _aiFsmDefendHold_attack_enemy :
             {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
+                target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
+                if (   target_unit_ptr == 0
+                    || target_unit_ptr-&gt;unit_state.lifecycle_state == _UNIT_LIFECYCLE_DESTROYED
+                    || (target_unit_ptr-&gt;unit_state.location - unit_state.location).mag2() &gt; unit_state.defend_range )
                 {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
                     clearFsmGunneryTarget();
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
+                    aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
                 }
-                else if ( pending_AI_comm == true )
-                {
-                    // External Event: A new AI command is pending
-                    // Action: Allow command transition to occur
-                    clearFsmGunneryTarget();
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else
-                {
-                    target_unit_ptr = my_manager-&gt;getUnit( aiFsmDefendHold_target_ID );
-                    if ( target_unit_ptr == 0 )
-                    {
-                        clearFsmGunneryTarget();
-                        aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                        end_cycle = true;
-                    }
-                    else
-                    {
-                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
-                        {
-                            clearFsmGunneryTarget();
-                            aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                            end_cycle = true;
-                        } // ** if
-                        else
-                        {
-                            range_vector = target_unit_state-&gt;location - unit_state.location;
-                            if ( range_vector.mag2() &gt; unit_state.defend_range )
-                            {
-                                clearFsmGunneryTarget();
-                                aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                                end_cycle = true;
-                            }
-                        } 
-                    }
-                }
                 end_cycle = true;
             }
             break;
@@ -1611,94 +1368,6 @@
 
 }
 
-
-
-
-
-void Unit::aiFsmManualMove()
-{
-    bool end_cycle = false;
-    signed char offset_x = 0, offset_y = 0;
-    size_t next_square;
-
-    do
-    {
-        switch( aiFsmManualMove_state )
-        {
-            case _aiFsmManualMove_next_move :
-            {
-                aiFsmManualMove_prev_loc = aiFsmManualMove_next_loc;
-                orientationToOffset( aiFsmManualMove_move_orientation, &amp;offset_x, &amp;offset_y );
-                aiFsmManualMove_next_loc.x += offset_x;
-                aiFsmManualMove_next_loc.y += offset_y;
-                next_square = MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
-
-                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                }
-                else if( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
-                {
-                    setAiFsmDefendHold();
-                    end_cycle = true;
-                }
-                else
-                {
-                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmManualMove_next_loc );
-                    setFsmMoveMapSquare( next_square );
-                    aiFsmManualMove_state = _aiFsmManualMove_move_wait;
-                }
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_move_wait :
-            {
-                if ( fsm_active_list[ _control_move_map_square ] == false )
-                {
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmManualMove_prev_loc );
-                    aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
-                    end_cycle = true;
-                }
-                else
-                {
-                    end_cycle = true;
-                } // ** else
-            }
-            break;
-
-            // *************************************************************
-
-            case _aiFsmManualMove_check_fsm_transition :
-            {
-                if ( external_ai_event == _external_event_pending_unit_destruct )
-                {
-                    // External Event: This unit is about to be deleted
-                    // Action : Exit fsm gracefully
-                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmManualMove_next_loc );
-                    external_ai_event = _external_event_null;
-                    ai_command_state = _ai_command_idle;
-                    end_cycle = true;
-                }
-                else if ( pending_AI_comm == true )
-                {
-                    ai_fsm_transition_complete = true;
-                    end_cycle = true;
-                }
-                else
-                {
-                    aiFsmManualMove_state = _aiFsmManualMove_next_move;
-                }
-            }
-            break;
-
-        } // ** switch
-    } while ( end_cycle == false );
-
-}
-
 void Unit::fireWeapon( iXY &amp;target_loc )
 {
     reload_counter = 0;
@@ -1713,7 +1382,7 @@
     if ( NetworkState::status == _network_state_server ) {
         FireWeaponOpcode fire_opcode(id);
         fire_opcode.setTarget(target_loc);
-        my_manager-&gt;sendOpcode(&amp;fire_opcode);
+        UnitInterface::sendOpcode(&amp;fire_opcode);
     }
 }
 
@@ -1798,9 +1467,6 @@
             aiFsmAttackUnit();
             break;
 
-        case _ai_command_manual_move:
-            aiFsmManualMove();
-            break;
     }
 }
 
@@ -1874,7 +1540,7 @@
 
     aiFsmAttackUnit_target_ID = message-&gt;getTargetUnitID();
 
-    target_unit_ptr = my_manager-&gt;getUnit( aiFsmAttackUnit_target_ID );
+    target_unit_ptr = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
     if ( target_unit_ptr == 0 )
     {
         return;
@@ -1942,7 +1608,7 @@
 
     update_state_opcode.setUnitID(id);
     update_state_opcode.setHitPoints(unit_state.hit_points);
-    my_manager-&gt;sendOpcode( &amp;update_state_opcode );
+    UnitInterface::sendOpcode( &amp;update_state_opcode );
 
     if ( unit_state.hit_points &lt;= 0 )
     {
@@ -1952,12 +1618,12 @@
         UMesgEndLifeCycleUpdate lifecycle_update;
         lifecycle_update.set(id, weapon_hit-&gt;getOwnerUnitID(),
                 unit_state.unit_type);
-        my_manager-&gt;sendMessage(&amp;lifecycle_update);
+        UnitInterface::sendMessage(&amp;lifecycle_update);
 
         // ** Note: Temp
-        iXY current_map_loc;
-        MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
-        global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc(current_map_loc);
+//        iXY current_map_loc;
+//        MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
+//        UnitInterface::unmarkUnitLoc(current_map_loc);
     }
 }
 
@@ -1995,9 +1661,9 @@
     external_ai_event = _external_event_pending_unit_destruct;
 
     // ** Note: Temp
-    iXY current_map_loc;
-    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
+//    iXY current_map_loc;
+//    MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
+//    UnitInterface::unmarkUnitLoc( current_map_loc );
 }
 
 void Unit::processMessage(const UnitMessage* message)
@@ -2141,7 +1807,7 @@
 
     SyncUnitOpcode sync_opcode(id);
 
-    my_manager-&gt;sendOpcode( &amp;sync_opcode );
+    UnitInterface::sendOpcode( &amp;sync_opcode );
 }
 
 

Modified: trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -41,7 +41,7 @@
     UnitState    unit_state;
     bool         in_sync_flag;
 
-    Unit(PlayerState* ownplayer, UnitInterface * unit_manager, unsigned char utype, UnitID uid, iXY initial_loc);
+    Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc);
 
     void soundSelected();
 
@@ -79,8 +79,6 @@
     bool fsm_active_list[ 7 ];
 
     PathList path;
-    bool path_generated;
-    bool critical_ai_section;
     bool ai_fsm_transition_complete;
 
     unsigned short reload_counter;
@@ -181,13 +179,6 @@
     void aiFsmAttackUnit_OnExitCleanUp();
     void aiFsmAttackUnit();
 
-
-    unsigned char aiFsmManualMove_move_orientation;
-    unsigned char aiFsmManualMove_state;
-    iXY aiFsmManualMove_next_loc;
-    iXY aiFsmManualMove_prev_loc;
-    void aiFsmManualMove();
-
     void fireWeapon( iXY &amp;target_loc );
     unsigned short launchProjectile();
 
@@ -229,7 +220,6 @@
 
 private:
     friend class UnitInterface;
-    UnitInterface * my_manager;
 
     void setID(UnitID id)
     {

Deleted: trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -1,30 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include &quot;Units/UnitBlackBoard.hpp&quot;
-
-void UnitBlackBoard::initialize(unsigned long mapWidth, unsigned long mapHeight)
-{
-    unit_loc_map.initialize(mapWidth, mapHeight);
-    unit_loc_map.clear();
-}
-
-void UnitBlackBoard::cleanUp()
-{
-    unit_loc_map.clear();
-}

Deleted: trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -1,50 +0,0 @@
-/*
-Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
- 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
- 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
- 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef _UNITBLACKBOARD_HPP
-#define _UNITBLACKBOARD_HPP
-
-#include &quot;ArrayUtil/BitArray.hpp&quot;
-#include &quot;Types/iXY.hpp&quot;
-
-class UnitBlackBoard
-{
-public:
-    void initialize(unsigned long mapWidth, unsigned long mapHeight);
-
-    void cleanUp();
-
-    bool unitOccupiesLoc( iXY &amp;unit_map_loc )
-    {
-        return( unit_loc_map.getBit( unit_map_loc.x, unit_map_loc.y ) );
-    }
-
-    void markUnitLoc( iXY &amp;unit_map_loc )
-    {
-        unit_loc_map.setBit( unit_map_loc.x, unit_map_loc.y );
-    }
-
-    void unmarkUnitLoc( iXY &amp;unit_map_loc )
-    {
-        unit_loc_map.clearBit( unit_map_loc.x, unit_map_loc.y );
-    }
-
-private:
-    BitArray unit_loc_map;
-};
-
-#endif // ** _UNITBLACKBOARD_HPP

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -16,7 +16,6 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
 #include &quot;Util/Log.hpp&quot;
 #include &lt;list&gt;
 #include &lt;algorithm&gt;
@@ -26,6 +25,14 @@
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 
+BucketList* UnitBucketArray::buckets = 0;
+long        UnitBucketArray::map_x_sample_factor = 0;
+long        UnitBucketArray::map_y_sample_factor = 0;
+long        UnitBucketArray::pixel_x_sample_factor = 0;
+long        UnitBucketArray::pixel_y_sample_factor = 0;
+size_t      UnitBucketArray::row_size = 0;
+size_t      UnitBucketArray::column_size = 0;
+
 void
 UnitBucketArray::initialize( const iXY &amp; map_size, const iXY &amp; tile_size,
         const unsigned int x_sample, const unsigned int y_sample )
@@ -58,7 +65,8 @@
 
     row_size = rows;
     column_size = columns;
-    buckets.resize(rows*columns);
+    buckets = new BucketList();
+    buckets-&gt;resize(rows*columns);
 }
 
 void

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -30,66 +30,69 @@
 class UnitBucketArray
 {
 public:
-    void queryPlayerUnitsAt(std::vector&lt;UnitID&gt;&amp; working_list,
+    static void queryPlayerUnitsAt(std::vector&lt;UnitID&gt;&amp; working_list,
                             const iXY&amp; point,
                             const Uint16 player_id);
 
-    void queryUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+    static void queryUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
                                const iRect&amp; rect);
 
-    void queryPlayerUnitsInWorldRect(std::vector&lt;UnitID&gt;&amp; working_list,
+    static void queryPlayerUnitsInWorldRect(std::vector&lt;UnitID&gt;&amp; working_list,
                                      const iRect&amp; rect,
                                      const Uint16 player_id);
 
-    void queryNonPlayerUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+    static void queryNonPlayerUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
                                         const iRect&amp; rect,
                                         const Uint16 player_id);
 
-    Unit * queryUnitAtMapLoc(const iXY&amp; map_loc);
+    static Unit * queryUnitAtMapLoc(const iXY&amp; map_loc);
 
-    Unit * queryNonPlayerUnitAtWorld(const iXY &amp; world_loc,
+    static Unit * queryNonPlayerUnitAtWorld(const iXY &amp; world_loc,
                                      const Uint16 player_id);
 
-    bool queryClosestEnemyUnitInRange(Unit **closest_unit_ptr,
+    static bool queryClosestEnemyUnitInRange(Unit **closest_unit_ptr,
                                       const iXY &amp;loc,
                                       unsigned long range,
                                       const Uint16 player_id);
 
 private:
     friend class UnitInterface;
-    UnitBucketArray( ) {}
-    ~UnitBucketArray( ) {}
+    
+    static void initialize(const iXY &amp; map_size, const iXY &amp; tile_size,
+                     const unsigned int x_sample, const unsigned int y_sample);
 
-    void sort();
-
-    void initialize( const iXY &amp; map_size, const iXY &amp; tile_size,
-                     const unsigned int x_sample, const unsigned int y_sample );
-    void initialize( const iXY &amp; map_size, const iXY &amp; tile_size)
+    static void initialize(const iXY &amp; map_size, const iXY &amp; tile_size)
     {
         initialize( map_size, tile_size, 10, 10 );
     }
+
+    static void cleanUp()
+    {
+        if ( buckets )
+        {
+            delete buckets;
+            buckets = 0;
+        }
+    }
+
+    static void sort();
     
-    void moveUnit( Unit * unit, const unsigned int from, const unsigned int to )
+    static void moveUnit(Unit * unit, const unsigned int from, const unsigned int to)
     {
         UnitList &amp; uli = getBucket(from);
         uli.erase(std::remove(uli.begin(), uli.end(), unit), uli.end());
         getBucket(to).push_back(unit);
     }
 
-    void cleanUp()
+    static Unit * getUnitAtWorldLoc(const UnitID unit_id, const iXY &amp; world_loc)
     {
-        buckets.clear();
-    }
-
-    Unit * getUnitAtWorldLoc( const UnitID unit_id, const iXY &amp; world_loc)
-    {
         UnitList &amp; uli = getBucketAssocWorldLoc(world_loc);
         UnitList::iterator iter;
         iter = std::find_if( uli.begin(), uli.end(), FindUnit(unit_id));
         return (iter != uli.end())?*iter:0;
     }
 
-    Unit * getUnitAtMapLoc( const UnitID unit_id, const iXY &amp; map_loc )
+    static Unit * getUnitAtMapLoc(const UnitID unit_id, const iXY &amp; map_loc)
     {
         UnitList &amp; uli = getBucketAssocMapLoc(map_loc);
         UnitList::iterator iter;
@@ -97,58 +100,60 @@
         return (iter != uli.end())?*iter:0;
     }
 
-    void addUnit( Unit *unit )
+    static void addUnit(Unit *unit)
     {
         getBucketAssocWorldLoc(unit-&gt;unit_state.location).push_back(unit);
     }
 
-    void removeUnit( const Unit *unit )
+    static void removeUnit(const Unit *unit)
     {
         UnitList &amp; uli = getBucketAssocWorldLoc(unit-&gt;unit_state.location);
         uli.erase(std::remove(uli.begin(), uli.end(), unit), uli.end());
     }
 
-    unsigned int getSize() const
+    static unsigned int getSize()
     {
-        return buckets.size();
+        return buckets-&gt;size();
     }
 
-    UnitList &amp; getBucket(const unsigned int bucket_index)
+    static UnitList &amp; getBucket(const unsigned int bucket_index)
     {
 //        assert( bucket_index &lt; getSize() );
-        return( buckets[ bucket_index ] );
+        return( (*buckets)[ bucket_index ] );
     }
 
-    UnitList &amp; getBucket( const unsigned int row, const unsigned int column )
+    static UnitList &amp; getBucket(const unsigned int row, const unsigned int col)
     {
-        return ( getBucket((row * column_size) + column) );
+        return ( getBucket((row * column_size) + col) );
     }
 
-    unsigned int mapLocToBucketIndex( const iXY &amp; map_loc ) const
+    static unsigned int mapLocToBucketIndex(const iXY &amp; map_loc)
     {
         return ((map_loc.y / map_y_sample_factor) * column_size)
                 + (map_loc.x / map_x_sample_factor);
     }
 
-    unsigned int worldLocToBucketIndex( const iXY &amp; world_loc ) const
+    static unsigned int worldLocToBucketIndex(const iXY &amp; world_loc)
     {
         return ((world_loc.y / pixel_y_sample_factor) * column_size)
                 + (world_loc.x / pixel_x_sample_factor);
     }
 
-    void worldLocToBucketLoc( const iXY &amp; world_loc, iXY &amp; bucket_loc ) const
+    static void worldLocToBucketLoc(const iXY &amp; world_loc, iXY &amp; bucket_loc)
     {
         bucket_loc.x = (world_loc.x-1) / pixel_x_sample_factor;
         bucket_loc.y = (world_loc.y-1) / pixel_y_sample_factor;
     }
 
-    void worldRectToBucketRect( const iRect &amp; world_rect, iRect &amp;bucket_rect ) const
+    static void worldRectToBucketRect(const iRect &amp; world_rect, iRect &amp;bucket_rect)
     {
         worldLocToBucketLoc(world_rect.min, bucket_rect.min);
         worldLocToBucketLoc(world_rect.max, bucket_rect.max);
     }
 
-    void unitRangeToBucketRect( const iXY&amp; world_loc, unsigned long range, iRect &amp;bucket_rect ) const
+    static void unitRangeToBucketRect(const iXY&amp; world_loc,
+                                      unsigned long range,
+                                      iRect &amp;bucket_rect)
     {
         worldLocToBucketLoc(world_loc, bucket_rect.min);
         worldLocToBucketLoc(world_loc, bucket_rect.max);
@@ -171,35 +176,35 @@
         }
     }
 
-    void mapLocToBucketLoc( const iXY &amp; map_loc, iXY &amp; bucket_loc) const
+    static void mapLocToBucketLoc(const iXY &amp; map_loc, iXY &amp; bucket_loc)
     {
         bucket_loc.x = map_loc.x / map_x_sample_factor;
         bucket_loc.y = map_loc.y / map_y_sample_factor;
     }
 
-    void mapRectToBucketRect( const iRect &amp; map_rect, iRect &amp;bucket_rect ) const
+    static void mapRectToBucketRect(const iRect &amp; map_rect, iRect &amp;bucket_rect)
     {
         mapLocToBucketLoc(map_rect.min, bucket_rect.min);
         mapLocToBucketLoc(map_rect.max, bucket_rect.max);
     }
 
-    UnitList &amp; getBucketAssocWorldLoc( const iXY &amp; world_loc )
+    static UnitList &amp; getBucketAssocWorldLoc(const iXY &amp; world_loc)
     {
         return getBucket(worldLocToBucketIndex(world_loc));
     }
 
-    UnitList &amp; getBucketAssocMapLoc( const iXY &amp; map_loc )
+    static UnitList &amp; getBucketAssocMapLoc(const iXY &amp; map_loc)
     {
         return getBucket(mapLocToBucketIndex(map_loc));
     }
 
-    BucketList buckets;
-    long map_x_sample_factor;
-    long map_y_sample_factor;
-    long pixel_x_sample_factor;
-    long pixel_y_sample_factor;
-    size_t row_size;
-    size_t column_size;
+    static BucketList* buckets;
+    static long map_x_sample_factor;
+    static long map_y_sample_factor;
+    static long pixel_x_sample_factor;
+    static long pixel_y_sample_factor;
+    static size_t row_size;
+    static size_t column_size;
 
     struct FindUnit
     {

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -19,6 +19,7 @@
 
 #include &lt;iostream&gt;
 #include &lt;algorithm&gt;
+#include &lt;cassert&gt;
 
 #include &quot;Core/GlobalEngineState.hpp&quot;
 #include &quot;Core/GlobalGameState.hpp&quot;
@@ -27,9 +28,11 @@
 #include &quot;UnitProfileInterface.hpp&quot;
 #include &quot;UnitBucketArray.hpp&quot;
 #include &quot;UnitOpcodeDecoder.hpp&quot;
-#include &quot;UnitBlackBoard.hpp&quot;
 #include &quot;Unit.hpp&quot;
 
+#include &quot;Classes/PlacementMatrix.hpp&quot;
+#include &quot;Classes/PlayerUnitConfig.hpp&quot;
+
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
@@ -51,32 +54,62 @@
 #include &quot;Util/Log.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
 
-UnitInterface::UnitInterface()
+BitArray*                      UnitInterface::unit_black_board = 0;
+UnitInterface::Units*          UnitInterface::units = 0;
+UnitInterface::PlayerUnitList* UnitInterface::playerUnitLists = 0;
+
+UnitOpcodeEncoder* UnitInterface::opcode_encoder = 0;
+
+// ******************************************************************
+
+static unsigned int units_per_player = 0;
+
+static Timer* message_timer = 0;
+static Timer* no_guarantee_message_timer = 0;
+
+
+// ******************************************************************
+
+static UnitID lastUnitID = 0;
+
+UnitID
+newUnitID()
 {
-    // nothing
-}
+    UnitID newID = lastUnitID++;
+    while( UnitInterface::getUnit(newID) != 0 )
+    {
+        newID = lastUnitID++;
+    }
 
-UnitInterface::~UnitInterface()
-{
-    // nothing
+    return newID;
 }
 
 void
 UnitInterface::initialize( const unsigned int max_units )
 {
-    unit_black_board.initialize(global_game_state-&gt;world_map-&gt;getWidth(),
-                                global_game_state-&gt;world_map-&gt;getHeight());
+    cleanUp();
 
-    unit_bucket_array.initialize(MapInterface::getSize(),
-                                 TileInterface::getTileSize());
+    unit_black_board = new BitArray(global_game_state-&gt;world_map-&gt;getWidth(),
+                                    global_game_state-&gt;world_map-&gt;getHeight());
 
-    playerUnitLists.resize(PlayerInterface::getMaxPlayers());
+    UnitBucketArray::initialize(MapInterface::getSize(),
+                                TileInterface::getTileSize());
 
+    units = new Units();
+
+    playerUnitLists = new PlayerUnitList();
+    playerUnitLists-&gt;resize(PlayerInterface::getMaxPlayers());
+
     lastUnitID = 0;
 
-    message_timer.changeRate( 8 );
-    no_guarantee_message_timer.changeRate( 15 );
+    message_timer = new Timer();
+    message_timer-&gt;changeRate( 8 );
 
+    no_guarantee_message_timer = new Timer();
+    no_guarantee_message_timer-&gt;changeRate( 15 );
+
+    opcode_encoder = new UnitOpcodeEncoder();
+
     units_per_player = max_units;
 }
 
@@ -84,17 +117,49 @@
 
 void UnitInterface::cleanUp()
 {
-    unit_black_board.cleanUp();
+    if ( unit_black_board )
+    {
+        delete unit_black_board;
+        unit_black_board = 0;
+    }
 
-    unit_bucket_array.cleanUp();
+    UnitBucketArray::cleanUp();
 
-    playerUnitLists.clear();
+    if ( playerUnitLists )
+    {
+        delete playerUnitLists;
+        playerUnitLists = 0;
+    }
 
-    for(Units::iterator i = units.begin(); i != units.end(); ++i)
+    if ( units )
     {
-        delete i-&gt;second;
+        for(Units::iterator i = units-&gt;begin(); i != units-&gt;end(); ++i)
+        {
+            delete i-&gt;second;
+        }
+
+        delete units;
+        units = 0;
     }
-    units.clear();
+
+    if ( message_timer )
+    {
+        delete message_timer;
+        message_timer = 0;
+    }
+
+    if ( no_guarantee_message_timer )
+    {
+        delete no_guarantee_message_timer;
+        no_guarantee_message_timer = 0;
+    }
+
+    if ( opcode_encoder )
+    {
+        delete opcode_encoder;
+        opcode_encoder = 0;
+    }
+
 }
 
 // ******************************************************************
@@ -111,7 +176,10 @@
 void
 UnitInterface::updateUnitStatus()
 {
-    for(Units::iterator i = units.begin(); i != units.end(); /*nothing*/ )
+//    iXY prev_unit_loc;
+//    iXY unit_map_loc;
+
+    for(Units::iterator i = units-&gt;begin(); i != units-&gt;end(); /*nothing*/ )
     {
         Unit* unit = i-&gt;second;
 
@@ -123,27 +191,37 @@
 
         ++i;
 
+//        prev_unit_loc = unit-&gt;unit_state.location;
+
         unsigned int bucket_before;
-        bucket_before = unit_bucket_array.worldLocToBucketIndex(
+        bucket_before = UnitBucketArray::worldLocToBucketIndex(
                                                     unit-&gt;unit_state.location );
 
         unit-&gt;updateState();
 
+//        if ( prev_unit_loc != unit-&gt;unit_state.location )
+//        {
+//            MapInterface::pointXYtoMapXY(prev_unit_loc, &amp;unit_map_loc);
+//            unmarkUnitLoc(unit_map_loc);
+//            MapInterface::pointXYtoMapXY(unit-&gt;unit_state.location, &amp;unit_map_loc);
+//            markUnitLoc(unit_map_loc);
+//        }
+
         unsigned int bucket_after;
-        bucket_after = unit_bucket_array.worldLocToBucketIndex(
+        bucket_after = UnitBucketArray::worldLocToBucketIndex(
                                                     unit-&gt;unit_state.location );
 
         if ( bucket_before != bucket_after )
         {
-            unit_bucket_array.moveUnit( unit, bucket_before, bucket_after );
+            UnitBucketArray::moveUnit( unit, bucket_before, bucket_after );
         }
     }
 
     if ( NetworkState::status == _network_state_server )
     {
-        if (message_timer.count())
+        if (message_timer-&gt;count())
         {
-            opcode_encoder.send();
+            opcode_encoder-&gt;send();
         }
     }
 }
@@ -159,7 +237,7 @@
     Unit * unit = 0;
 
     world_window_rect = sorter.getWorldWindow();
-    unit_bucket_array.worldRectToBucketRect(world_window_rect, bucket_rect);
+    UnitBucketArray::worldRectToBucketRect(world_window_rect, bucket_rect);
 
     for( int row_index = bucket_rect.min.y;
          row_index &lt;= bucket_rect.max.y;
@@ -169,7 +247,7 @@
              column_index &lt;= bucket_rect.max.x;
              ++column_index )
         {
-            UnitList &amp; bucket_list = unit_bucket_array.getBucket(row_index, column_index);
+            UnitList &amp; bucket_list = UnitBucketArray::getBucket(row_index, column_index);
 
             for( bucket_iter = bucket_list.begin();
                  bucket_iter != bucket_list.end();
@@ -218,7 +296,7 @@
                            const iXY &amp;location,
                            const Uint16 player_id )
 {
-    if (playerUnitLists[player_id].size() &gt;= units_per_player)
+    if ((*playerUnitLists)[player_id].size() &gt;= units_per_player)
     {
         return 0;
     }
@@ -243,8 +321,10 @@
 
     NetMessageEncoder encoder;
 
-    unit_placement_matrix.reset( location );
+    PlacementMatrix::reset( location );
 
+    LOGGER.warning(&quot;Spawning player: %d&quot;, player_id);
+
     for ( utype = 0; utype &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); ++utype )
     {
         numunits = unit_config.getSpawnUnitCount( utype );
@@ -252,7 +332,7 @@
         {
             --numunits;
 
-            unit_placement_matrix.getNextEmptyLoc( &amp;next_loc );
+            PlacementMatrix::getNextEmptyLoc( &amp;next_loc );
             unit = createUnit(utype, next_loc, player_id);
 
             assert(unit != 0);
@@ -275,30 +355,19 @@
     UMesgSelfDestruct self_destruct;
     self_destruct.setHeader(0);
 
-    UnitList&amp; unitlist = playerUnitLists[player_id];
-    for(UnitList::iterator i = unitlist.begin(); i != unitlist.end(); ++i)
+    const UnitList* unitlist = getPlayerUnits(player_id);
+    if ( unitlist )
     {
-        Unit* unit = *i;
-        unit-&gt;processMessage(&amp;self_destruct);
+        for(UnitList::const_iterator i = unitlist-&gt;begin(); i != unitlist-&gt;end(); ++i)
+        {
+            Unit* unit = *i;
+            unit-&gt;processMessage(&amp;self_destruct);
+        }
     }
 }
 
 // ******************************************************************
 
-UnitID
-UnitInterface::newUnitID()
-{
-    UnitID newID = lastUnitID++;
-    while(getUnit(newID) != 0)
-    {
-        newID = lastUnitID++;
-    }
-
-    return newID;
-}
-
-// ******************************************************************
-
 Unit *
 UnitInterface::newUnit( const unsigned short unit_type,
                         const iXY &amp;location,
@@ -313,7 +382,7 @@
 
     if ( unit_type &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes() )
     {
-        unit = new Unit(player, this, unit_type, id, location);
+        unit = new Unit(player, unit_type, id, location);
     }
     else
     {   // XXX change for a error window
@@ -328,9 +397,12 @@
 void
 UnitInterface::addUnit( Unit *unit )
 {
-    units.insert(std::make_pair(unit-&gt;id, unit));
-    playerUnitLists[unit-&gt;player-&gt;getID()].push_back(unit);
-    unit_bucket_array.addUnit(unit);
+    units-&gt;insert(std::make_pair(unit-&gt;id, unit));
+    (*playerUnitLists)[unit-&gt;player-&gt;getID()].push_back(unit);
+    iXY map_location;
+    MapInterface::pointXYtoMapXY(unit-&gt;unit_state.location, &amp;map_location);
+    markUnitLoc(map_location);
+    UnitBucketArray::addUnit(unit);
 }
 
 // ******************************************************************
@@ -347,12 +419,16 @@
     global_engine_state-&gt;sound_manager-&gt;playAmbientSound(&quot;expl&quot;,
             WorldViewInterface::getCameraDistance( unit-&gt;unit_state.location ));
 
-    unit_bucket_array.removeUnit(unit);
+    iXY map_location;
+    MapInterface::pointXYtoMapXY(unit-&gt;unit_state.location, &amp;map_location);
+    unmarkUnitLoc(map_location);
 
-    UnitList&amp; plist = playerUnitLists[unit-&gt;player-&gt;getID()];
+    UnitBucketArray::removeUnit(unit);
+
+    UnitList&amp; plist = (*playerUnitLists)[unit-&gt;player-&gt;getID()];
     plist.erase(std::remove(plist.begin(), plist.end(), unit), plist.end());
 
-    units.erase(i);
+    units-&gt;erase(i);
     delete unit;
 }
 
@@ -395,7 +471,7 @@
 {
     if ( message-&gt;message_id == _umesg_weapon_hit )
     {
-        UnitList &amp; uli = unit_bucket_array.getBucketAssocWorldLoc(
+        UnitList &amp; uli = UnitBucketArray::getBucketAssocWorldLoc(
                                 ((UMesgWeaponHit*)message)-&gt;getHitLocation() );
 
         for ( UnitList::iterator i = uli.begin(); i != uli.end(); ++i)
@@ -527,8 +603,8 @@
 
     try
     {
-        std::map&lt;UnitID, Unit*&gt;::iterator uit = units.find(create_mesg-&gt;getUnitID());
-        if ( uit != units.end() )
+        std::map&lt;UnitID, Unit*&gt;::iterator uit = units-&gt;find(create_mesg-&gt;getUnitID());
+        if ( uit != units-&gt;end() )
         {
             LOGGER.warning(&quot;UnitInterface::unitCreateMessage() Received an existing unit [%d]&quot;,
                             create_mesg-&gt;getUnitID());
@@ -539,7 +615,7 @@
                                  player_index, create_mesg-&gt;getUnitID());
         addUnit(unit);
         // remove unit from blackboard in client (we are client here)
-        global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( unitpos );
+        unmarkUnitLoc( unitpos );
     }
     catch(std::exception&amp; e)
     {
@@ -555,8 +631,8 @@
     const UnitRemoteDestroy* remote_destroy
         = (const UnitRemoteDestroy *) net_message;
 
-    Units::iterator i = units.find(remote_destroy-&gt;getUnitToDestroy());
-    if(i != units.end())
+    Units::iterator i = units-&gt;find(remote_destroy-&gt;getUnitToDestroy());
+    if(i != units-&gt;end())
     {
         removeUnit(i);
     }
@@ -572,8 +648,8 @@
 
     try
     {
-        std::map&lt;UnitID, Unit*&gt;::iterator uit = units.find(sync_message-&gt;getUnitID());
-        if ( uit != units.end() )
+        std::map&lt;UnitID, Unit*&gt;::iterator uit = units-&gt;find(sync_message-&gt;getUnitID());
+        if ( uit != units-&gt;end() )
         {
             LOGGER.warning(&quot;UnitInterface::unitSyncMessage() Received an existing unit [%d]&quot;,
                             sync_message-&gt;getUnitID());
@@ -620,5 +696,5 @@
 void
 UnitInterface::unitSyncIntegrityCheckMessage( const NetMessage* )
 {
-    unit_bucket_array.sort();
+    UnitBucketArray::sort();
 }

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -21,161 +21,134 @@
 
 #include &lt;vector&gt;
 #include &lt;map&gt;
-#include &lt;cassert&gt;
 #include &quot;Core/CoreTypes.hpp&quot;
 
+#include &quot;ArrayUtil/BitArray.hpp&quot;
 #include &quot;UnitBucketArray.hpp&quot;
 #include &quot;UnitOpcodeEncoder.hpp&quot;
 
-#include &quot;Classes/PlacementMatrix.hpp&quot;
-#include &quot;Classes/PlayerUnitConfig.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
-
-enum
-{
-    _search_all_players,
-    _search_player,
-    _search_exclude_player,
-    _search_enemy_only
-};
-
-enum { _no_unit_found, _unit_player, _unit_allied, _unit_enemy };
-
 class NetPacket;
+class PlayerUnitConfig;
+class SpriteSorter;
 
 class UnitInterface
 {
 public:
-    UnitBucketArray unit_bucket_array;
-
-    UnitInterface();
-    ~UnitInterface();
-
     // type definitions
     typedef std::map&lt;UnitID, Unit*&gt; Units;
     typedef std::vector&lt;UnitList&gt; PlayerUnitList;
 
     // initialization/cleanup
-    void initialize( const unsigned int max_units );
-    void cleanUp();
-    void reset();
+    static void initialize( const unsigned int max_units );
+    static void cleanUp();
+    static void reset();
 
     // unit getters
-    Unit * getUnit( UnitID id )
+    static Unit * getUnit( UnitID id )
     {
-        Units::iterator i = units.find(id);
-        return (i!=units.end())?i-&gt;second:0;
+        Units::iterator i = units-&gt;find(id);
+        return (i!=units-&gt;end())?i-&gt;second:0;
     }
 
-    const Units&amp; getUnits()
+    static const Units* getUnits()
     {
         return units;
     }
-
-    const UnitList&amp; getPlayerUnits( const Uint16 player_id )
+    
+    static const UnitList* getPlayerUnits( const Uint16 player_id )
     {
-        assert(player_id &lt; playerUnitLists.size());
-        return playerUnitLists[player_id];
+        if ( player_id &lt; playerUnitLists-&gt;size() )
+        {
+            return &amp;(*playerUnitLists)[player_id];
+        }
+        return 0;
     }
 
-    size_t getUnitCount( const Uint16 player_index )
+    static size_t getPlayerUnitCount( const Uint16 player_id )
     {
-        return getPlayerUnits(player_index).size();
+        if ( player_id &lt; playerUnitLists-&gt;size() )
+        {
+            return (*playerUnitLists)[player_id].size();
+        }
+        return 0;
     }
 
-    size_t getTotalUnitCount()
+    static size_t getTotalUnitCount()
     {
-        return units.size();
+        return units-&gt;size();
     }
 
     // main loop methods
-    void updateUnitStatus();
+    static void updateUnitStatus();
 
     // graphic methods
-    void offloadGraphics( SpriteSorter &amp;sorter );
+    static void offloadGraphics( SpriteSorter &amp;sorter );
 
     // unit creation
-    Unit* createUnit( const unsigned short unit_type,
-                             const iXY &amp;location,
-                             const Uint16 player_id);
+    static Unit* createUnit(const unsigned short unit_type,
+                            const iXY &amp;location,
+                            const Uint16 player_id);
 
-    void spawnPlayerUnits( const iXY &amp; location,
-                                  const Uint16 player_id,
-                                  const PlayerUnitConfig &amp; unit_config );
+    static void spawnPlayerUnits(const iXY &amp; location,
+                                 const Uint16 player_id,
+                                 const PlayerUnitConfig &amp; unit_config );
 
-    void destroyPlayerUnits( const Uint16 player_id );
+    static void destroyPlayerUnits( const Uint16 player_id );
 
     // message methods
-    void processNetPacket( const NetPacket* packet );
-    void sendMessage( const UnitMessage* message,
+    static void processNetPacket( const NetPacket* packet );
+    static void sendMessage( const UnitMessage* message,
                              const PlayerState* player = 0 );
 
-    void processNetMessage( const NetMessage *net_message );
+    static void processNetMessage( const NetMessage *net_message );
 
-    bool unitOccupiesLoc( iXY &amp;unit_map_loc )
+    static bool unitOccupiesLoc(const iXY &amp;unit_map_loc)
     {
-        return unit_black_board.unitOccupiesLoc(unit_map_loc);
+        return unit_black_board-&gt;getBit(unit_map_loc.x, unit_map_loc.y);
     }
 
-    void markUnitLoc( iXY &amp;unit_map_loc )
+    static void markUnitLoc(const iXY &amp;unit_map_loc)
     {
-        unit_black_board.markUnitLoc(unit_map_loc);
+        unit_black_board-&gt;setBit(unit_map_loc.x, unit_map_loc.y);
     }
 
-    void unmarkUnitLoc( iXY &amp;unit_map_loc )
+    static void unmarkUnitLoc(const iXY &amp;unit_map_loc)
     {
-        unit_black_board.unmarkUnitLoc(unit_map_loc);
+        unit_black_board-&gt;clearBit(unit_map_loc.x, unit_map_loc.y);
     }
 
 private:
     friend class Unit;
+    UnitInterface();
+    ~UnitInterface();
 
-    UnitBlackBoard unit_black_board;
     // Unit Message Handler Methods
-    void unitManagerMesgEndLifecycle( const UnitMessage *message );
+    static void unitManagerMesgEndLifecycle( const UnitMessage *message );
 
-    // Network Message Handler Variables
-    Timer message_timer;
-    Timer no_guarantee_message_timer;
-    UnitOpcodeEncoder opcode_encoder;
-
     // Network Message Handler Methods
-    void sendOpcode( const UnitOpcode* opcode )
+    static void sendOpcode( const UnitOpcode* opcode )
     {
-        opcode_encoder.encode(opcode);
+        opcode_encoder-&gt;encode(opcode);
     }
 
-    void unitCreateMessage( const NetMessage *net_message );
-    void unitDestroyMessage( const NetMessage *net_message );
-    void unitSyncMessage( const NetMessage *net_message );
-    void unitOpcodeMessage( const NetMessage *net_message );
-    void unitSyncIntegrityCheckMessage( const NetMessage *net_message );
+    static void unitCreateMessage( const NetMessage *net_message );
+    static void unitDestroyMessage( const NetMessage *net_message );
+    static void unitSyncMessage( const NetMessage *net_message );
+    static void unitOpcodeMessage( const NetMessage *net_message );
+    static void unitSyncIntegrityCheckMessage( const NetMessage *net_message );
 
-    unsigned long  sync_units_iterator;
-    bool           sync_units_complete_flag;
-    unsigned short sync_units_list_index;
-    Timer	  sync_units_packet_timer;
-    unsigned long  sync_units_in_sync_count;
-    unsigned long  sync_units_in_sync_partial_count;
-    unsigned long  sync_units_total_units;
-
-    Units units;
-    PlayerUnitList playerUnitLists;
-        
-    unsigned int units_per_player;
-    PlacementMatrix unit_placement_matrix;
-
-    Uint16 lastUnitID;
-    UnitID newUnitID();
-
-    Unit* newUnit( const unsigned short unit_type,
+    static Unit* newUnit( const unsigned short unit_type,
                           const iXY &amp;location,
                           const unsigned short player_index,
                           const UnitID id );
 
-    void addUnit( Unit *unit );
-    
-    void removeUnit( Units::iterator i );
+    static void addUnit( Unit *unit );
+    static void removeUnit( Units::iterator i );
+
+    static Units* units;
+    static PlayerUnitList* playerUnitLists;
+    static BitArray* unit_black_board;
+    static UnitOpcodeEncoder* opcode_encoder;
 };
 
 #endif // ** _UNITINTERFACE_HPP

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -47,7 +47,7 @@
              &quot;game %s | units %3d/%-3d | frags %4d/%-4d | objs. %3d/%-3d | time %02d:%02d/%02d:%02d | FPS %.2f&quot;,
              gameconfig-&gt;getGameTypeString(),
              
-             int(global_game_state-&gt;unit_manager-&gt;getUnitCount(PlayerInterface::getLocalPlayerIndex())),
+             int(UnitInterface::getPlayerUnitCount(PlayerInterface::getLocalPlayerIndex())),
              gameconfig-&gt;maxunits / gameconfig-&gt;maxplayers,
              
              PlayerInterface::getLocalPlayer()-&gt;getTotal(),

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -215,9 +215,9 @@
 void
 MiniMap::drawUnits(Surface &amp;dest)
 {
-    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
-    for(UnitInterface::Units::const_iterator i = units.begin();
-            i != units.end(); ++i)
+    const UnitInterface::Units* units = UnitInterface::getUnits();
+    for(UnitInterface::Units::const_iterator i = units-&gt;begin();
+            i != units-&gt;end(); ++i)
     {
         Unit* unit = i-&gt;second;
         IntColor color;

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -303,7 +303,7 @@
 
     for ( int i = 0; i &lt; max_players; i++ ) {
         unsigned long units;
-        units = global_game_state-&gt;unit_manager-&gt;getUnitCount( i );
+        units = UnitInterface::getPlayerUnitCount( i );
         total += units;
 
         sprintf(strBuf, &quot;Player %d : %lu  &quot;, i, units);

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -115,7 +115,7 @@
     ParticleSystem2D::drawAll( SPRITE_SORTER );
     Particle2D::drawAll( SPRITE_SORTER );
 
-    global_game_state-&gt;unit_manager-&gt;offloadGraphics( SPRITE_SORTER );
+    UnitInterface::offloadGraphics( SPRITE_SORTER );
     ProjectileInterface::offloadGraphics( SPRITE_SORTER );
     ObjectiveInterface::offloadGraphics( SPRITE_SORTER );
     PowerUpInterface::offloadGraphics( SPRITE_SORTER );

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -406,7 +406,7 @@
     }
 
     int unitPerPlayer = gameconfig-&gt;maxunits / gameconfig-&gt;maxplayers;
-    sprintf(strBuf, &quot;%d/%d&quot;, int(global_game_state-&gt;unit_manager-&gt;getUnitCount(PlayerInterface::getLocalPlayerIndex())), unitPerPlayer);
+    sprintf(strBuf, &quot;%d/%d&quot;, int(UnitInterface::getPlayerUnitCount(PlayerInterface::getLocalPlayerIndex())), unitPerPlayer);
     drawString(unitsBuiltPos.x, unitsBuiltPos.y, strBuf, color);
 
     drawUnitProfileInfo( iXY(0, unitProfileDataY), highlightedUnitType);

Modified: trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -65,7 +65,7 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
+                    UnitInterface::sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;

Modified: trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -114,7 +114,7 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
+                    UnitInterface::sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;

Modified: trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -89,7 +89,7 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
+                    UnitInterface::sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;

Modified: trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp	2009-12-20 15:33:47 UTC (rev 1151)
+++ trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp	2009-12-27 14:50:29 UTC (rev 1152)
@@ -116,7 +116,7 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
+                    UnitInterface::sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000179.html">[Netpanzer-cvs] r1151 - in trunk/netpanzer: . scripts src/Lib	src/Lib/2D src/Lib/Util src/Lib/toluapp src/NetPanzer/Classes	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/Scripts src/NetPanzer/Scripts/bindings	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Views/Components
</A></li>
	<LI>Next message: <A HREF="000181.html">[Netpanzer-cvs] r1153 - in trunk/netpanzer: scripts	src/NetPanzer/Bot src/NetPanzer/Classes	src/NetPanzer/Classes/Network src/NetPanzer/Core	src/NetPanzer/Interfaces src/NetPanzer/Scripts	src/NetPanzer/Scripts/toluapkg src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
