<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1066 - trunk/netpanzer/src/NetPanzer/Units
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1066%20-%20trunk/netpanzer/src/NetPanzer/Units&In-Reply-To=%3C200809210351.m8L3pNdo016690%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000101.html">
   <LINK REL="Next"  HREF="000103.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1066 - trunk/netpanzer/src/NetPanzer/Units</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1066%20-%20trunk/netpanzer/src/NetPanzer/Units&In-Reply-To=%3C200809210351.m8L3pNdo016690%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1066 - trunk/netpanzer/src/NetPanzer/Units">kromxp at mail.berlios.de
       </A><BR>
    <I>Sun Sep 21 05:51:23 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000101.html">[Netpanzer-cvs] r1065 - in trunk/netpanzer/src/NetPanzer:	Interfaces Units Views/Game
</A></li>
        <LI>Next message: <A HREF="000103.html">[Netpanzer-cvs] r1067 - in trunk/netpanzer: nbproject	src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#102">[ date ]</a>
              <a href="thread.html#102">[ thread ]</a>
              <a href="subject.html#102">[ subject ]</a>
              <a href="author.html#102">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2008-09-21 05:51:15 +0200 (Sun, 21 Sep 2008)
New Revision: 1066

Modified:
   trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp
Log:
- No real change, only reformat vehicle.cpp to be more readable

Modified: trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2008-09-21 02:51:00 UTC (rev 1065)
+++ trunk/netpanzer/src/NetPanzer/Units/Vehicle.cpp	2008-09-21 03:51:15 UTC (rev 1066)
@@ -165,58 +165,57 @@
 
     if ( (unit_state.lifecycle_state == _UNIT_LIFECYCLE_PENDING_DESTRUCT) &amp;&amp;
             (ai_command_state == _ai_command_idle)
-       ) {
+       )
+    {
         unit_state.lifecycle_state = _UNIT_LIFECYCLE_DESTROYED;
         death_counter = 0;
     }
 
-    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_DESTROYED ) {
-        if ( death_counter == 5 ) {
+    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+    {
+        if ( death_counter == 5 )
+        {
             unit_state.lifecycle_state = _UNIT_LIFECYCLE_INACTIVE;
 
             DestructUnitOpcode destruct_opcode;
             destruct_opcode.setUnitID(id);
             UnitInterface::sendOpcode(&amp;destruct_opcode);
-        } else
+        }
+        else
+        {
             death_counter++;
+        }
     }
 }
 
 void Vehicle::orientationToOffset( unsigned short orientation, signed char *offset_x, signed char *offset_y )
 {
-    switch ( orientation ) {
-    case 0: {
+    switch ( orientation )
+    {
+        case 0:
             *offset_x =  1; *offset_y =  0;
-        }
-        break;
-    case 1: {
+            break;
+        case 1:
             *offset_x =  1; *offset_y = -1;
-        }
-        break;
-    case 2: {
+            break;
+        case 2:
             *offset_x =  0; *offset_y = -1;
-        }
-        break;
-    case 3: {
+            break;
+        case 3:
             *offset_x = -1; *offset_y = -1;
-        }
-        break;
-    case 4: {
+            break;
+        case 4:
             *offset_x = -1; *offset_y =  0;
-        }
-        break;
-    case 5: {
+            break;
+        case 5:
             *offset_x = -1; *offset_y =  1;
-        }
-        break;
-    case 6: {
+            break;
+        case 6:
             *offset_x =  0; *offset_y =  1;
-        }
-        break;
-    case 7: {
+            break;
+        case 7:
             *offset_x =  1; *offset_y =  1;
-        }
-        break;
+            break;
     }
 
 }
@@ -227,43 +226,52 @@
 
     MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
     MapInterface::offsetToMapXY( square, &amp;next_loc );
-
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y == current_loc.y) ) {
+    
+    // so many magic numbers
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y == current_loc.y) )
+    {
         *goal_angle = 0;
         return( 0 );
     }
 
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) ) {
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
         *goal_angle = 5;
         return( 1 );
     }
 
-    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) ) {
+    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
         *goal_angle = 9;
         return( 2 );
     }
 
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y)   ) {
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &lt; current_loc.y) )
+    {
         *goal_angle = 14;
         return( 3 );
     }
 
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y  == current_loc.y)  ) {
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y  == current_loc.y) )
+    {
         *goal_angle = 18;
         return( 4 );
     }
 
-    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) ) {
+    if ( (next_loc.x &lt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
         *goal_angle = 23;
         return( 5 );
     }
 
-    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) ) {
+    if ( (next_loc.x == current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
         *goal_angle = 27;
         return( 6 );
     }
 
-    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) ) {
+    if ( (next_loc.x &gt; current_loc.x)  &amp;&amp;  (next_loc.y &gt; current_loc.y) )
+    {
         *goal_angle = 32;
         return( 7 );
     }
@@ -287,10 +295,13 @@
     else
         delta_minus = (angle.angle_int ) - ( goal_angle );
 
-    if (delta_minus &gt; delta_plus) {
+    if (delta_minus &gt; delta_plus)
+    {
         *delta = delta_plus;
         return( _rotate_pos );
-    } else {
+    }
+    else
+    {
         *delta = delta_minus;
         return( _rotate_neg );
     }
@@ -315,13 +326,19 @@
 
 bool Vehicle::fsmBodyRotate()
 {
-    if( unit_state.body_angle.angle_int != fsmBodyRotate_goal_angle ) {
-        if ( fsmBodyRotate_rotation == _rotate_pos ) {
+    if( unit_state.body_angle.angle_int != fsmBodyRotate_goal_angle )
+    {
+        if ( fsmBodyRotate_rotation == _rotate_pos )
+        {
             ++unit_state.body_angle;
-        } else {
+        }
+        else
+        {
             --unit_state.body_angle;
         }  // ** else turn_rotation **
-    } else {
+    }
+    else
+    {
         return( true );   // goal direction achieved
     }
 
@@ -336,13 +353,19 @@
 
 bool Vehicle::fsmTurretRotate()
 {
-    if( unit_state.turret_angle.angle_int != fsmTurretRotate_goal_angle ) {
-        if ( fsmTurretRotate_rotation == _rotate_pos ) {
+    if( unit_state.turret_angle.angle_int != fsmTurretRotate_goal_angle )
+    {
+        if ( fsmTurretRotate_rotation == _rotate_pos )
+        {
             ++unit_state.turret_angle;
-        } else {
+        }
+        else
+        {
             --unit_state.turret_angle;
         }  // ** else turn_rotation **
-    } else {
+    }
+    else
+    {
         return( true );   // goal direction achieved
     }
 
@@ -385,7 +408,8 @@
      }
     */
 
-    if ( fsmMove_moves_counter &lt; fsmMove_moves_per_square ) {
+    if ( fsmMove_moves_counter &lt; fsmMove_moves_per_square )
+    {
         /*
         fsmMove_moves_counter += move_offset;
 
@@ -404,7 +428,8 @@
         //start_move_stamp = now();
     }
 
-    if( fsmMove_moves_counter &gt;= fsmMove_moves_per_square) {
+    if( fsmMove_moves_counter &gt;= fsmMove_moves_per_square)
+    {
         //fsmMove_first_stamp = true;
         fsm_timer.changeRate( 10 );
         return( true );
@@ -433,7 +458,8 @@
     fsm_active_list[ _control_move_map_square ] = true;
     critical_ai_section = true;
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         iXY loc_offset;
 
         move_opcode.opcode = _UNIT_OPCODE_MOVE;
@@ -443,8 +469,9 @@
         move_opcode.loc_x_offset = (signed char) loc_offset.x;
         move_opcode.loc_y_offset = (signed char) loc_offset.y;
         if ( move_opcode_sent == true )
+        {
             UnitInterface::sendOpcode(&amp;move_opcode);
-
+        }
     }
 
 }
@@ -455,41 +482,51 @@
 bool Vehicle::fsmMoveMapSquare()
 {
     if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
-        if ( opcode_move_timer.count() ) {
+    {
+        if ( opcode_move_timer.count() )
+        {
             UnitInterface::sendOpcode(&amp;move_opcode);
             move_opcode_sent = true;
         }
+    }
 
-    switch( fsmMoveMapSquare_movement_type ) {
-    case  _rotate_stop_move : {
+    switch( fsmMoveMapSquare_movement_type )
+    {
+        case  _rotate_stop_move :
+        {
             if ( fsmBodyRotate() )
-                if ( fsmMove() ) {
+            {
+                if ( fsmMove() )
+                {
                     fsm_active_list[ _control_move_map_square ] = false;
                     critical_ai_section = false;
 
-                    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server ) {
+                    if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
+                    {
                         UnitInterface::sendOpcode(&amp;move_opcode);
                         move_opcode_sent = true;
                     }
-
-
+                    
                     return( true );
                 }
+            }
         }
         break;
 
-    case _rotate_and_move : {
+        case _rotate_and_move :
+        {
             fsmBodyRotate();
-            if ( fsmMove() ) {
+            if ( fsmMove() )
+            {
                 fsm_active_list[ _control_move_map_square ] = false;
                 critical_ai_section = false;
 
-                if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server ) {
+                if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
+                {
                     UnitInterface::sendOpcode(&amp;move_opcode);
                     move_opcode_sent = true;
                 }
 
-
                 return( true );
             }
         }
@@ -512,7 +549,8 @@
 
     fsm_active_list[ _control_turret_track_point ] = true;
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         TurretTrackPointOpcode track_point_opcode;
         track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
         track_point_opcode.setUnitID(id);
@@ -529,7 +567,8 @@
 
     fsmTurretTrackPoint_on_target = false;
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         TurretTrackPointOpcode track_point_opcode;
         track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
         track_point_opcode.setUnitID(id);
@@ -540,7 +579,8 @@
 
 void Vehicle::syncFsmTurretTrackPoint()
 {
-    if ( fsm_active_list[ _control_turret_track_point ] == true ) {
+    if ( fsm_active_list[ _control_turret_track_point ] == true )
+    {
         TurretTrackPointOpcode track_point_opcode;
         track_point_opcode.flags = _unit_opcode_flag_sync;
         track_point_opcode.opcode = _UNIT_OPCODE_TURRET_TRACK_POINT;
@@ -578,7 +618,8 @@
     fsmTurretTrackTarget_target_id = target_id;
     fsm_active_list[ _control_turret_track_target ] = true;
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         TurretTrackTargetOpcode track_target_opcode;
         track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
         track_target_opcode.setUnitID(id);
@@ -593,7 +634,8 @@
 {
     fsm_active_list[ _control_turret_track_target ] = false;
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         TurretTrackTargetOpcode track_target_opcode;
         track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
         track_target_opcode.setUnitID(id);
@@ -605,7 +647,8 @@
 
 void Vehicle::syncFsmTurretTrackTarget()
 {
-    if ( fsm_active_list[ _control_turret_track_target ] == true ) {
+    if ( fsm_active_list[ _control_turret_track_target ] == true )
+    {
         TurretTrackTargetOpcode track_target_opcode;
         track_target_opcode.opcode  = _UNIT_OPCODE_TURRET_TRACK_TARGET;
         track_target_opcode.flags = _unit_opcode_flag_sync;
@@ -628,7 +671,8 @@
 
     target_unit_ptr = UnitInterface::getUnit( fsmTurretTrackTarget_target_id );
 
-    if ( target_unit_ptr != 0 ) {
+    if ( target_unit_ptr != 0 )
+    {
         direction_vector = target_unit_ptr-&gt;unit_state.location - unit_state.location;
         Angle float_angle( direction_vector );
 
@@ -637,9 +681,12 @@
         setFsmTurretRotate( goal_angle, rotation );
     }
 
-    if ( fsmTurretRotate() == true ) {
+    if ( fsmTurretRotate() == true )
+    {
         fsmTurretTrackTarget_on_target = true;
-    } else {
+    }
+    else
+    {
         fsmTurretTrackTarget_on_target = false;
     }
 }
@@ -648,7 +695,8 @@
 
 void Vehicle::setFsmGunneryLocation(const iXY&amp; target )
 {
-    if ( fsm_active_list[ _control_gunnery_target ] == true ) {
+    if ( fsm_active_list[ _control_gunnery_target ] == true )
+    {
         clearFsmGunneryTarget();
     }
 
@@ -672,7 +720,8 @@
     if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
             (fsmTurretTrackPoint_on_target == true) &amp;&amp;
             (reload_counter &gt;= unit_state.reload_time)
-       ) {
+       )
+    {
         fireWeapon( fsmGunneryLocation_target );
         clearFsmGunneryLocation();
     }
@@ -681,11 +730,13 @@
 
 void Vehicle::setFsmGunneryTarget(UnitID target_id)
 {
-    if ( fsm_active_list[ _control_gunnery_location ] == true ) {
+    if ( fsm_active_list[ _control_gunnery_location ] == true )
+    {
         clearFsmGunneryLocation();
     }
 
-    if ( fsm_active_list[ _control_turret_track_point ] == true ) {
+    if ( fsm_active_list[ _control_turret_track_point ] == true )
+    {
         clearFsmTurretTrackPoint();
     }
 
@@ -707,26 +758,30 @@
     iXY range_vector;
 
     target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
-    if ( target_unit_ptr == 0 ) {
+    if ( target_unit_ptr == 0 )
+    {
         clearFsmGunneryTarget();
-    } else {
+    }
+    else
+    {
         target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
 
-        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED ) {
+        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+        {
             clearFsmGunneryTarget();
-        } // ** if
-        else {
+        }
+        else
+        {
             range_vector = target_unit_state-&gt;location - unit_state.location;
 
             if ( (range_vector.mag2() &lt; unit_state.weapon_range) &amp;&amp;
                     (fsmTurretTrackTarget_on_target == true) &amp;&amp;
                     (reload_counter == unit_state.reload_time )
-               ) {
+               )
+            {
                 fireWeapon( target_unit_state-&gt;location );
             }
-
         }
-
     }
 
 
@@ -734,7 +789,8 @@
 
 void Vehicle::aiFsmIdle()
 {
-    if ( pending_AI_comm == true ) {
+    if ( pending_AI_comm == true )
+    {
         ai_fsm_transition_complete = true;
     }
 
@@ -755,16 +811,20 @@
 {
     bool end_cycle = false;
 
-    do {
-        switch ( aiFsmMoveToLoc_state ) {
+    do
+    {
+        switch ( aiFsmMoveToLoc_state )
+        {
 
             // *************************************************************
-        case _aiFsmMoveToLoc_path_generate : {
+            case _aiFsmMoveToLoc_path_generate :
+            {
                 // QueryPath: Has a path been generated for unit ?
                 path_generated = PathScheduler::queryPath(id);
 
 
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+                if ( external_ai_event == _external_event_pending_unit_destruct  )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmMoveToLoc_OnExitCleanUp();
@@ -776,30 +836,35 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmMoveToLoc_OnExitCleanUp();
-                        end_cycle = true;
-                    } else
-                        if ( path_generated == true ) {
-                            // Rule QueryPath: is true move to next state
-                            //LOG( (&quot;Path Successfully Generated&quot;) );
-                            aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                        } else
-                            end_cycle = true;
-
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( path_generated == true )
+                {
+                    // Rule QueryPath: is true move to next state
+                    //LOG( (&quot;Path Successfully Generated&quot;) );
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+                }
+                else
+                {
+                    end_cycle = true;                    
+                }
             }
             break;
 
             // *************************************************************
 
-        case _aiFsmMoveToLoc_check_goal : {
-
+            case _aiFsmMoveToLoc_check_goal :
+            {
                 //  GoalReached: Has the goal been reached ?
-                if ( ruleMoveToLoc_GoalReached() == true ) {
+                if ( ruleMoveToLoc_GoalReached() == true )
+                {
                     // Rule GoalReached : is true
                     // Action : Exit fsm
                     aiFsmMoveToLoc_prev_loc = unit_state.location;
@@ -810,8 +875,11 @@
                     setAiFsmDefendHold();
 
                     end_cycle = true;
-                } else {
-                    if ( aiFsmMoveToLoc_path_not_finished == false ) {
+                }
+                else
+                {
+                    if ( aiFsmMoveToLoc_path_not_finished == false )
+                    {
                         //  Rule: GoalReached is false AND Unit is at the end of path
                         //  Action : Request path generation to goal
                         iXY start;
@@ -823,7 +891,9 @@
                         PathScheduler::requestPath( path_request );
                         aiFsmMoveToLoc_path_not_finished = true;
                         aiFsmMoveToLoc_state = _aiFsmMoveToLoc_path_generate;
-                    } else {
+                    }
+                    else
+                    {
                         // Rule GoalReached: is false
                         // Action: Get next move;
                         aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
@@ -834,17 +904,20 @@
 
             // *************************************************************
 
-        case _aiFsmMoveToLoc_next_move : {
+            case _aiFsmMoveToLoc_next_move :
+            {
                 // CurrentPathComplete: is Unit at the end of the current path
                 aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
                 MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
 
-
-                if ( !aiFsmMoveToLoc_path_not_finished ) {
+                if ( !aiFsmMoveToLoc_path_not_finished )
+                {
                     // Rule: CurrentPathComplete is true
                     // Action : check if unit is at the goal
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                } else {
+                }
+                else
+                {
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
                     aiFsmMoveToLoc_prev_loc = unit_state.location;
@@ -854,13 +927,13 @@
                     aiFsmMoveToLoc_wait_timer.changePeriod( 0.8f );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_wait_clear_loc;
                 }
-
             }
             break;
 
             // *************************************************************
 
-        case _aiFsmMoveToLoc_wait_clear_loc : {
+            case _aiFsmMoveToLoc_wait_clear_loc :
+            {
 
                 if ( external_ai_event == _external_event_pending_unit_destruct  )
                 {
@@ -874,14 +947,13 @@
                 }
                 else if ( pending_AI_comm == true )
                 {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmMoveToLoc_OnExitCleanUp();
-                        end_cycle = true;
-                }
-                else  // NextSquareOccupied: does the next square contain a abstruction
-                    if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                } // NextSquareOccupied: does the next square contain a abstruction
+                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
                 {
                     // Rule: NextSquareOccupied is true
                     // Action: Check Wait Timer
@@ -890,7 +962,6 @@
                     {
                         // Rule: NextSquareOccupied is true AND WaitTimer is finished
                         // Action: Preform path update
-
                         if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
                         {
 
@@ -928,15 +999,19 @@
 
             // *************************************************************
 
-        case _aiFsmMoveToLoc_move_wait : {
+            case _aiFsmMoveToLoc_move_wait :
+            {
                 // MoveFinished : has the low level fsm finshed
-                if ( fsm_active_list[ _control_move_map_square ] == false ) {
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
                     // Rule: MoveFinished is true
                     // Action: Check for a pending transition
                     UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
                     end_cycle = true;
-                } else {
+                }
+                else
+                {
                     end_cycle = true;
                 } // ** else
 
@@ -945,8 +1020,10 @@
 
             // *************************************************************
 
-        case _aiFsmMoveToLoc_check_fsm_transition : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+            case _aiFsmMoveToLoc_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmMoveToLoc_OnExitCleanUp();
@@ -954,23 +1031,25 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmMoveToLoc_OnExitCleanUp();
-                        end_cycle = true;
-                    } else {
-                        aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
-                    }
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmMoveToLoc_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
+                }
 
             }
             break;
-
-
+            
         } // ** switch
-
+        
     } while (end_cycle == false);
 }
 
@@ -989,20 +1068,26 @@
 
     UnitBase* target_unit_ptr 
         = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
-    if ( target_unit_ptr == 0 ) {
+    if ( target_unit_ptr == 0 )
+    {
         aiFsmAttackUnit_target_destroyed = true;
-        if(aiFsmAttackUnit_state != _aiFsmAttackUnit_move_wait) {
+        if(aiFsmAttackUnit_state != _aiFsmAttackUnit_move_wait)
+        {
             setAiFsmDefendHold();
             aiFsmAttackUnit_OnExitCleanUp();
             return;
         }
-    } else {
+    }
+    else
+    {
         target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
 
-        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED ) {
+        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+        {
             aiFsmAttackUnit_target_destroyed = true;
 
-            if ( aiFsmAttackUnit_state !=  _aiFsmAttackUnit_move_wait ) {
+            if ( aiFsmAttackUnit_state !=  _aiFsmAttackUnit_move_wait )
+            {
                 setAiFsmDefendHold();
                 aiFsmAttackUnit_OnExitCleanUp();
                 return;
@@ -1010,15 +1095,19 @@
         }
     }
 
-    do {
-        switch ( aiFsmAttackUnit_state ) {
+    do
+    {
+        switch ( aiFsmAttackUnit_state )
+        {
             // *************************************************************
 
-        case _aiFsmAttackUnit_path_generate : {
+            case _aiFsmAttackUnit_path_generate :
+            {
                 // QueryPath: Has a path been generated for unit ?
                 path_generated = PathScheduler::queryPath(id);
 
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
@@ -1030,30 +1119,36 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmAttackUnit_OnExitCleanUp();
-                        end_cycle = true;
-                    } else
-                        if ( path_generated == true ) {
-                            // Rule QueryPath: is true move to next state
-                            aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
-                        } else
-                            end_cycle = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( path_generated == true )
+                {
+                    // Rule QueryPath: is true move to next state
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
+                }
+                else
+                {
+                    end_cycle = true;
+                }
 
             }
             break;
             // *************************************************************
 
-        case _aiFsmAttackUnit_range_check : {
-
+            case _aiFsmAttackUnit_range_check :
+            {
                 // RangeVector: the absolute distance between unit and target
                 range_vector = target_unit_state-&gt;location - unit_state.location;
 
-                if ( range_vector.mag2() &lt; unit_state.weapon_range ) {
+                if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                {
                     // Rule: RangeVector &lt; WeaponRange, unit is in range
                     // Action: Remain in position
                     aiFsmAttackUnit_prev_loc = unit_state.location;
@@ -1061,8 +1156,11 @@
                     UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
                     end_cycle = true;
-                } else {
-                    if ( aiFsmAttackUnit_path_not_finished == false ) {
+                }
+                else
+                {
+                    if ( aiFsmAttackUnit_path_not_finished == false )
+                    {
                         iXY start;
                         MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
 
@@ -1072,7 +1170,9 @@
 
                         aiFsmAttackUnit_path_not_finished = true;
                         aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-                    } else {
+                    }
+                    else
+                    {
                         // Rule: RangeVector &gt; WeaponRange
                         // Action: Get next move
                         aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
@@ -1082,10 +1182,12 @@
             break;
             // *************************************************************
 
-        case _aiFsmAttackUnit_idle : {
+            case _aiFsmAttackUnit_idle :
+            {
                 range_vector = target_unit_state-&gt;location - unit_state.location;
 
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
@@ -1093,39 +1195,46 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmAttackUnit_OnExitCleanUp();
-                        end_cycle = true;
-                    } else
-                        if ( range_vector.mag2() &lt; unit_state.weapon_range ) {
-                            // Rule: RangeVector &lt; WeaponRange, unit is in range
-                            // Action: Remain in position
-                            end_cycle = true;
-                        } else {
-                            // Rule: RangeVector &gt; WeaponRange
-                            // Action: Get next move
-                            aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
-                        }
-
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( range_vector.mag2() &lt; unit_state.weapon_range )
+                {
+                    // Rule: RangeVector &lt; WeaponRange, unit is in range
+                    // Action: Remain in position
+                    end_cycle = true;
+                }
+                else
+                {
+                    // Rule: RangeVector &gt; WeaponRange
+                    // Action: Get next move
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_next_move;
+                }
             }
             break;
 
             // *************************************************************
 
-        case _aiFsmAttackUnit_next_move : {
+            case _aiFsmAttackUnit_next_move :
+            {
                 // CurrentPathComplete: is Unit at the end of the current path
                 aiFsmAttackUnit_path_not_finished = path.popFirst( &amp;aiFsmAttackUnit_next_square );
                 MapInterface::offsetToMapXY( aiFsmAttackUnit_next_square, &amp;aiFsmAttackUnit_next_loc );
 
-                if ( !aiFsmAttackUnit_path_not_finished ) {
+                if ( !aiFsmAttackUnit_path_not_finished )
+                {
                     // Rule: CurrentPathComplete is true
                     // Action : check if unit is at the goal
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
-                } else {
+                }
+                else
+                {
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
                     aiFsmAttackUnit_prev_loc = unit_state.location;
@@ -1139,8 +1248,10 @@
 
             // *************************************************************
 
-        case _aiFsmAttackUnit_wait_clear_loc : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+            case _aiFsmAttackUnit_wait_clear_loc :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
@@ -1148,49 +1259,56 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
-                        aiFsmAttackUnit_OnExitCleanUp();
-                        end_cycle = true;
-                    } else
-                        if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true ) {
-                            if ( aiFsmAttackUnit_wait_timer.count() ) {
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
+                {
+                    if ( aiFsmAttackUnit_wait_timer.count() )
+                    {
+                        if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
+                        {
+                            UnitInterface::unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
+                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
 
-                                if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc ) {
-                                    UnitInterface::unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
-                                    UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
+                            PathRequest path_request;
+                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
+                            PathScheduler::requestPath( path_request );
 
-                                    PathRequest path_request;
-                                    path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
-                                    PathScheduler::requestPath( path_request );
+                        }
+                        else
+                        {
+                            PathRequest path_request;
+                            path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_update );
+                            PathScheduler::requestPath( path_request );
+                        }
 
-                                } else {
-                                    PathRequest path_request;
-                                    path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_update );
-                                    PathScheduler::requestPath( path_request );
-                                }
+                        aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
+                    }
 
-
-                                aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
-                            }
-
-                            end_cycle = true;
-                        } else {
-                            UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_next_loc );
-                            setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
-                            aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
-                        }
-
+                    end_cycle = true;
+                }
+                else
+                {
+                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_next_loc );
+                    setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
+                }
             }
             break;
 
             // *************************************************************
 
-        case _aiFsmAttackUnit_move_wait : {
-                if ( fsm_active_list[ _control_move_map_square ] == false ) {
+            case _aiFsmAttackUnit_move_wait :
+            {
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
                     UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
                 }
@@ -1200,8 +1318,10 @@
 
             // *************************************************************
 
-        case _aiFsmAttackUnit_check_fsm_transition : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+            case _aiFsmAttackUnit_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
@@ -1209,33 +1329,37 @@
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        ai_fsm_transition_complete = true;
-                        aiFsmAttackUnit_OnExitCleanUp();
-                        end_cycle = true;
-                    } else
-                        if (  aiFsmAttackUnit_target_destroyed == true ) {
-                            setAiFsmDefendHold();
-                            aiFsmAttackUnit_OnExitCleanUp();
-                            end_cycle = true;
-                        } else {
-
-                            aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
-                        }
-
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    ai_fsm_transition_complete = true;
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else if (  aiFsmAttackUnit_target_destroyed == true )
+                {
+                    setAiFsmDefendHold();
+                    aiFsmAttackUnit_OnExitCleanUp();
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmAttackUnit_state = _aiFsmAttackUnit_check_path_deviation;
+                }
             }
             break;
             // *************************************************************
 
-        case _aiFsmAttackUnit_check_path_deviation : {
+            case _aiFsmAttackUnit_check_path_deviation :
+            {
                 iXY deviation_vector;
                 iXY goal_point_loc;
 
                 MapInterface::mapXYtoPointXY( aiFsmAttackUnit_target_goal_loc, &amp;goal_point_loc );
                 deviation_vector = target_unit_state-&gt;location - goal_point_loc;
 
-                if ( deviation_vector.mag2() &gt; unit_state.weapon_range ) {
+                if ( deviation_vector.mag2() &gt; unit_state.weapon_range )
+                {
                     MapInterface::pointXYtoMapXY( target_unit_state-&gt;location, &amp;aiFsmAttackUnit_target_goal_loc );
 
                     PathRequest path_request;
@@ -1244,7 +1368,9 @@
 
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_path_generate;
                     end_cycle = true;
-                } else {
+                }
+                else
+                {
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_range_check;
                 }
 
@@ -1279,87 +1405,109 @@
 
     iXY range_vector;
 
-    do {
-        switch ( aiFsmDefendHold_state ) {
-        case _aiFsmDefendHold_search_for_enemy : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+    do
+    {
+        switch ( aiFsmDefendHold_state )
+        {
+            case _aiFsmDefendHold_search_for_enemy :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
-                        ai_fsm_transition_complete = true;
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else if ( aiFsmDefendHold_search_timer.count() )
+                {
+                    if (UnitInterface::queryClosestEnemyUnit(
+                                &amp;target_unit_ptr, unit_state.location,
+                                player-&gt;getID() ) )
+                    {
+                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+                        range_vector = target_unit_state-&gt;location - unit_state.location;
+                        if ( range_vector.mag2() &lt;= unit_state.defend_range )
+                        {
+                            aiFsmDefendHold_target_ID = target_unit_ptr-&gt;id;
+                            setFsmGunneryTarget( aiFsmDefendHold_target_ID );
+                            aiFsmDefendHold_state = _aiFsmDefendHold_attack_enemy;
+                            end_cycle = true;
+                        }
+                        else
+                        {
+                            end_cycle = true;
+                        }
+                    } // **  quearyClosestEnemyUnit
+                    else
+                    {
                         end_cycle = true;
-                    } else
-                        if ( aiFsmDefendHold_search_timer.count() ) {
-                            if (UnitInterface::queryClosestEnemyUnit(
-                                        &amp;target_unit_ptr, unit_state.location,
-                                        player-&gt;getID() ) ) {
-                                target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                                range_vector = target_unit_state-&gt;location - unit_state.location;
-                                if ( range_vector.mag2() &lt;= unit_state.defend_range ) {
-                                    aiFsmDefendHold_target_ID = target_unit_ptr-&gt;id;
-                                    setFsmGunneryTarget( aiFsmDefendHold_target_ID );
-                                    aiFsmDefendHold_state = _aiFsmDefendHold_attack_enemy;
-                                    end_cycle = true;
-                                } else {
-                                    end_cycle = true;
-                                }
-                            } // **  quearyClosestEnemyUnit
-                            else {
-                                end_cycle = true;
-                            }
+                    }
 
-                        } // ** aiFsmDefendHold_search_timer.count()
-                        else {
-                            end_cycle = true;
-                        }
+                } // ** aiFsmDefendHold_search_timer.count()
+                else
+                {
+                    end_cycle = true;
+                }
             }
             break;
 
-        case _aiFsmDefendHold_attack_enemy : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+            case _aiFsmDefendHold_attack_enemy :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     clearFsmGunneryTarget();
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        // External Event: A new AI command is pending
-                        // Action: Allow command transition to occur
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    // External Event: A new AI command is pending
+                    // Action: Allow command transition to occur
+                    clearFsmGunneryTarget();
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else
+                {
+                    target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
+                    if ( target_unit_ptr == 0 )
+                    {
                         clearFsmGunneryTarget();
-                        ai_fsm_transition_complete = true;
+                        aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
                         end_cycle = true;
-                    } else {
-                        target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
-                        if ( target_unit_ptr == 0 ) {
+                    }
+                    else
+                    {
+                        target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
+                        if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED )
+                        {
                             clearFsmGunneryTarget();
                             aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
                             end_cycle = true;
-                        } else {
-                            target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
-                            if ( target_unit_state-&gt;lifecycle_state == _UNIT_LIFECYCLE_DESTROYED ) {
+                        } // ** if
+                        else
+                        {
+                            range_vector = target_unit_state-&gt;location - unit_state.location;
+                            if ( range_vector.mag2() &gt; unit_state.defend_range )
+                            {
                                 clearFsmGunneryTarget();
                                 aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
                                 end_cycle = true;
-                            } // ** if
-                            else {
-                                range_vector = target_unit_state-&gt;location - unit_state.location;
-                                if ( range_vector.mag2() &gt; unit_state.defend_range ) {
-                                    clearFsmGunneryTarget();
-                                    aiFsmDefendHold_state = _aiFsmDefendHold_search_for_enemy;
-                                    end_cycle = true;
-                                }
-                            } // else
-                        } // ** else
-                    } // ** else
-
+                            }
+                        } 
+                    }
+                }
                 end_cycle = true;
             }
             break;
@@ -1379,39 +1527,49 @@
     signed char offset_x = 0, offset_y = 0;
     size_t next_square;
 
-    do {
-        switch( aiFsmManualMove_state ) {
-        case _aiFsmManualMove_next_move : {
+    do
+    {
+        switch( aiFsmManualMove_state )
+        {
+            case _aiFsmManualMove_next_move :
+            {
                 aiFsmManualMove_prev_loc = aiFsmManualMove_next_loc;
                 orientationToOffset( aiFsmManualMove_move_orientation, &amp;offset_x, &amp;offset_y );
                 aiFsmManualMove_next_loc.x += offset_x;
                 aiFsmManualMove_next_loc.y += offset_y;
-                next_square =
-                    MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
+                next_square = MapInterface::mapXYtoOffset(aiFsmManualMove_next_loc);
 
-                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF ) {
+                if ( MapInterface::getMovementValue( aiFsmManualMove_next_loc ) == 0xFF )
+                {
                     setAiFsmDefendHold();
                     end_cycle = true;
-                } else
-                    if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true ) {
-                        setAiFsmDefendHold();
-                        end_cycle = true;
-                    } else {
-                        UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
-                        setFsmMoveMapSquare( next_square );
-                        aiFsmManualMove_state = _aiFsmManualMove_move_wait;
-                    }
+                }
+                else if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
+                {
+                    setAiFsmDefendHold();
+                    end_cycle = true;
+                }
+                else
+                {
+                    UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
+                    setFsmMoveMapSquare( next_square );
+                    aiFsmManualMove_state = _aiFsmManualMove_move_wait;
+                }
             }
             break;
 
             // *************************************************************
 
-        case _aiFsmManualMove_move_wait : {
-                if ( fsm_active_list[ _control_move_map_square ] == false ) {
+            case _aiFsmManualMove_move_wait :
+            {
+                if ( fsm_active_list[ _control_move_map_square ] == false )
+                {
                     UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_prev_loc );
                     aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
                     end_cycle = true;
-                } else {
+                }
+                else
+                {
                     end_cycle = true;
                 } // ** else
             }
@@ -1419,21 +1577,26 @@
 
             // *************************************************************
 
-        case _aiFsmManualMove_check_fsm_transition : {
-                if ( external_ai_event == _external_event_pending_unit_destruct  ) {
+            case _aiFsmManualMove_check_fsm_transition :
+            {
+                if ( external_ai_event == _external_event_pending_unit_destruct )
+                {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_next_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
-                } else
-                    if ( pending_AI_comm == true ) {
-                        ai_fsm_transition_complete = true;
-                        end_cycle = true;
-                    } else {
-                        aiFsmManualMove_state = _aiFsmManualMove_next_move;
-                    }
+                }
+                else if ( pending_AI_comm == true )
+                {
+                    ai_fsm_transition_complete = true;
+                    end_cycle = true;
+                }
+                else
+                {
+                    aiFsmManualMove_state = _aiFsmManualMove_next_move;
+                }
             }
             break;
 
@@ -1470,8 +1633,10 @@
 
 void Vehicle::accessThreatLevels()
 {
-    if ( unit_state.threat_level == _threat_level_under_attack ) {
-        if( threat_level_under_attack_timer.count() ) {
+    if ( unit_state.threat_level == _threat_level_under_attack )
+    {
+        if( threat_level_under_attack_timer.count() )
+        {
             unit_state.threat_level = _threat_level_all_clear;
         }
     }
@@ -1512,7 +1677,8 @@
 
 void Vehicle::updateAIState()
 {
-    switch(ai_command_state) {
+    switch(ai_command_state)
+    {
         case _ai_command_idle:
             aiFsmIdle();
             break;
@@ -1539,27 +1705,30 @@
 void Vehicle::checkPendingAICommStatus()
 {
     if ( (pending_AI_comm == true) &amp;&amp;
-            (ai_fsm_transition_complete == true) ) {
+            (ai_fsm_transition_complete == true) )
+    {
         pending_AI_comm = false;
         ai_fsm_transition_complete = false;
 
-        if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE ) {
-            switch( pending_AI_comm_mesg.command ) {
-            case _command_move_to_loc :
-                setCommandMoveToLoc( &amp;pending_AI_comm_mesg );
-                break;
+        if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
+        {
+            switch( pending_AI_comm_mesg.command )
+            {
+                case _command_move_to_loc :
+                    setCommandMoveToLoc( &amp;pending_AI_comm_mesg );
+                    break;
 
-            case _command_attack_unit :
-                setCommandAttackUnit( &amp;pending_AI_comm_mesg );
-                break;
+                case _command_attack_unit :
+                    setCommandAttackUnit( &amp;pending_AI_comm_mesg );
+                    break;
 
-            case _command_start_manual_move :
-                setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                break;
+                case _command_start_manual_move :
+                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
+                    break;
 
-            case _command_stop_manual_move :
-                setCommandManualMove( &amp;pending_AI_comm_mesg  );
-                break;
+                case _command_stop_manual_move :
+                    setCommandManualMove( &amp;pending_AI_comm_mesg  );
+                    break;
             } // ** switch
 
         } // ** unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE
@@ -1572,7 +1741,8 @@
 {
     iXY start;
 
-    if ( fsm_active_list[ _control_gunnery_location ] == true ) {
+    if ( fsm_active_list[ _control_gunnery_location ] == true )
+    {
         clearFsmGunneryLocation();
     }
 
@@ -1636,15 +1806,17 @@
 
 void Vehicle::setCommandManualMove(const UMesgAICommand* message)
 {
-    if ( message-&gt;command == _command_start_manual_move ) {
+    if ( message-&gt;command == _command_start_manual_move )
+    {
         aiFsmManualMove_move_orientation = message-&gt;manual_move_orientation;
         MapInterface::pointXYtoMapXY( unit_state.location, &amp;aiFsmManualMove_next_loc );
         aiFsmManualMove_state = _aiFsmManualMove_next_move;
         ai_command_state = _ai_command_manual_move;
-    } else
-        if ( message-&gt;command == _command_stop_manual_move ) {
-            ai_command_state = _ai_command_idle;
-        }
+    }
+    else if ( message-&gt;command == _command_stop_manual_move )
+    {
+        ai_command_state = _ai_command_idle;
+    }
 }
 
 void Vehicle::setCommandManualFire(const UMesgAICommand* message)
@@ -1656,10 +1828,14 @@
 {
     const UMesgAICommand *command_mesg = (const UMesgAICommand *) message;
 
-    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE ) {
-        if (command_mesg-&gt;command == _command_manual_fire) {
+    if ( unit_state.lifecycle_state == _UNIT_LIFECYCLE_ACTIVE )
+    {
+        if (command_mesg-&gt;command == _command_manual_fire)
+        {
             setCommandManualFire( command_mesg );
-        } else {
+        }
+        else
+        {
             memcpy(&amp;pending_AI_comm_mesg, command_mesg, sizeof(UMesgAICommand));
             pending_AI_comm = true;
         }
@@ -1685,7 +1861,8 @@
     update_state_opcode.setHitPoints(unit_state.hit_points);
     UnitInterface::sendOpcode( &amp;update_state_opcode );
 
-    if ( unit_state.hit_points &lt;= 0 ) {
+    if ( unit_state.hit_points &lt;= 0 )
+    {
         unit_state.lifecycle_state = _UNIT_LIFECYCLE_PENDING_DESTRUCT;
         external_ai_event = _external_event_pending_unit_destruct;
 
@@ -1706,19 +1883,23 @@
     const UMesgUpdateSelectBoxInfo *select_box_update 
         = (const UMesgUpdateSelectBoxInfo *) message;
 
-    switch (select_box_update-&gt;request_type) {
-        case _select_box_allie_visibility: {
+    switch (select_box_update-&gt;request_type)
+    {
+        case _select_box_allie_visibility:
+        {
             select_info_box.setAllieIcon(select_box_update-&gt;allie_flag_visiblity );
             break;
         }
         break;
 
-        case _select_box_flag_visiblity: {
+        case _select_box_flag_visiblity:
+        {
             select_info_box.setFlagIcon( select_box_update-&gt;flag_visiblity );
             break;
         }
 
-        case _select_box_is_allied: {
+        case _select_box_is_allied:
+        {
             select_info_box.setAllieState( select_box_update-&gt;allied_state );
             break;
         }
@@ -1741,7 +1922,8 @@
     if (unit_state.lifecycle_state != _UNIT_LIFECYCLE_ACTIVE)
         return;
     
-    switch(message-&gt;message_id) {
+    switch(message-&gt;message_id)
+    {
         case _umesg_ai_command:
             messageAICommand(message);
             break;
@@ -1783,7 +1965,8 @@
 
     MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_loc );
 
-    if ( current_loc != sync_loc ) {
+    if ( current_loc != sync_loc )
+    {
         MapInterface::mapXYtoPointXY( sync_loc, &amp;(unit_state.location) );
     }
 
@@ -1800,10 +1983,13 @@
     const TurretTrackPointOpcode* track_point_opcode 
         = (const TurretTrackPointOpcode *) opcode;
 
-    if ( track_point_opcode-&gt;activate == true ) {
+    if ( track_point_opcode-&gt;activate == true )
+    {
         iXY target = track_point_opcode-&gt;getTarget();
         setFsmTurretTrackPoint( target );
-    } else {
+    }
+    else
+    {
         fsm_active_list[ _control_turret_track_point ] = false;
     }
 
@@ -1819,9 +2005,12 @@
     const TurretTrackTargetOpcode* track_target_opcode 
         = (const TurretTrackTargetOpcode *) opcode;
 
-    if ( track_target_opcode-&gt;activate == true ) {
+    if ( track_target_opcode-&gt;activate == true )
+    {
         setFsmTurretTrackTarget( track_target_opcode-&gt;getTargetUnitID() );
-    } else {
+    }
+    else
+    {
         fsm_active_list[ _control_turret_track_target ] = false;
     }
 
@@ -1877,10 +2066,14 @@
 
 void Vehicle::processMoveOpcodeQueue()
 {
-    if (!move_opcode_queue.empty()) {
-        if( fsm_active_list[ _control_move_map_square ] == false ) {
-            if ( move_opcode_queue.size() &gt;= 3 ) {
-                for( int i = 0; i &lt; 2; i++ ) {
+    if (!move_opcode_queue.empty())
+    {
+        if( fsm_active_list[ _control_move_map_square ] == false )
+        {
+            if ( move_opcode_queue.size() &gt;= 3 )
+            {
+                for( int i = 0; i &lt; 2; i++ )
+                {
                     move_opcode_queue.pop();
                 }
                 //ConsoleInterface::postMessage( &quot;Move Opcode Queue Adjusted&quot; );
@@ -1898,11 +2091,13 @@
 {
     processMoveOpcodeQueue();
 
-    if (!opcode_queue.empty()) {
+    if (!opcode_queue.empty())
+    {
         UnitOpcodeStruct opcodedata = opcode_queue.front();
         const UnitOpcode* opcode = (UnitOpcode*) &opcodedata;
 
-        switch(opcode-&gt;opcode ) {
+        switch(opcode-&gt;opcode )
+        {
             case _UNIT_OPCODE_TURRET_TRACK_POINT:
                 unitOpcodeTrackPoint(opcode);
                 break;
@@ -1938,9 +2133,12 @@
 
 void Vehicle::evalCommandOpcode(const UnitOpcode* opcode)
 {
-    if (opcode-&gt;opcode == _UNIT_OPCODE_MOVE) {
+    if (opcode-&gt;opcode == _UNIT_OPCODE_MOVE)
+    {
         move_opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
-    } else {
+    }
+    else
+    {
         opcode_queue.push(*((const UnitOpcodeStruct*) opcode));
     }
 }
@@ -1949,25 +2147,31 @@
 {
     updateFsmState();
 
-    if ( NetworkState::status == _network_state_server ) {
+    if ( NetworkState::status == _network_state_server )
+    {
         if( unit_state_timer.count() )
             updateUnitStateProperties();
 
         updateAIState();
         checkPendingAICommStatus();
-    } else {
+    }
+    else
+    {
         processOpcodeQueue();
     }
 
     accessThreatLevels();
 
-    if( unit_state.hit_points &lt; unit_state.max_hit_points ) {
+    if( unit_state.hit_points &lt; unit_state.max_hit_points )
+    {
         smolderWait += TimerInterface::getTimeSlice();
 
         int intPercent = unit_state.percentDamageInt();
 
-        if (intPercent &gt; 50 &amp;&amp; (rand() % 100) &lt; intPercent) {
-            if (smolderWait &gt; smolderWaitMin) {
+        if (intPercent &gt; 50 &amp;&amp; (rand() % 100) &lt; intPercent)
+        {
+            if (smolderWait &gt; smolderWaitMin)
+            {
                 float percent = unit_state.percentDamageFloat();
 
                 smolderWaitMin  = (float(100 - percent) / 100.0) + (float(100 - percent) / 100.0) * 0.3;
@@ -1985,7 +2189,8 @@
 {
     body_anim_shadow.setWorldPos( unit_state.location);
 
-    if ( sorter.cullSprite( body_anim_shadow ) == false ) {
+    if ( sorter.cullSprite( body_anim_shadow ) == false )
+    {
         // Body
         body_anim.setWorldPos( unit_state.location );
         body_anim.setFrame( unit_state.body_angle.angle_int );


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000101.html">[Netpanzer-cvs] r1065 - in trunk/netpanzer/src/NetPanzer:	Interfaces Units Views/Game
</A></li>
	<LI>Next message: <A HREF="000103.html">[Netpanzer-cvs] r1067 - in trunk/netpanzer: nbproject	src/NetPanzer/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#102">[ date ]</a>
              <a href="thread.html#102">[ thread ]</a>
              <a href="subject.html#102">[ subject ]</a>
              <a href="author.html#102">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
