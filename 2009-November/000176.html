<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Netpanzer-cvs] r1148 - in trunk/netpanzer/src: Lib/2D	NetPanzer/Bot NetPanzer/Classes NetPanzer/Classes/AI	NetPanzer/Classes/Network NetPanzer/Core NetPanzer/Interfaces	NetPanzer/Network NetPanzer/Objectives NetPanzer/Particles	NetPanzer/PowerUps NetPanzer/Resources NetPanzer/System	NetPanzer/Units NetPanzer/Views/Components	NetPanzer/Views/Game NetPanzer/Views/MainMenu/Multi	NetPanzer/Views/MainMenu/Options NetPanzer/Weapons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/netpanzer-cvs/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1148%20-%20in%20trunk/netpanzer/src%3A%20Lib/2D%0A%09NetPanzer/Bot%20NetPanzer/Classes%20NetPanzer/Classes/AI%0A%09NetPanzer/Classes/Network%20NetPanzer/Core%20NetPanzer/Interfaces%0A%09NetPanzer/Network%20NetPanzer/Objectives%20NetPanzer/Particles%0A%09NetPanzer/PowerUps%20NetPanzer/Resources%20NetPanzer/System%0A%09NetPanzer/Units%20NetPanzer/Views/Components%0A%09NetPanzer/Views/Game%20NetPanzer/Views/MainMenu/Multi%0A%09NetPanzer/Views/MainMenu/Options%20NetPanzer/Weapons&In-Reply-To=%3C200911041629.nA4GT9oj019544%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000177.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Netpanzer-cvs] r1148 - in trunk/netpanzer/src: Lib/2D	NetPanzer/Bot NetPanzer/Classes NetPanzer/Classes/AI	NetPanzer/Classes/Network NetPanzer/Core NetPanzer/Interfaces	NetPanzer/Network NetPanzer/Objectives NetPanzer/Particles	NetPanzer/PowerUps NetPanzer/Resources NetPanzer/System	NetPanzer/Units NetPanzer/Views/Components	NetPanzer/Views/Game NetPanzer/Views/MainMenu/Multi	NetPanzer/Views/MainMenu/Options NetPanzer/Weapons</H1>
    <B>kromxp at mail.berlios.de</B> 
    <A HREF="mailto:netpanzer-cvs%40lists.berlios.de?Subject=Re%3A%20%5BNetpanzer-cvs%5D%20r1148%20-%20in%20trunk/netpanzer/src%3A%20Lib/2D%0A%09NetPanzer/Bot%20NetPanzer/Classes%20NetPanzer/Classes/AI%0A%09NetPanzer/Classes/Network%20NetPanzer/Core%20NetPanzer/Interfaces%0A%09NetPanzer/Network%20NetPanzer/Objectives%20NetPanzer/Particles%0A%09NetPanzer/PowerUps%20NetPanzer/Resources%20NetPanzer/System%0A%09NetPanzer/Units%20NetPanzer/Views/Components%0A%09NetPanzer/Views/Game%20NetPanzer/Views/MainMenu/Multi%0A%09NetPanzer/Views/MainMenu/Options%20NetPanzer/Weapons&In-Reply-To=%3C200911041629.nA4GT9oj019544%40sheep.berlios.de%3E"
       TITLE="[Netpanzer-cvs] r1148 - in trunk/netpanzer/src: Lib/2D	NetPanzer/Bot NetPanzer/Classes NetPanzer/Classes/AI	NetPanzer/Classes/Network NetPanzer/Core NetPanzer/Interfaces	NetPanzer/Network NetPanzer/Objectives NetPanzer/Particles	NetPanzer/PowerUps NetPanzer/Resources NetPanzer/System	NetPanzer/Units NetPanzer/Views/Components	NetPanzer/Views/Game NetPanzer/Views/MainMenu/Multi	NetPanzer/Views/MainMenu/Options NetPanzer/Weapons">kromxp at mail.berlios.de
       </A><BR>
    <I>Wed Nov  4 17:29:09 CET 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000177.html">[Netpanzer-cvs] r1149 - in trunk/netpanzer: docs src/Lib/Util	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/System src/NetPanzer/Views/Components	src/NetPanzer/Views/MainMenu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#176">[ date ]</a>
              <a href="thread.html#176">[ thread ]</a>
              <a href="subject.html#176">[ subject ]</a>
              <a href="author.html#176">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kromxp
Date: 2009-11-04 17:27:37 +0100 (Wed, 04 Nov 2009)
New Revision: 1148

Added:
   trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.cpp
   trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.hpp
   trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp
   trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp
Modified:
   trunk/netpanzer/src/Lib/2D/Surface.cpp
   trunk/netpanzer/src/Lib/2D/Surface.hpp
   trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp
   trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
   trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp
   trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
   trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp
   trunk/netpanzer/src/NetPanzer/Classes/PlayerUnitConfig.cpp
   trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
   trunk/netpanzer/src/NetPanzer/Classes/SpawnList.cpp
   trunk/netpanzer/src/NetPanzer/Classes/SpawnList.hpp
   trunk/netpanzer/src/NetPanzer/Classes/TileSet.hpp
   trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
   trunk/netpanzer/src/NetPanzer/Classes/WorldMap.hpp
   trunk/netpanzer/src/NetPanzer/Core/main.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/InfoSocket.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.hpp
   trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.cpp
   trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.hpp
   trunk/netpanzer/src/NetPanzer/Network/ClientSocket.hpp
   trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
   trunk/netpanzer/src/NetPanzer/Network/MessageRouter.hpp
   trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.cpp
   trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
   trunk/netpanzer/src/NetPanzer/Particles/ChunkTrajectoryParticle2D.cpp
   trunk/netpanzer/src/NetPanzer/Particles/ParticleInterface.cpp
   trunk/netpanzer/src/NetPanzer/Particles/Physics.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/PowerUpInterface.cpp
   trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
   trunk/netpanzer/src/NetPanzer/Resources/ResourceManager.cpp
   trunk/netpanzer/src/NetPanzer/System/Sound.cpp
   trunk/netpanzer/src/NetPanzer/System/Sound.hpp
   trunk/netpanzer/src/NetPanzer/Units/Unit.cpp
   trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
   trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.cpp
   trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.hpp
   trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp
   trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/GameTemplateView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/LoadingView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp
   trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
   trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/HostJoinTemplateView.cpp
   trunk/netpanzer/src/NetPanzer/Views/MainMenu/Options/SoundView.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp
   trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp
Log:
- Reestructuring of the code to work with objects instead of static classes, bugs assured, still working on it.
- Connecting to servers process controlled in a single point.
- Maps are loaded only in 2 points now, hopefully will be only one in the future.


Modified: trunk/netpanzer/src/Lib/2D/Surface.cpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Surface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/Lib/2D/Surface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -104,6 +104,15 @@
     totalByteCount += sizeof(Surface);
 } // end Surface::Surface
 
+Surface::Surface(unsigned int w, unsigned int h, unsigned int nframes, int bpp)
+{
+    reset();
+
+    alloc( w, h, nframes, bpp);
+
+    totalSurfaceCount++;
+    totalByteCount += sizeof(Surface);
+} // end Surface::Surface
 // ~Surface
 //---------------------------------------------------------------------------
 Surface::~Surface()
@@ -120,13 +129,13 @@
 void
 Surface::freeFrames()
 {
-	for ( unsigned int n = 0; n &lt; frames.size(); ++n )
-	{
-		SDL_FreeSurface(frames[n]);
-	}
-	frames.clear();
-	cur_frame = 0;
-	mem = 0;
+    for ( unsigned int n = 0; n &lt; frames.size(); ++n )
+    {
+        SDL_FreeSurface(frames[n]);
+    }
+    frames.clear();
+    cur_frame = 0;
+    mem = 0;
 }
 
 // reset
@@ -1033,16 +1042,26 @@
         return false;
     }
 
+
     for ( unsigned int line=0; line&lt;getHeight(); ++line )
     {
+        Uint8 * ptr8 = mem + (line * getPitch());
         for ( unsigned int column=0; column &lt; getWidth(); ++column )
         {
             Uint8 c = *rawdata;
             ++rawdata;
-            putPixel(column, line, SDL_MapRGB(cur_frame-&gt;format,
-                                              Palette::color[c].r,
-                                              Palette::color[c].g,
-                                              Palette::color[c].b));
+            if ( cur_frame-&gt;format-&gt;BitsPerPixel == 8 )
+            {
+                *ptr8 = c;
+                ++ptr8;
+            }
+            else
+            {
+                putPixel(column, line, SDL_MapRGB(cur_frame-&gt;format,
+                                                  Palette::color[c].r,
+                                                  Palette::color[c].g,
+                                                  Palette::color[c].b));
+            }
 //            memcpy(pixPtr(0,line), rawdata+(line*getWidth()), getWidth());
         }
     }
@@ -1052,16 +1071,25 @@
 bool
 Surface::getRawDataFromPixels( Uint8 * rawdata, int buffer_length )
 {
-	if ( buffer_length &lt; getArea() )
-	{
-		return false;
-	}
+    if ( buffer_length &lt; getArea() )
+    {
+        return false;
+    }
 
-	for ( unsigned int line=0; line&lt;getHeight(); ++line )
-	{
-		memcpy(rawdata+(line*getWidth()),  pixPtr(0,line), getWidth());
-	}
-	return true;
+//    for ( unsigned int line=0; line&lt;getHeight(); ++line )
+//    {
+//        for ( unsigned int column=0; column &lt; getWidth(); ++column )
+//        {
+//            Uint32 pcolor = getPixel(column, line);
+//            *rawdata = pcolor&amp;0xff;
+//            ++rawdata;
+//        }
+//    }
+    for ( unsigned int line=0; line&lt;getHeight(); ++line )
+    {
+        memcpy(rawdata+(line*getWidth()),  pixPtr(0,line), getWidth());
+    }
+    return true;
 }
 
 void

Modified: trunk/netpanzer/src/Lib/2D/Surface.hpp
===================================================================
--- trunk/netpanzer/src/Lib/2D/Surface.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/Lib/2D/Surface.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -54,6 +54,8 @@
 
     Surface();
     Surface(unsigned int w, unsigned int h, unsigned int nframes);
+    Surface(unsigned int w, unsigned int h, unsigned int nframes, int bpp);
+
     ~Surface(); // no inheritance please
     
     void freeFrames();

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,6 +19,7 @@
  */
 
 #include &lt;list&gt;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &quot;BotManager.hpp&quot;
 #include &quot;Bot.hpp&quot;
@@ -79,7 +80,7 @@
 
             ObjectiveInterface::disownPlayerObjectives( playerid );
 
-            UnitInterface::destroyPlayerUnits( playerid );
+            global_game_state-&gt;unit_manager-&gt;destroyPlayerUnits( playerid );
 
             ResourceManagerReleaseFlagMessage releasemsg;
             releasemsg.setFlagID(player-&gt;getFlag());

Modified: trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Bot/BotPlayer.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -23,6 +23,8 @@
 #include &lt;stdlib.h&gt;
 #include &lt;assert.h&gt;
 
+#include &quot;Core/GlobalGameState.hpp&quot;
+
 #include &quot;BotPlayer.hpp&quot;
 
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
@@ -57,8 +59,8 @@
 
             // manual fire on closest enemy
             Unit *enemyUnit;
-            if (UnitInterface::queryClosestEnemyUnit(&amp;enemyUnit,
-                        unit-&gt;unit_state.location, playerIndex))
+            if (global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryClosestEnemyUnitInRange(&amp;enemyUnit,
+                        unit-&gt;unit_state.location, unit-&gt;unit_state.weapon_range, playerIndex))
             {
                 manualFire(unit, enemyUnit-&gt;unit_state.location);
             }
@@ -80,7 +82,7 @@
 {
     if (m_timer.count())
     {
-        int unitCount = UnitInterface::getUnitCount(botPlayerId);
+        int unitCount = global_game_state-&gt;unit_manager-&gt;getUnitCount(botPlayerId);
         if (unitCount &gt; 0)
         {
             m_timer.changePeriod(5.0 / unitCount);
@@ -98,7 +100,7 @@
 BotPlayer::getRandomUnit(int playerIndex)
 {
     const std::vector&lt;Unit*&gt;&amp; units
-        = UnitInterface::getPlayerUnits(playerIndex);
+        = global_game_state-&gt;unit_manager-&gt;getPlayerUnits(playerIndex);
 
     if(units.size() == 0)
         return 0;
@@ -237,7 +239,7 @@
         OutpostStatus outpostStatus =
             ObjectiveInterface::getOutpostStatus(*i);
         if (outpostStatus.unit_generation_on_off == false) {
-            produceUnit(*i, rand() % UnitProfileInterface::getNumUnitTypes() );
+            produceUnit(*i, rand() % global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes() );
         }
     }
 }

Modified: trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/AI/Astar.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -22,6 +22,8 @@
 #include &quot;Util/Timer.hpp&quot;
 #include &quot;PathingState.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
+#include &quot;Units/UnitInterface.hpp&quot;
 
 #define HEURISTIC_WEIGHT    10
 
@@ -33,10 +35,12 @@
 void Astar::initializeAstar( unsigned long node_list_size,
                              unsigned long step_limit)
 {
-    open_set.initialize( MapInterface::getWidth(),
-            MapInterface::getHeight() );
-    closed_set.initialize( MapInterface::getWidth(),
-            MapInterface::getHeight() );
+    open_set.initialize(global_game_state-&gt;world_map-&gt;getWidth(),
+                        global_game_state-&gt;world_map-&gt;getHeight());
+
+    closed_set.initialize(global_game_state-&gt;world_map-&gt;getWidth(),
+                          global_game_state-&gt;world_map-&gt;getHeight());
+
     open = std::priority_queue&lt;AstarNode*, std::vector&lt;AstarNode*&gt;,
            AstarNodePtrCompare&gt;();
 
@@ -156,8 +160,8 @@
 {
     unsigned long abs;
 
-    if ( ( map_loc.x &lt; 0 ) || (map_loc.x &gt;= (int) main_map.getWidth() ) ||
-            ( map_loc.y &lt; 0 ) || (map_loc.y &gt;= (int) main_map.getHeight() )
+    if ( ( map_loc.x &lt; 0 ) || (map_loc.x &gt;= (int) global_game_state-&gt;world_map-&gt;getWidth() ) ||
+            ( map_loc.y &lt; 0 ) || (map_loc.y &gt;= (int) global_game_state-&gt;world_map-&gt;getHeight() )
        )
         return 0xFFFFFFFF;
 
@@ -223,12 +227,12 @@
     succ-&gt;abs_loc = mapXYtoAbsloc( succ-&gt;map_loc );
 
     movement_val = getMovementValue( succ-&gt;map_loc );
-    if ( movement_val != 0xFF )
-        if ( ( (UnitBlackBoard::unitOccupiesLoc( succ-&gt;map_loc ) == true ) &amp;&amp;
-                (succ-&gt;map_loc != goal_node.map_loc) )
-           ) {
-            movement_val = 200;
-        }
+    if ( movement_val != 0xFF
+         &amp;&amp; global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(succ-&gt;map_loc) == true
+         &amp;&amp; succ-&gt;map_loc != goal_node.map_loc )
+    {
+        movement_val = 200;
+    }
 
     succ-&gt;g += node-&gt;g + movement_val;
 
@@ -280,7 +284,7 @@
             done = true;
             break;
         }
-
+//LOGGER.warning(&quot;ASTAR:best node is %d,%d goal is %d, %d&quot;, best_node-&gt;map_loc.x, best_node-&gt;map_loc.y, goal_node.map_loc.x, goal_node.map_loc.y);
         if ( (best_node-&gt;map_loc == goal_node.map_loc) ) {
             done = true;
         } else {
@@ -366,7 +370,7 @@
 
         node = best_node;
         while ( (node != 0) &amp;&amp; (insert_successful == true) ) {
-
+//LOGGER.warning(&quot;ASTAR:adding to path: %d,%d&quot;, node-&gt;map_loc.x, node-&gt;map_loc.y);
             if ( path_merge_type == _path_merge_front ) {
                 insert_successful = path-&gt;pushFirst( node-&gt;abs_loc );
             } else {
@@ -428,8 +432,8 @@
     debug_mode_flag = on_off;
 
     if ( debug_mode_flag == true ) {
-        astar_set_array.initialize(MapInterface::getWidth(),
-                MapInterface::getHeight() );
+        astar_set_array.initialize(global_game_state-&gt;world_map-&gt;getWidth(),
+                                   global_game_state-&gt;world_map-&gt;getHeight());
     } else {
         astar_set_array.deallocate();
     }

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -344,20 +344,19 @@
                             LoadingView::append( str_buf);
                             connection_state = _connect_state_connect_failure;
                             failure_display_timer.reset();
-                        } else
-                            if( result_code == _mapload_result_no_wad_file ) {
-                                LoadingView::append( &quot;MAP TILE SET NOT FOUND!&quot; );
-                                LoadingView::append( &quot;please download the appropriate tileset&quot; );
-                                LoadingView::append( &quot;from www.pyrosoftgames.com&quot; );
-                                connection_state = _connect_state_connect_failure;
-                                failure_display_timer.reset();
-                            } else {
-                                LoadingView::append( &quot;Loading Game Data ...&quot; );
+                        } else if( result_code == _mapload_result_no_wad_file ) {
+                            LoadingView::append( &quot;MAP TILE SET NOT FOUND!&quot; );
+                            LoadingView::append( &quot;please download the appropriate tileset&quot; );
+                            LoadingView::append( &quot;from www.pyrosoftgames.com&quot; );
+                            connection_state = _connect_state_connect_failure;
+                            failure_display_timer.reset();
+                        } else {
+                            LoadingView::append( &quot;Loading Game Data ...&quot; );
 
-                                NetworkClient::sendMessage( &amp;client_game_setup_ping, sizeof(ConnectMesgClientGameSetupPing));
+                            NetworkClient::sendMessage( &amp;client_game_setup_ping, sizeof(ConnectMesgClientGameSetupPing));
 
-                                connection_state = _connect_state_setup_client_game;
-                            }
+                            connection_state = _connect_state_setup_client_game;
+                        }
                     }
                 }
 
@@ -369,7 +368,7 @@
                 char str_buf[128];
                 int percent_complete;
 
-                GameManager::clientGameSetup();
+//                GameManager::clientGameSetup();
                 ConnectMesgClientGameSetupAck client_game_setup_ack;
 
                 sprintf( str_buf, &quot;Loading Game Data ... (%d%%)&quot;, percent_complete);
@@ -378,14 +377,6 @@
                 NetworkClient::sendMessage( &amp;client_game_setup_ack, sizeof(ConnectMesgClientGameSetupAck));
                 connection_state = _connect_state_idle;
 
-//                } else {
-//                    ConnectMesgClientGameSetupPing client_game_setup_ping;
-//
-//                    sprintf( str_buf, &quot;Loading Game Data ... (%d%%)&quot;, percent_complete);
-//                    LoadingView::update( str_buf );
-//                    NetworkClient::sendMessage( &amp;client_game_setup_ping, sizeof(ConnectMesgClientGameSetupPing));
-//                }
-
                 end_cycle = true;
             }
             break;

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/ClientConnectDaemon.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -22,9 +22,25 @@
 #include &quot;Classes/Network/NetPacket.hpp&quot;
 #include &quot;Util/Timer.hpp&quot;
 
+class ConnectState;
+
 class ClientConnectDaemon
 {
-protected:
+public:
+    static void startConnectDaemon();
+
+    static void shutdownConnectDaemon();
+
+    static void startConnectionProcess();
+
+    static void connectProcess();
+
+    static void processNetMessage(const NetMessage* message);
+
+    static void serverConnectionBroken();
+
+private:
+    static ConnectState * connect_state;
     static Timer failure_display_timer;
     static Timer time_out_timer;
     static int   time_out_counter;
@@ -39,20 +55,6 @@
     static void connectProcess(const NetMessage* message);
 
     static void connectFailureResult( unsigned char result_code );
-
-public:
-    static void startConnectDaemon();
-
-    static void shutdownConnectDaemon();
-
-    static void startConnectionProcess();
-
-    static void connectProcess();
-
-    static void processNetMessage(const NetMessage* message);
-
-    static void serverConnectionBroken();
-
 };
 
 #endif // ** _CLIENTCONNECTDAEMON_HPP

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -50,6 +50,12 @@
     partServer();
 }
 
+bool
+NetworkClient::isConnected()
+{
+    return connection_status == _connection_status_connected;
+}
+
 void
 NetworkClient::onClientDisconected(ClientSocket *s, const char *msg)
 {

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkClient.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -47,6 +47,8 @@
 
     static void checkIncoming();
 
+    static bool isConnected();
+
 protected:
     static MessageClassHandler* getPacketHandler();
     static void onClientDisconected(ClientSocket *s, const char *msg);

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/NetworkServer.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,7 +19,7 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;Resources/ResourceManager.hpp&quot;
 
 #include &quot;NetworkServer.hpp&quot;
@@ -47,16 +47,15 @@
 #include &quot;Network/MessageClassHandler.hpp&quot;
 
 typedef std::list&lt;ServerClientListData*&gt; ClientList;
+
 static ClientList client_list;
 static ClientList connecting_clients;
 
-
-
 class ListenSocket : public TCPListenSocketObserver,
                      public ClientSocketObserver
 {
 public:
-    ListenSocket() : socket(0) {};
+    ListenSocket() : socket(0) {}
     ~ListenSocket()
     {
         if ( socket )
@@ -103,7 +102,6 @@
         (void)so;
         LOGGER.warning(&quot;NetworkServer: Listen Socket error: '%s'&quot;, msg);
         LOGGER.warning(&quot;Something bad could happen from now&quot;);
-
     }
 
     TCPSocketObserver * onNewConnection(TCPListenSocket *so, const Address &amp;fromaddr)
@@ -453,7 +451,7 @@
 
         ObjectiveInterface::disownPlayerObjectives( player_index );
 
-        UnitInterface::destroyPlayerUnits( player_index );
+        global_game_state-&gt;unit_manager-&gt;destroyPlayerUnits( player_index );
 
         ResourceManagerReleaseFlagMessage releasemsg;
         releasemsg.setFlagID(player-&gt;getFlag());

Modified: trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/Network/UnitSync.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,7 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;UnitSync.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
@@ -28,9 +28,9 @@
 UnitSync::UnitSync(ClientSocket * c)
     : client(c), count(0), unitid(0), unitstosync(0), lastunit(0)
 {
-    unitstosync = UnitInterface::getTotalUnitCount();
+    unitstosync = global_game_state-&gt;unit_manager-&gt;getTotalUnitCount();
     if ( unitstosync ) {
-        lastunit = UnitInterface::getUnits().rbegin()-&gt;first;
+        lastunit = global_game_state-&gt;unit_manager-&gt;getUnits().rbegin()-&gt;first;
     }
 }
 
@@ -47,7 +47,7 @@
 
 bool UnitSync::sendNextUnit()
 {
-    const UnitInterface::Units&amp; units = UnitInterface::getUnits();
+    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
     UnitInterface::Units::const_iterator i = units.lower_bound(unitid);
     if(i == units.end() || i-&gt;first &gt; lastunit ) {
         return false;

Modified: trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/PlacementMatrix.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -18,7 +18,7 @@
 
 #include &quot;Classes/PlacementMatrix.hpp&quot;
 #include &quot;Interfaces/MapInterface.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
+#include &quot;Units/UnitInterface.hpp&quot;
 
 void PlacementMatrix::reset( iXY ini_map_loc )
 {
@@ -36,9 +36,9 @@
     iXY succ;
     unsigned long direction_index;
 
-    if ( ( MapInterface::getMovementValue( loc ) &gt;= 0xFF) ||
-            ( UnitBlackBoard::unitOccupiesLoc( loc ) == true )
-       ) {
+    if ( MapInterface::getMovementValue(loc) &gt;= 0xFF
+        || global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(loc) == true )
+    {
         return(false);
     }
 
@@ -89,9 +89,9 @@
         succ.x = loc.x + (x_offset);
         succ.y = loc.y + (y_offset);
 
-        if ( ( MapInterface::getMovementValue( succ ) &lt; 0xFF) &amp;&amp;
-                ( UnitBlackBoard::unitOccupiesLoc( succ ) == false )
-           ) {
+        if ( MapInterface::getMovementValue(succ) &lt; 0xFF
+             &amp;&amp; global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(succ) == false )
+        {
             return true;
         }
 
@@ -212,116 +212,3 @@
 
     return( false );
 }
-
-/*
-void PlacementMatrix::reset( iXY ini_map_loc )
- {
-  *
-  ini_loc = ini_map_loc;
-  level = 2;
-  direction = 0;
- }
- 
-bool PlacementMatrix::getNextEmptyLoc( iXY *loc )
- {
-  long x_offset, y_offset;
-  iXY succ;
-  iXY succ_right;
-  iXY succ_left;
- 
-  while ( level &lt; 50 )
-   {
-    switch( direction )
-     {
-      case 0: { x_offset =  0; y_offset =  0; } break;
-      case 1: { x_offset =  1; y_offset =  0; } break;
-      case 2: { x_offset =  1; y_offset = -1; } break;
-      case 3: { x_offset =  0; y_offset = -1; } break;
-      case 4: { x_offset = -1; y_offset = -1; } break;
-      case 5: { x_offset = -1; y_offset =  0; } break;
-      case 6: { x_offset = -1; y_offset =  1; } break;
-      case 7: { x_offset =  0; y_offset =  1; } break;
-      case 8: { x_offset =  1; y_offset =  1; } break; 
-     } // ** switch   
-      
-    succ.x = ini_loc.x + (x_offset * level);
-    succ.y = ini_loc.y + (y_offset * level);
- 
-     switch( direction )
-       {
-        case 0: { succ_right.y = succ.y; 
-                  succ_left.y = succ.y;
-                  succ_right.x = succ.x;
-                  succ_left.x = succ.x;  } break;
- 
-        case 1: { succ_right.y = succ.y + 1; 
-                  succ_left.y = succ.y - 1;
-                  succ_right.x = succ.x;
-                  succ_left.x = succ.x;  } break;
-        
-        case 2: { succ_right.y = succ.y + 1;
-                  succ_left.x = succ.x - 1;
-                  succ_right.x = succ.x;
-                  succ_left.y = succ.y;   } break;
-        
-        case 3: { succ_right.x = succ.x + 1; 
-                  succ_left.x = succ.x - 1;
-                  succ_right.y = succ.y;
-                  succ_left.y = succ.y; } break;
-                  
-        case 4: { succ_right.x = succ.x + 1; 
-                  succ_left.y = succ.y + 1;
-                  succ_right.y = succ.y;
-                  succ_left.x = succ.x; } break;
-        
-        case 5: { succ_right.y = succ.y - 1; 
-                  succ_left.y = succ.y + 1;
-                  succ_right.x = succ.x;
-                  succ_left.x = succ.x; } break;
-        
-        case 6: { succ_right.y = succ.y - 1; 
-                  succ_left.x = succ.x + 1;
-                  succ_right.x = succ.x;
-                  succ_left.y = succ.y; } break;
-        
-        case 7: { succ_right.x = succ.x - 1; 
-                  succ_left.x = succ.x + 1;
-                  succ_right.y = succ.y;
-                  succ_left.y = succ.y; } break;
-        
-        case 8: { succ_right.x = succ.x + 1; 
-                  succ_left.y = succ.y - 1;
-                  succ_right.y = succ.y;
-                  succ_left.x = succ.x; } break;
-        
-      } // ** switch    
- 
-   if ( ( MapInterface::getMovementValue( succ ) &lt; 0xFF) &amp;&amp;
-        ( UnitBlackBoard::unitOccupiesLoc( succ ) == false ) &amp;&amp;
-		( (MapInterface::getMovementValue( succ_right ) &lt; 0xFF) 
-		   || (MapInterface::getMovementValue( succ ) &lt; 0xFF) 
-		)
-      )
-    {
-     *loc = succ;
-	 direction++;
-	 if (direction == 9)
-	  {
-	   level++;
-	   direction = 0;
-	  }	   
-	 return( true );
-    }
-  
-   direction++;
-   if (direction == 9)
-    {
-     level++;
-     direction = 0;
-    }	   
-  
-  } // ** while 
-  
-  return( false );
- }
- */

Modified: trunk/netpanzer/src/NetPanzer/Classes/PlayerUnitConfig.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/PlayerUnitConfig.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/PlayerUnitConfig.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,6 +19,7 @@
 #include &quot;Classes/PlayerUnitConfig.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
 #include &quot;Units/UnitProfileInterface.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 PlayerUnitConfig::PlayerUnitConfig()
 {
@@ -27,7 +28,7 @@
 void PlayerUnitConfig::initialize()
 {
     max_allowed_units = gameconfig-&gt;maxunits / gameconfig-&gt;maxplayers;
-    unit_spawn_list.resize(UnitProfileInterface::getNumUnitTypes(), 0);
+    unit_spawn_list.resize(global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(), 0);
     
     int rem_units = max_allowed_units;
     int numunits;
@@ -35,7 +36,7 @@
     vector&lt;ConfigVariable*&gt;::iterator i = gameconfig-&gt;spawnsettings.begin();
     while ( i != gameconfig-&gt;spawnsettings.end() )
     {
-        UnitProfile * u = UnitProfileInterface::getProfileByName((*i)-&gt;getName());
+        UnitProfile * u = global_game_state-&gt;unit_profile_interface-&gt;getProfileByName((*i)-&gt;getName());
         if ( u )
         {
             numunits = *(ConfigInt *)(*i);
@@ -54,7 +55,7 @@
         for ( int a=0; a&lt;(int)unit_spawn_list.size(); a++ )
         {
             unit_spawn_list[a] = 1;
-            UnitProfile * u = UnitProfileInterface::getUnitProfile(a);
+            UnitProfile * u = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(a);
             gameconfig-&gt;spawnsettings.push_back(new ConfigInt(u-&gt;unitname,1));
         }
     }

Modified: trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/SelectionList.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,6 +16,7 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;SelectionList.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
@@ -29,7 +30,7 @@
     deselect();
     unit_list.clear();
 
-    UnitInterface::queryPlayerUnitsAt(unit_list, point,
+    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(unit_list, point,
                                         PlayerInterface::getLocalPlayerIndex());
 
     select();
@@ -44,7 +45,7 @@
 {
     deselect();
 
-    UnitInterface::queryPlayerUnitsAt(unit_list, point,
+    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(unit_list, point,
                                         PlayerInterface::getLocalPlayerIndex());
 
     select();
@@ -58,7 +59,7 @@
 bool SelectionList::selectBounded(iRect bounds, bool addunits)
 {
     std::vector&lt;UnitID&gt; tempunits;
-    UnitInterface::queryPlayerUnitsInWorldRect(tempunits, bounds,
+    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(tempunits, bounds,
                                        PlayerInterface::getLocalPlayerIndex() );
     
     if ( ! tempunits.size() )
@@ -95,17 +96,17 @@
 
     std::vector&lt;UnitID&gt; temp_list;
 
-    UnitInterface::queryPlayerUnitsAt(temp_list, point, player_id);
+    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsAt(temp_list, point, player_id);
     
     if ( temp_list.empty() )
         return false;
         
-    unsigned char t=UnitInterface::getUnit(temp_list[0])-&gt;unit_state.unit_type;
+    unsigned char t=global_game_state-&gt;unit_manager-&gt;getUnit(temp_list[0])-&gt;unit_state.unit_type;
     temp_list.clear();
     
     iRect wr;
     WorldViewInterface::getViewWindow(&amp;wr);
-    UnitInterface::queryPlayerUnitsInWorldRect(temp_list, wr, player_id );
+    global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(temp_list, wr, player_id );
     
     int p = temp_list.size();
     if ( !p )
@@ -113,7 +114,7 @@
 
     p--;
     do {
-        if ( UnitInterface::getUnit(temp_list[p])-&gt;unit_state.unit_type == t)
+        if ( global_game_state-&gt;unit_manager-&gt;getUnit(temp_list[p])-&gt;unit_state.unit_type == t)
             unit_list.push_back(temp_list[p]);
     } while (p--);
 
@@ -139,7 +140,7 @@
     id_list_size = unit_list.size();
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
+        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = true;
         }
@@ -156,7 +157,7 @@
     id_list_size = unit_list.size();
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
+        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = false;
         }
@@ -176,7 +177,7 @@
     deselect();
     do {
 
-        unit = UnitInterface::getUnit( unit_list[ unit_cycle_index ] );
+        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ unit_cycle_index ] );
         if ( unit != 0 ) {
             unit-&gt;unit_state.select = true;
         }
@@ -214,7 +215,7 @@
     Unit *unit;
 
     if ( unit_list.size() &gt; 0 ) {
-        unit = UnitInterface::getUnit( unit_list[ 0 ] );
+        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ 0 ] );
         if( unit != 0 ) {
             return unit-&gt;unit_state.unit_type;
         } else {
@@ -238,7 +239,7 @@
     }
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit = UnitInterface::getUnit( unit_list[ id_list_index ] );
+        unit = global_game_state-&gt;unit_manager-&gt;getUnit( unit_list[ id_list_index ] );
         if ( unit != 0 ) {
             return;
         }

Modified: trunk/netpanzer/src/NetPanzer/Classes/SpawnList.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/SpawnList.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/SpawnList.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -34,7 +34,7 @@
 
 void SpawnList::loadSpawnFile(const std::string&amp; file_path)
 {
-    clear();
+    spawn_points.clear();
 
     try {
         IFileStream in(file_path);
@@ -51,7 +51,7 @@
             if(!in.good())
                 throw Exception(&quot;file too short&quot;);
             
-            push_back(iXY(x, y));
+            spawn_points.push_back(iXY(x, y));
         }
 
         last_spawn_index = 0;
@@ -67,15 +67,15 @@
 
     switch(gameconfig-&gt;respawntype) {
         case _game_config_respawn_type_round_robin :
-            spawn_index = (last_spawn_index + 1) % size();
+            spawn_index = (last_spawn_index + 1) % spawn_points.size();
             last_spawn_index = spawn_index;
             break;
         case _game_config_respawn_type_random :
-            spawn_index = rand() % size();
+            spawn_index = rand() % spawn_points.size();
             break;
         default:
             throw Exception(&quot;unknown respawn type&quot;);
     }
 
-    return at(spawn_index);
+    return spawn_points[spawn_index];
 }

Modified: trunk/netpanzer/src/NetPanzer/Classes/SpawnList.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/SpawnList.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/SpawnList.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -22,16 +22,17 @@
 #include &lt;string&gt;
 #include &quot;Types/iXY.hpp&quot;
 
-class SpawnList : public std::vector&lt;iXY&gt;
+class SpawnList
 {
-private:
-    size_t last_spawn_index;
-
 public:
     SpawnList();
 
     void loadSpawnFile(const std::string&amp; file_path);
     iXY getFreeSpawnPoint();
+
+private:
+    size_t last_spawn_index;
+    std::vector&lt;iXY&gt; spawn_points;
 };
 
 #endif // ** _SPAWNLIST_HPP

Modified: trunk/netpanzer/src/NetPanzer/Classes/TileSet.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/TileSet.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/TileSet.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -27,16 +27,12 @@
 
 typedef struct TileSetHeader_s
 {
-    unsigned char netp_id_header[64];
     int     version;
     int     x_pix;
     int     y_pix;
     int     tile_count;
-    Uint8   palette[768];
-
     std::string image_file;
     std::string unused;
-
 } TileSetHeader;
 
 typedef struct TileAttributes_s
@@ -48,16 +44,6 @@
 
 class TileSet
 {
-protected:
-    bool tile_set_loaded;
-    TileSetHeader header;
-    std::vector&lt;TileAttributes&gt; tile_attributes;
-    std::vector&lt;Surface*&gt; tiles;
-
-
-    unsigned long tile_size;
-    void computeTileConsts( void );
-
 public:
     TileSet();
     ~TileSet();
@@ -67,37 +53,23 @@
 
     void loadTileSet( const char *file_path );
 
-    inline Surface * getTile(unsigned long index) const
-    {
-        return tiles[index];
-    }
+    Surface * getTile(unsigned long index) const { return tiles[index]; }
 
-    inline unsigned short getTileXsize() const
-    {
-        return ( header.x_pix );
-    }
+    unsigned short getTileXsize() const { return header.x_pix; }
+    unsigned short getTileYsize() const { return header.y_pix; }
+    unsigned short getTileCount() const { return header.tile_count; }
 
-    inline unsigned short getTileYsize() const
+    const SDL_Color* getAverageTileColor(unsigned long index) const
     {
-        return ( header.y_pix );
+        return &amp;tile_attributes[ index ].avg_color;
     }
 
-    inline unsigned short getTileCount() const
+    char getTileMovementValue( unsigned long index )
     {
-        return ( header.tile_count );
+        return tile_attributes[ index ].move_value;
     }
 
-    inline const SDL_Color* getAverageTileColor(unsigned long index) const
-    {
-        return( &amp;(tile_attributes[ index ].avg_color) );
-    }
-
-    inline char getTileMovementValue( unsigned long index )
-    {
-        return( tile_attributes[ index ].move_value );
-    }
-
-    inline unsigned char getTilePixel( unsigned long index , unsigned int pixX,
+    unsigned char getTilePixel( unsigned long index , unsigned int pixX,
                                        unsigned int pixY)
     {
         if( index &lt; tiles.size() )
@@ -107,7 +79,15 @@
 
         return( 0 );
     }
+
 private:
+    bool                        tile_set_loaded;
+    TileSetHeader               header;
+    std::vector&lt;TileAttributes&gt; tile_attributes;
+    std::vector&lt;Surface*&gt;       tiles;
+    unsigned long               tile_size;
+
+    void computeTileConsts( void );
     void loadTileAttributes(IFileStream&amp; file);
     void freeTiles();
 };

Modified: trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/WorldInputCmdProcessor.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,8 @@
 */
 
 #include &lt;sstream&gt;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;WorldInputCmdProcessor.hpp&quot;
 
 #include &quot;Interfaces/MouseInterface.hpp&quot;
@@ -154,7 +156,7 @@
     }
 	
 	//Unit * unit = UnitInterface::queryNonPlayerUnitAtWorld( loc, PlayerInterface::getLocalPlayerIndex() );
-    Unit * unit = UnitInterface::queryUnitAtMapLoc( map_loc );
+    Unit * unit = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitAtMapLoc( map_loc );
 	if ( unit )
 	{
         if ( unit-&gt;player-&gt;getID() == PlayerInterface::getLocalPlayerIndex() )
@@ -320,7 +322,7 @@
 void
 WorldInputCmdProcessor::jumpLastAttackedUnit()
 {
-    const UnitInterface::Units&amp; units = UnitInterface::getUnits();
+    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
     for(UnitInterface::Units::const_iterator i = units.begin();
             i != units.end(); ++i)
     {
@@ -721,7 +723,7 @@
                 current_selection_list_index = 0xFFFF;
                 if (working_list.unit_list.size() &gt; 0)
                 {
-                    Unit *unit = UnitInterface::getUnit(
+                    Unit *unit = global_game_state-&gt;unit_manager-&gt;getUnit(
                             working_list.unit_list[0]);
                     if(unit)
                         unit-&gt;soundSelected();
@@ -785,6 +787,7 @@
     iXY map_pos;
     PlacementMatrix matrix;
 
+    LOGGER.warning(&quot;Wants to move to world %d,%d&quot;, world_pos.x, world_pos.y);
     unsigned long id_list_index;
     size_t id_list_size;
     Unit *unit_ptr;
@@ -797,15 +800,21 @@
         return;
 
     MapInterface::pointXYtoMapXY( world_pos, &amp;map_pos );
+    LOGGER.warning(&quot;Wants to move to map %d,%d&quot;, map_pos.x, map_pos.y);
     matrix.reset( map_pos );
 
     NetMessageEncoder encoder(true);
 
     for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-        unit_ptr = UnitInterface::getUnit(working_list.unit_list[ id_list_index ]);
+        unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit(working_list.unit_list[ id_list_index ]);
         if ( unit_ptr != 0 ) {
             if ( unit_ptr-&gt;unit_state.select == true ) {
                 matrix.getNextEmptyLoc( &amp;map_pos );
+                LOGGER.warning(&quot;Unit %d move from %d, %d to %d,%d&quot;,
+                               unit_ptr-&gt;id,
+                               unit_ptr-&gt;unit_state.location.x/32,
+                               unit_ptr-&gt;unit_state.location.y/32,
+                               map_pos.x, map_pos.y);
                 comm_mesg.comm_request.setHeader(unit_ptr-&gt;id);
 
                 comm_mesg.comm_request.setMoveToLoc( map_pos );
@@ -818,8 +827,8 @@
     encoder.sendEncodedMessage();
 
     //sfx
-    sound-&gt;playUnitSound(working_list.getHeadUnitType() );
-    sound-&gt;playSound(&quot;move&quot;);
+    global_engine_state-&gt;sound_manager-&gt;playUnitSound(working_list.getHeadUnitType());
+    global_engine_state-&gt;sound_manager-&gt;playSound(&quot;move&quot;);
 }
 
 void
@@ -835,7 +844,7 @@
 
     if ( working_list.isSelected() == true )
     {
-        target_ptr = UnitInterface::queryNonPlayerUnitAtWorld(world_pos,
+        target_ptr = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitAtWorld(world_pos,
                                         PlayerInterface::getLocalPlayerIndex());
 
         if ( ! target_ptr ) // there was nothing there
@@ -852,7 +861,7 @@
 
         for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ )
         {
-            unit_ptr = UnitInterface::getUnit( working_list.unit_list[ id_list_index ] );
+            unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit( working_list.unit_list[ id_list_index ] );
             if ( unit_ptr != 0 )
             {
                 if ( unit_ptr-&gt;unit_state.select == true )
@@ -869,7 +878,7 @@
         encoder.sendEncodedMessage();
 
         //sfx
-        sound-&gt;playSound(&quot;target&quot;);
+        global_engine_state-&gt;sound_manager-&gt;playSound(&quot;target&quot;);
     }
 }
 
@@ -888,7 +897,7 @@
         NetMessageEncoder encoder(true);
 
         for( id_list_index = 0; id_list_index &lt; id_list_size; id_list_index++ ) {
-            unit_ptr = UnitInterface::getUnit( working_list.unit_list[ id_list_index ] );
+            unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit( working_list.unit_list[ id_list_index ] );
 
             if ( unit_ptr != 0 ) {
                 if ( unit_ptr-&gt;unit_state.select == true ) {
@@ -904,14 +913,14 @@
         encoder.sendEncodedMessage();
         
         // SFX
-        sound-&gt;playSound(&quot;target&quot;);
+        global_engine_state-&gt;sound_manager-&gt;playSound(&quot;target&quot;);
     } // ** if containsItems() &gt; 0
 }
 
 void
 WorldInputCmdProcessor::sendAllianceRequest(const iXY&amp; world_pos, bool make_break)
 {
-    Unit *target_ptr = UnitInterface::queryNonPlayerUnitAtWorld(world_pos,
+    Unit *target_ptr = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitAtWorld(world_pos,
                                         PlayerInterface::getLocalPlayerIndex());
 
     if ( target_ptr )
@@ -1016,15 +1025,16 @@
 void
 WorldInputCmdProcessor::closeSelectionBox()
 {
-    iXY world_pos;
-    iXY mouse_pos;
+    if (selection_box_active == true)
+    {
+        iXY world_pos;
+        iXY mouse_pos;
 
-    MouseInterface::getMousePosition( &amp;mouse_pos.x, &amp;mouse_pos.y );
+        MouseInterface::getMousePosition( &amp;mouse_pos.x, &amp;mouse_pos.y );
 
-    WorldViewInterface::getViewWindow( &amp;world_win );
-    WorldViewInterface::clientXYtoWorldXY( world_win, mouse_pos, &amp;world_pos );
+        WorldViewInterface::getViewWindow( &amp;world_win );
+        WorldViewInterface::clientXYtoWorldXY( world_win, mouse_pos, &amp;world_pos );
 
-    if (selection_box_active == true) {
         selection_box_active = false;
         box_release = world_pos;
         left_button_hold_action_complete = selectBoundBoxUnits();
@@ -1087,7 +1097,7 @@
     // Vote direction
     bool firstunit = true;
     for(unsigned int id_list_index = 0; id_list_index &lt; working_list.unit_list.size(); id_list_index++) {
-        Unit* unit_ptr = UnitInterface::getUnit(working_list.unit_list[id_list_index]);
+        Unit* unit_ptr = global_game_state-&gt;unit_manager-&gt;getUnit(working_list.unit_list[id_list_index]);
 
         if(unit_ptr == 0)
             continue;

Modified: trunk/netpanzer/src/NetPanzer/Classes/WorldMap.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Classes/WorldMap.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Classes/WorldMap.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -20,6 +20,7 @@
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
+#include &quot;SDL.h&quot;
 
 namespace filesystem { class ReadFile; }
 
@@ -70,22 +71,6 @@
         return data[y*getWidth() + x];
     }
 
-    /** @deprecatet */
-    MapElementType getValue(size_t offset) const
-    {
-        assert(offset &lt; getSize());
-        return data[offset];
-    }
-
-    void setMapValue(size_t x, size_t y, MapElementType value)
-    {
-        assert(x &lt; getWidth());
-        assert(y &lt; getHeight());
-       
-        data[y*getWidth() + x] = value;
-    }
-
-
 private:
     bool      loaded;
     MapHeader header;

Added: trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -0,0 +1,25 @@
+/*
+Copyright (C) 2009 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ */
+
+#include &quot;GlobalEngineState.hpp&quot;
+
+GlobalEngineState * global_engine_state = 0;
+
+GlobalEngineState::GlobalEngineState() : game_manager(0), sound_manager(0)
+{}

Added: trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalEngineState.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -0,0 +1,36 @@
+/*
+Copyright (C) 2008 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ */
+#ifndef GLOBAL_ENGINE_STATE_HPP__
+#define GLOBAL_ENGINE_STATE_HPP__
+
+class BaseGameManager;
+class Sound;
+
+class GlobalEngineState
+{
+public:
+    GlobalEngineState();
+
+    BaseGameManager * game_manager;
+    Sound * sound_manager;
+};
+
+extern GlobalEngineState * global_engine_state;
+
+#endif

Added: trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -0,0 +1,27 @@
+/*
+Copyright (C) 2009 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ */
+
+#include &quot;GlobalGameState.hpp&quot;
+
+GlobalGameState * global_game_state = 0;
+
+GlobalGameState::GlobalGameState()
+        : tile_set(0), world_map(0), spawn_list(0),
+          unit_manager(0), unit_profile_interface(0)
+{}

Added: trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Core/GlobalGameState.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -0,0 +1,42 @@
+/*
+Copyright (C) 2008 by Aaron Perez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">aaronps at gmail.com</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+ */
+#ifndef GLOBAL_GAME_STATE_HPP__
+#define GLOBAL_GAME_STATE_HPP__
+
+class TileSet;
+class WorldMap;
+class SpawnList;
+class UnitProfileInterface;
+class UnitInterface;
+
+class GlobalGameState
+{
+public:
+    GlobalGameState();
+
+    TileSet * tile_set;
+    WorldMap * world_map;
+    SpawnList * spawn_list;
+    UnitInterface * unit_manager;
+    UnitProfileInterface * unit_profile_interface;
+};
+
+extern GlobalGameState * global_game_state;
+
+#endif

Modified: trunk/netpanzer/src/NetPanzer/Core/main.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Core/main.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Core/main.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -33,6 +33,8 @@
 #include &lt;signal.h&gt;
 #include &quot;SDL.h&quot;
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+
 #include &quot;optionmm/command_line.hpp&quot;
 
 #include &quot;Util/Log.hpp&quot;
@@ -344,22 +346,29 @@
     ScriptManager::initialize();
     
     ScriptManager::runStr(&quot;LuaInitialize&quot;,&quot;print('Lua is working just fine');&quot;);
-        
-    BaseGameManager *manager = initialise(argc, argv);
 
     Palette::registerScript(); // here for the moment;
+
+    global_engine_state = new GlobalEngineState();
+
+    global_engine_state-&gt;game_manager = initialise(argc, argv);
+
     ScriptManager::runFile(&quot;unused&quot;,&quot;scripts/initialize.lua&quot;);
     
     // we'll catch every exception here, to be sure the user gets at least
     // a usefull error message and SDL has a chance to shutdown...
     try {
-        if (manager-&gt;launchNetPanzerGame()) {
-            while(manager-&gt;mainLoop())
-                ;
+        if ( global_engine_state-&gt;game_manager-&gt;launchNetPanzerGame() )
+        {
+            while ( global_engine_state-&gt;game_manager-&gt;mainLoop() )
+            {
+                // nothing
+            }
         }
 
-        manager-&gt;shutdown();
-        delete manager;
+        global_engine_state-&gt;game_manager-&gt;shutdown();
+        delete global_engine_state-&gt;game_manager;
+        delete global_engine_state;
         LOGGER.info(&quot;successfull shutdown.&quot;);
         shutdown();
     } 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,7 +17,7 @@
 */
 
 #include &quot;BaseGameManager.hpp&quot;
-
+#include &quot;Core/GlobalEngineState.hpp&quot;
 #include &quot;SDL.h&quot;
 
 // ** PObject netPanzer Network Includes
@@ -32,7 +32,6 @@
 #include &quot;System/DummySound.hpp&quot;
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Particles/Particle2D.hpp&quot;
 #include &quot;Particles/ParticleSystem2D.hpp&quot;
 #include &quot;Particles/ParticleInterface.hpp&quot;
@@ -58,33 +57,29 @@
 #include &quot;Network/MessageRouter.hpp&quot;
 #include &quot;Bot/BotManager.hpp&quot;
 
-BaseGameManager* gamemanager = 0;
-
 //------------------------------------------------------------------
 BaseGameManager::BaseGameManager()
     : running(true)
 {
-    assert(gamemanager == 0);
-    gamemanager = this;
 }
 
 //------------------------------------------------------------------
 BaseGameManager::~BaseGameManager()
 {
-    gamemanager = 0;
 }
 
 //-----------------------------------------------------------------
-void BaseGameManager::initializeSoundSubSystem()
+Sound * BaseGameManager::initializeSoundSubSystem()
 {
-    sound = new DummySound();
+     return new DummySound();
 }
 //-----------------------------------------------------------------
 void BaseGameManager::shutdownSoundSubSystem()
 {
-    if(sound) {
-        delete sound;
-        sound = 0;
+    if ( global_engine_state-&gt;sound_manager )
+    {
+        delete global_engine_state-&gt;sound_manager;
+        global_engine_state-&gt;sound_manager = 0;
     }
 }
 //-----------------------------------------------------------------
@@ -113,15 +108,16 @@
 //-----------------------------------------------------------------
 void BaseGameManager::initializeGameObjects()
 {
-    loadGameData();
+    loadGameData(); // load unit profiles and start resource manager.
+                   // unit profiles should be loaded when real game starts
 
-    Physics::init();
-    Weapon::init();
+    Physics::init(); // ok, only precalculates some values.
+    Weapon::init(); // only load images, should be on the resourcemanager.
+    PowerUpInterface::initialize(); // only load images
 
-    ConsoleInterface::initialize(25);
-    PowerUpInterface::initialize();
+    ConsoleInterface::initialize(25); // aargh
 
-    GameManager::initializeGameLogic();
+//    GameManager::initializeGameLogic(); // should be initialized when real game starts.
 }
 //-----------------------------------------------------------------
 void BaseGameManager::shutdownGameObjects()
@@ -129,18 +125,21 @@
 //-----------------------------------------------------------------
 void BaseGameManager::loadGameData()
 {
-    UnitProfileInterface::loadUnitProfiles();
-    
+    global_game_state = new GlobalGameState();
+
+    UnitProfileInterface * upi = new UnitProfileInterface();
+    upi-&gt;loadUnitProfiles();
+    if ( global_game_state-&gt;unit_profile_interface )
+    {
+        delete global_game_state-&gt;unit_profile_interface;
+    }
+    global_game_state-&gt;unit_profile_interface = upi;
+
     int numflags = ResourceManager::loadDefaultFlags();
     if ( numflags &lt;= 0 )
     {
         throw Exception(&quot;Couldn't find any flag in pics/flags/.&quot;);
     }
-
-//    if(gameconfig-&gt;playerflag.isDefaultValue())
-//    {
-//        gameconfig-&gt;playerflag=rand()%numflags;
-//    }
 }
 //-----------------------------------------------------------------
 void BaseGameManager::initializeNetworkSubSystem()
@@ -148,7 +147,7 @@
     //SERVER = new NetworkServer();
     //CLIENT = new NetworkClient();
 
-    ServerConnectDaemon::initialize( gameconfig-&gt;maxplayers );
+    ServerConnectDaemon::initialize( gameconfig-&gt;maxplayers ); // only if server
 
     NetworkState::setNetworkStatus( _network_state_server );
     NetworkState::resetNetworkStats();
@@ -163,16 +162,22 @@
 // boots up netPanzer; initializes all subsystems, game objects etc.
 void BaseGameManager::initialize(const std::string&amp; configfile)
 {
-    try {
-        if(!filesystem::exists(&quot;config&quot;))
+    try
+    {
+        if( !filesystem::exists(&quot;config&quot;) )
+        {
             filesystem::mkdir(&quot;config&quot;);
+        }
+
         initializeGameConfig(configfile);
-        initializeSoundSubSystem();
+        global_engine_state-&gt;sound_manager = initializeSoundSubSystem();
         initializeVideoSubSystem();
-        initializeGameObjects();
+        initializeGameObjects(); // aargh
         initializeNetworkSubSystem();
         initializeInputDevices();
-    } catch(std::exception&amp; e) {
+    }
+    catch(std::exception&amp; e)
+    {
         LOGGER.warning(&quot;Initialisation failed:\n%s&quot;, e.what());
         shutdown();
         throw Exception(&quot;bootstrap failed.&quot;);
@@ -186,7 +191,8 @@
 //-----------------------------------------------------------------
 void BaseGameManager::shutdownSubSystems()
 {
-    GameManager::shutdownGameLogic();
+    shutdownGameLogic();
+
     shutdownNetworkSubSystem();
     shutdownSoundSubSystem();
     shutdownVideoSubSystem();
@@ -229,20 +235,26 @@
     NetworkServer::cleanUpClientList();
     network::SocketManager::handleEvents();
 
+    // GameControlRulesDaemon might take some packets before they are routed.
+    GameControlRulesDaemon::updateGameControlFlow();
     MessageRouter::routePackets();
 
     if ( NetworkState::status == _network_state_server )
     {
         ServerConnectDaemon::connectProcess();
     }
-    else
+//    else
+//    {
+//        ClientConnectDaemon::connectProcess();
+//    }
+
+    NetworkState::updateNetworkStats();
+
+    if ( global_game_state-&gt;unit_manager )
     {
-        ClientConnectDaemon::connectProcess();
+        global_game_state-&gt;unit_manager-&gt;updateUnitStatus();
     }
 
-    NetworkState::updateNetworkStats();
-
-    UnitInterface::updateUnitStatus();
     ProjectileInterface::updateStatus();
     ObjectiveInterface::updateObjectiveStatus();
     PowerUpInterface::updateState();
@@ -253,7 +265,8 @@
     ParticleSystem2D::simAll();
     Particle2D::simAll();
 
-    GameControlRulesDaemon::updateGameControlFlow();
+//    GameControlRulesDaemon::updateGameControlFlow(); // moved up
+
     NetworkServer::sendRemaining();
     NetworkClient::sendRemaining();
     BotManager::simBots();
@@ -273,3 +286,77 @@
 {
     running = false;
 }
+
+void
+BaseGameManager::initializeGameLogic()
+{
+    PlayerInterface::initialize(gameconfig-&gt;maxplayers); // can pas
+
+    UnitInterface * uin = new UnitInterface();
+    uin-&gt;initialize(gameconfig-&gt;maxunits); // uses map
+    global_game_state-&gt;unit_manager = uin;
+
+    PathScheduler::initialize(); // uses map
+    PowerUpInterface::resetLogic(); // depends on map loaded
+
+    startGameTimer();
+}
+
+void
+BaseGameManager::reinitializeGameLogic()
+{
+    shutdownGameLogic();
+    initializeGameLogic();
+}
+
+bool
+BaseGameManager::resetGameLogic()
+{
+    PlayerInterface::reset();
+
+    if ( global_game_state-&gt;unit_manager )
+    {
+        global_game_state-&gt;unit_manager-&gt;reset();
+    }
+
+    PathScheduler::initialize();
+    PowerUpInterface::resetLogic();
+    ProjectileInterface::resetLogic();
+
+    startGameTimer();
+    return true;
+}
+
+void
+BaseGameManager::shutdownGameLogic()
+{
+    PlayerInterface::cleanUp();
+
+    if ( global_game_state-&gt;unit_manager )
+    {
+        delete global_game_state-&gt;unit_manager;
+        global_game_state-&gt;unit_manager = 0;
+    }
+
+//    UnitInterface::cleanUp();
+    PathScheduler::cleanUp();
+    //ObjectiveInterface::cleanUp();
+
+    game_elapsed_time_offset = 0;
+}
+
+void
+BaseGameManager::startGameTimer()
+{
+    time( &amp;game_start_time );
+}
+
+time_t
+BaseGameManager::getGameTime()
+{
+    time_t current_time;
+
+    time( &amp;current_time );
+
+    return( (current_time - game_start_time) + game_elapsed_time_offset );
+}

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/BaseGameManager.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,9 +19,39 @@
 #define _BASEGAMEMANAGER_HPP
 
 #include &lt;string&gt;
+#include &lt;ctime&gt;
 
+class Sound;
+
 class BaseGameManager
 {
+public:
+    BaseGameManager();
+    virtual ~BaseGameManager();
+
+    virtual void shutdown();
+
+    virtual void initialize(const std::string&amp; configfile = &quot;&quot;);
+
+    /// mainloop, return false if you want to quit
+    virtual bool mainLoop();
+
+    /// stop the mainloop
+    void stopMainLoop();
+
+    virtual bool launchNetPanzerGame() = 0;
+
+    void initializeGameLogic();
+    void reinitializeGameLogic();
+    bool resetGameLogic();
+    void shutdownGameLogic();
+
+    time_t getGameTime();
+    void setElapsetTimeOffset(time_t time_offset)
+    {
+        game_elapsed_time_offset = time_offset;
+    }
+
 protected:
     virtual void initializeNetworkSubSystem();
     virtual void shutdownNetworkSubSystem();
@@ -32,7 +62,7 @@
     virtual void initializeVideoSubSystem() = 0;
     virtual void shutdownVideoSubSystem() = 0;
 
-    virtual void initializeSoundSubSystem();
+    virtual Sound* initializeSoundSubSystem();
     virtual void shutdownSoundSubSystem();
 
     virtual void initializeGameConfig(const std::string&amp; configfile);
@@ -47,31 +77,17 @@
     virtual void graphicsLoop();
 
     virtual void shutdownSubSystems();
-public:
-    BaseGameManager();
-    virtual ~BaseGameManager();
+private:
+    void loadGameData();
+    void sleeping();
 
-    virtual void shutdown();
+    void   startGameTimer();
+    time_t game_start_time;
+    time_t game_elapsed_time_offset;
 
-    virtual void initialize(const std::string&amp; configfile = &quot;&quot;);
-
-    /// mainloop, return false if you want to quit
-    virtual bool mainLoop();
-    /// stop the mainloop
-    void stopMainLoop();
-
-    virtual bool launchNetPanzerGame() = 0;
-
-private:
-    void loadGameData();
-    void sleeping();                       
-    
     static const int TIMEINTERVAL = 20;
     /// this should be set to false if you want to quit netpanzer
     bool running;
 };
 
-/// the currently active gamemanager
-extern BaseGameManager* gamemanager;
-
 #endif

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/DedicatedGameManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -209,24 +209,14 @@
 //-----------------------------------------------------------------
 bool DedicatedGameManager::launchNetPanzerGame()
 {
-    *Console::server &lt;&lt; &quot;starting dedicated netPanzer server\n&quot;;
-
-    gameconfig-&gt;map = MapsManager::getNextMap(&quot;&quot;);
-
-    GameManager::dedicatedLoadGameMap(gameconfig-&gt;map.c_str());
-
-    GameManager::reinitializeGameLogic();
-
     MessageRouter::initialize(true);
     NetworkServer::openSession();
     NetworkServer::hostSession();
 
-    GameControlRulesDaemon::setStateServerInProgress();
     GameControlRulesDaemon::setDedicatedServer();
+    GameControlRulesDaemon::setStateServerLoadingMap();
     NetworkState::setNetworkStatus( _network_state_server );
 
-    GameManager::setNetPanzerGameOptions();
-
     gameconfig-&gt;hostorjoin=_game_session_host;
 
     Particle2D::setCreateParticles(false);
@@ -258,12 +248,11 @@
         }
     }
 
-    *Console::server &lt;&lt; &quot;game started.&quot; &lt;&lt; std::endl;
+    *Console::server &lt;&lt; &quot;Game starting.&quot; &lt;&lt; std::endl;
 
     console = new ServerConsole(this);
     console-&gt;startThread();
 
-    GameManager::startGameTimer();
     return true;
 }
 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,10 +16,14 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+#include &quot;Core/GlobalGameState.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/NetworkGlobals.hpp&quot;
 
 #include &quot;Util/NTimer.hpp&quot;
 #include &quot;Interfaces/GameControlRulesDaemon.hpp&quot;
 #include &quot;GameManager.hpp&quot;
+#include &quot;BaseGameManager.hpp&quot;
 
 #include &quot;Interfaces/GameManager.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
@@ -34,7 +38,13 @@
 #include &quot;Classes/Network/GameControlNetMessage.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 #include &quot;Classes/Network/ServerConnectDaemon.hpp&quot;
+#include &quot;Classes/Network/ConnectNetMessage.hpp&quot;
+#include &quot;Classes/Network/ClientServerNetMessage.hpp&quot;
+#include &quot;Classes/Network/PlayerNetMessage.hpp&quot;
 
+#include &quot;Classes/Network/NetworkClient.hpp&quot;
+#include &quot;Network/MessageRouter.hpp&quot;
+
 #include &quot;Views/Components/Desktop.hpp&quot;
 #include &quot;Views/Game/LoadingView.hpp&quot;
 
@@ -45,25 +55,29 @@
        _map_cycle_server_state_cycle_next_map,
        _map_cycle_server_state_load_map,
        _map_cycle_server_state_wait_for_client_map_load,
-       _map_cycle_server_state_respawn_players
+       _map_cycle_server_state_respawn_players,
+       _map_cycle_server_state_in_progress
      };
 
 enum { _map_cycle_client_idle,
+       _map_cycle_client_connecting_to_server,
+       _map_cycle_client_wait_connection,
+       _map_cycle_client_wait_link_ack,
+       _map_cycle_client_wait_connect_start,
+       _map_cycle_client_wait_connect_result,
+       _map_cycle_client_wait_game_setup,
        _map_cycle_client_start_map_load,
        _map_cycle_client_load_map,
+       _map_cycle_client_wait_for_resetgamelogic_or_connectid,
+       _map_cycle_client_wait_complete_connect,
        _map_cycle_client_wait_for_respawn_ack
-     };
+   };
 
 enum { _execution_mode_loop_back_server,
        _execution_mode_dedicated_server
      };
-enum { _game_state_idle,
-       _game_state_in_progress,
-       _game_state_completed
-     };
 
 int GameControlRulesDaemon::execution_mode = _execution_mode_loop_back_server;
-unsigned char GameControlRulesDaemon::game_state  = _game_state_idle;
 std::string GameControlRulesDaemon::nextmap = &quot;&quot;;
 NTimer GameControlRulesDaemon::respawntimer;
 
@@ -76,17 +90,28 @@
 
 int GameControlRulesDaemon::map_cycle_fsm_client_state = _map_cycle_client_idle;
 bool GameControlRulesDaemon::map_cycle_fsm_client_respawn_ack_flag = false;
-char GameControlRulesDaemon::map_cycle_fsm_client_map_name[256];
 
+static std::string connecting_server_name;
+
 //-----------------------------------------------------------------
-void GameControlRulesDaemon::setStateServerInProgress()
+void GameControlRulesDaemon::setStateServerLoadingMap()
 {
-    GameControlRulesDaemon::game_state = _game_state_in_progress;
+    GameControlRulesDaemon::map_cycle_fsm_server_state = _map_cycle_server_state_cycle_next_map;
 }
 //-----------------------------------------------------------------
+void GameControlRulesDaemon::setStateClientLoadingMap()
+{
+    GameControlRulesDaemon::map_cycle_fsm_client_state = _map_cycle_client_start_map_load;
+}
+void GameControlRulesDaemon::setStateClientConnectToServer(const std::string&amp; server_name)
+{
+    connecting_server_name = server_name;
+    GameControlRulesDaemon::map_cycle_fsm_client_state = _map_cycle_client_connecting_to_server;
+}
+//-----------------------------------------------------------------
 void GameControlRulesDaemon::setStateServerIdle()
 {
-    GameControlRulesDaemon::game_state = _game_state_idle;
+    GameControlRulesDaemon::map_cycle_fsm_server_state = _map_cycle_server_state_idle;
 }
 //-----------------------------------------------------------------
 void GameControlRulesDaemon::setDedicatedServer()
@@ -97,18 +122,191 @@
 //-----------------------------------------------------------------
 void GameControlRulesDaemon::mapCycleFsmClient()
 {
-    switch( map_cycle_fsm_client_state ) {
+    bool loop_finished = false;
+    while ( ! loop_finished )
+    {
+        loop_finished = true;
+    switch( map_cycle_fsm_client_state )
+    {
         case _map_cycle_client_idle :
             return;
 
+        case _map_cycle_client_connecting_to_server:
+            LoadingView::show();
+            LoadingView::append(&quot;Starting network connection...&quot;);
+            NetworkState::setNetworkStatus( _network_state_client );
+            MessageRouter::initialize(false);
+            NetworkClient::joinServer(connecting_server_name);
+            map_cycle_fsm_client_state = _map_cycle_client_wait_connection;
+            break;
+
+        case _map_cycle_client_wait_connection:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    const NetMessage * msg = np.getNetMessage();
+                    if (  msg-&gt;message_class == _net_message_class_client_server
+                        &amp;&amp; msg-&gt;message_id == _net_message_id_client_connect_ack
+                       )
+                    {
+                        LoadingView::append(&quot;Sending join request...&quot;);
+                        ClientConnectJoinRequest join_request;
+                        join_request.setProtocolVersion(NETPANZER_PROTOCOL_VERSION);
+                        NetworkClient::sendMessage(&amp;join_request, sizeof(join_request));
+                        map_cycle_fsm_client_state = _map_cycle_client_wait_link_ack;
+                    }
+                    else
+                    {
+                        LoadingView::append(&quot;Error in wait_connection&quot;);
+                        // TODO fail here if message is not expected
+                    }
+                }
+            }
+            break;
+
+        case _map_cycle_client_wait_link_ack:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    const ClientConnectJoinRequestAck * msg = (ClientConnectJoinRequestAck*)np.getNetMessage();
+                    if (  msg-&gt;message_class == _net_message_class_connect
+                        &amp;&amp; msg-&gt;message_id == _net_message_id_connect_join_game_request_ack
+                       )
+                    {
+                        switch ( msg-&gt;getResultCode() )
+                        {
+                            case _join_request_result_success:
+                                LoadingView::append(&quot;Link to Server Established&quot;);
+                                loop_finished = false;
+                                map_cycle_fsm_client_state = _map_cycle_client_wait_connect_start;
+                                break;
+
+                            case _join_request_result_invalid_protocol:
+                                // TODO fail here
+                                break;
+
+                            case _join_request_result_server_busy:
+                                // TODO fail here
+                                break;
+
+                            default:
+                                // TODO fail here if message is not expected
+                                ;
+                        }
+                    }
+                    else
+                    {
+                        LoadingView::append(&quot;Error in wait_link_ack&quot;);
+                        // TODO fail here if message is not expected
+                    }
+                }
+            }
+            break;
+
+        case _map_cycle_client_wait_connect_start:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    const NetMessage * msg = np.getNetMessage();
+                    if (  msg-&gt;message_class == _net_message_class_connect
+                        &amp;&amp; msg-&gt;message_id == _net_message_id_client_start_connect
+                       )
+                    {
+                        LoadingView::append(&quot;Starting connection ...&quot;);
+                        ClientConnectRequest connect_request;
+                        NetworkClient::sendMessage(&amp;connect_request, sizeof(connect_request));
+                        loop_finished = false;
+                        map_cycle_fsm_client_state = _map_cycle_client_wait_connect_result;
+                    }
+                    else
+                    {
+                        // TODO fail here if message is not expected
+                    }
+                }
+            }
+            break;
+
+        case _map_cycle_client_wait_connect_result:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    const ClientConnectResult * msg = (ClientConnectResult*)np.getNetMessage();
+                    if (  msg-&gt;message_class == _net_message_class_connect
+                        &amp;&amp; msg-&gt;message_id == _net_message_id_client_connect_result
+                       )
+                    {
+                         if ( msg-&gt;result_code == _connect_result_success )
+                        {
+                            LoadingView::append(&quot;Sending client settings...&quot;);
+                            ConnectClientSettings client_setting;
+
+                            client_setting.set(gameconfig-&gt;playername.c_str(),
+                                               gameconfig-&gt;getUnitColor(),
+                                               gameconfig-&gt;playerflag.c_str());
+
+                            NetworkClient::sendMessage(&amp;client_setting, sizeof(client_setting));
+                            loop_finished = false;
+                            map_cycle_fsm_client_state = _map_cycle_client_wait_game_setup;
+                        }
+                        else
+                        {
+                            // TODO fail here
+                        }
+                    }
+                    else
+                    {
+                        // TODO fail here if message is not expected
+                    }
+                }
+            }
+            break;
+
+        case _map_cycle_client_wait_game_setup:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    const ConnectMesgServerGameSettings * msg = (ConnectMesgServerGameSettings*)np.getNetMessage();
+                    if (  msg-&gt;message_class == _net_message_class_connect
+                        &amp;&amp; msg-&gt;message_id == _net_message_id_connect_server_game_setup
+                       )
+                    {
+                         LoadingView::append(&quot;Received server settings...&quot;);
+                        gameconfig-&gt;maxplayers = msg-&gt;getMaxPlayers();
+                        gameconfig-&gt;maxunits = msg-&gt;getMaxUnits();
+                        gameconfig-&gt;cloudcoverage = msg-&gt;getCloudCoverage();
+                        gameconfig-&gt;windspeed = (int)msg-&gt;getWindSpeed();
+                        gameconfig-&gt;powerups = msg-&gt;powerup_state;
+                        gameconfig-&gt;gametype = msg-&gt;getGameType();
+                        gameconfig-&gt;fraglimit = msg-&gt;getFragLimit();
+                        gameconfig-&gt;timelimit = msg-&gt;getTimeLimit();
+
+                        global_engine_state-&gt;game_manager-&gt;setElapsetTimeOffset(msg-&gt;getElapsedTime());
+                        gameconfig-&gt;map = msg-&gt;map_name;
+
+                        ConnectMesgClientGameSetupPing ping;
+                        NetworkClient::sendMessage(&amp;ping, sizeof(ping));
+                        loop_finished = false;
+                        map_cycle_fsm_client_state = _map_cycle_client_start_map_load;
+                    }
+                    else
+                    {
+                        // TODO fail here if message is not expected
+                    }
+                }
+            }
+            break;
+
         case _map_cycle_client_start_map_load : {
                 LoadingView::show();
 
                 GameManager::shutdownParticleSystems();
                 ObjectiveInterface::resetLogic();
 
-                gameconfig-&gt;map = map_cycle_fsm_client_map_name;
-
                 char buf[256];
                 snprintf(buf, sizeof(buf), &quot;Next Map '%s'.&quot;,
                         gameconfig-&gt;map.c_str());
@@ -124,18 +322,20 @@
                     return;
                 }
                 
-                GameManager::resetGameLogic();
+                global_engine_state-&gt;game_manager-&gt;resetGameLogic();
+                loop_finished = false;
                 map_cycle_fsm_client_state = _map_cycle_client_load_map;
-                return;
             }
             break;
 
-        case _map_cycle_client_load_map : {
-                int percent_complete;
-                char str_buf[128];
+        case _map_cycle_client_load_map:
+        {
+//                int percent_complete;
+//                char str_buf[128];
+            LoadingView::append(&quot;Map loaded, sending ack...&quot;);
 
+            global_engine_state-&gt;game_manager-&gt;reinitializeGameLogic();
 //                if ( GameManager::gameMapLoad( &amp;percent_complete ) == false ) {
-                    map_cycle_fsm_client_state = _map_cycle_client_wait_for_respawn_ack;
 //
 //                    sprintf( str_buf, &quot;Loading Game Map ... (%d%%)&quot;, percent_complete);
 //                    LoadingView::update( str_buf );
@@ -145,32 +345,98 @@
 //                    sprintf( str_buf, &quot;Loading Game Map ... (%d%%)&quot;, percent_complete);
 //                    LoadingView::update( str_buf );
 //                }
+            ConnectMesgClientGameSetupAck ack;
+            NetworkClient::sendMessage( &amp;ack, sizeof(ack));
+            loop_finished = false;
+            map_cycle_fsm_client_state = _map_cycle_client_wait_for_resetgamelogic_or_connectid;
+            break;
+        }
 
-                return;
-            }
+        case _map_cycle_client_wait_for_resetgamelogic_or_connectid:
+            {
+                NetPacket np;
+                if ( MessageRouter::getNextPacket(np) )
+                {
+                    switch ( np.getNetMessage()-&gt;message_class )
+                    {
+                        case _net_message_class_player:
+                            if ( np.getNetMessage()-&gt;message_id == _net_message_id_player_connect_id )
+                            {
+                                LoadingView::append(&quot;Received my id...&quot;);
+                                MessageRouter::routePacket(np);
+                                loop_finished = false;
+                                map_cycle_fsm_client_state = _map_cycle_client_wait_complete_connect;
+                            }
+                            else
+                            {
+                                // TODO fail here
+                            }
+                            break;
 
-        case _map_cycle_client_wait_for_respawn_ack : {
-                if( map_cycle_fsm_client_respawn_ack_flag == true ) {
-                    LoadingView::loadFinish();
-                    map_cycle_fsm_client_respawn_ack_flag = false;
-                    map_cycle_fsm_client_state = _map_cycle_client_idle;
+                        case _net_message_class_system:
+                            if ( np.getNetMessage()-&gt;message_id == _net_message_id_system_reset_game_logic )
+                            {
+                                LoadingView::append(&quot;Resetting game logic...&quot;);
+                                global_engine_state-&gt;game_manager-&gt;resetGameLogic();
+                                loop_finished = false;
+                                map_cycle_fsm_client_state = _map_cycle_client_wait_for_respawn_ack;
+                            }
+                            else
+                            {
+                                // TODO fail here
+                            }
+                            break;
+                        default:
+                            // TODO fail here if message is not expected
+                            ;
+                    }
+
                 }
+            }
+            break;
 
-                return;
+        case _map_cycle_client_wait_for_respawn_ack:
+            if( map_cycle_fsm_client_respawn_ack_flag == true )
+            {
+                LoadingView::loadFinish();
+                map_cycle_fsm_client_respawn_ack_flag = false;
+                map_cycle_fsm_client_state = _map_cycle_client_idle;
             }
             break;
 
+        case _map_cycle_client_wait_complete_connect:
+            {
+                NetPacket np;
+                bool in_loop = true;
+                while ( in_loop &amp;&amp;  MessageRouter::getNextPacket(np) )
+                {
+                    if ( np.getNetMessage()-&gt;message_class == _net_message_class_connect
+                        &amp;&amp; np.getNetMessage()-&gt;message_id == _net_message_id_client_connect_process_state_mesg
+                        &amp;&amp; ((ConnectProcessStateMessage*)np.getNetMessage())-&gt;getMessageEnum() == _connect_state_sync_complete
+                       )
+                    {
+                        map_cycle_fsm_client_state = _map_cycle_client_idle;
+                    }
+
+                    MessageRouter::routePacket(np);
+                }
+            }
+            break;
     } // ** switch
+
+    }
 }
 
 
 void GameControlRulesDaemon::mapCycleFsmServer()
 {
-    switch( map_cycle_fsm_server_state ) {
+    switch ( map_cycle_fsm_server_state )
+    {
         case _map_cycle_server_state_idle:
             break;
 
-        case _map_cycle_server_state_display_endgame_views: {
+        case _map_cycle_server_state_display_endgame_views:
+            {
                 ChatInterface::setMessageScopeServer();
                 ChatInterface::sendCurrentMessage(&quot;Round is over&quot;);
                                                                 
@@ -194,10 +460,12 @@
             }
             break;
 
-        case _map_cycle_server_state_cycle_next_map : {
+        case _map_cycle_server_state_cycle_next_map:
+            {
                 if ( map_cycle_fsm_server_endgame_timer.count() &amp;&amp;
                         (ServerConnectDaemon::isConnecting() == false)
-                   ) {
+                   )
+                {
                     GameManager::shutdownParticleSystems();
 
                     if(nextmap != &quot;&quot;) {
@@ -216,14 +484,12 @@
 
                     NetworkServer::broadcastMessage( &amp;cycle_map_mesg, sizeof( GameControlCycleMap ));
 
-                    if ( GameControlRulesDaemon::execution_mode == _execution_mode_dedicated_server ) {
-                        ObjectiveInterface::resetLogic();
+                    ObjectiveInterface::resetLogic();
 
-                        GameManager::dedicatedLoadGameMap(
-                                gameconfig-&gt;map.c_str());
+                    if ( GameControlRulesDaemon::execution_mode == _execution_mode_dedicated_server )
+                    {
+                        GameManager::dedicatedLoadGameMap(gameconfig-&gt;map.c_str());
 
-                        GameManager::resetGameLogic();
-
                         map_cycle_fsm_server_map_load_timer.changePeriod(_MAP_CYCLE_MAP_LOAD_WAIT_PERIOD);
                         map_cycle_fsm_server_map_load_timer.reset();
                         map_cycle_fsm_server_state = _map_cycle_server_state_wait_for_client_map_load;
@@ -231,7 +497,6 @@
                         LoadingView::show();
 
                         LoadingView::append( &quot;Loading Game Map ...&quot; );
-                        ObjectiveInterface::resetLogic();
 
                         try {
                             GameManager::loadGameMap(gameconfig-&gt;map.c_str());
@@ -243,18 +508,15 @@
                             return;
                         }
                         
-                        GameManager::resetGameLogic();
                         map_cycle_fsm_server_state = _map_cycle_server_state_load_map;
-                        return;
                     }
-
                 }
             }
             break;
 
         case _map_cycle_server_state_load_map : {
-                int percent_complete;
-                char str_buf[128];
+//                int percent_complete;
+//                char str_buf[128];
 
 //                if ( GameManager::gameMapLoad( &amp;percent_complete ) == false ) {
                     map_cycle_fsm_server_state = _map_cycle_server_state_respawn_players;
@@ -265,36 +527,59 @@
             }
             break;
 
-        case _map_cycle_server_state_wait_for_client_map_load : {
-                if ( map_cycle_fsm_server_map_load_timer.count() ) {
-                    ConsoleInterface::postMessage(Color::white, false, 0, &quot;game started.&quot;);
+        case _map_cycle_server_state_wait_for_client_map_load :
+            {
+                if ( map_cycle_fsm_server_map_load_timer.count() )
+                {
+                    ConsoleInterface::postMessage(Color::white, false, 0, &quot;Game started.&quot;);
                     map_cycle_fsm_server_state = _map_cycle_server_state_respawn_players;
                 }
             }
             break;
 
-        case _map_cycle_server_state_respawn_players : {
-                SystemResetGameLogic reset_game_logic_mesg;
+        case _map_cycle_server_state_respawn_players :
+            {
+                if ( ! global_game_state-&gt;unit_manager )
+                {
+                    ConsoleInterface::postMessage(Color::white, false, 0, &quot;Reinitializing game logic.&quot;);
+                    global_engine_state-&gt;game_manager-&gt;reinitializeGameLogic();
+                    if ( GameControlRulesDaemon::execution_mode == _execution_mode_loop_back_server )
+                    {
+                        PlayerState * player_state = PlayerInterface::allocateLoopBackPlayer();
+                        player_state-&gt;setName(gameconfig-&gt;playername.c_str());
+                        ResourceManager::loadDefaultFlags();
+                        Uint8 flagdata[20*14]; // XXX shouldn't use fixed values
+                        ResourceManager::getFlagData(gameconfig-&gt;playerflag.c_str(), (Uint8 *)&amp;flagdata);
+                        player_state-&gt;setFlag(ResourceManager::registerFlagFromData(flagdata));
+                    }
+                }
+                else
+                {
+                    ConsoleInterface::postMessage(Color::white, false, 0, &quot;Resetting game logic.&quot;);
+                    SystemResetGameLogic reset_game_logic_mesg;
+                    global_engine_state-&gt;game_manager-&gt;resetGameLogic();
+                    NetworkServer::broadcastMessage( &amp;reset_game_logic_mesg, sizeof(SystemResetGameLogic));
+                }
 
-                GameManager::resetGameLogic();
-                NetworkServer::broadcastMessage( &amp;reset_game_logic_mesg, sizeof(SystemResetGameLogic));
-
                 GameManager::respawnAllPlayers();
 
                 PlayerInterface::unlockPlayerStats();
-                GameControlRulesDaemon::game_state = _game_state_in_progress;
 
                 LoadingView::loadFinish();
 
                 GameControlCycleRespawnAck respawn_ack_mesg;
                 NetworkServer::broadcastMessage( &amp;respawn_ack_mesg, sizeof(GameControlCycleRespawnAck));
 
-                map_cycle_fsm_server_state = _map_cycle_server_state_idle;
+                map_cycle_fsm_server_state = _map_cycle_server_state_in_progress;
 
                 ServerConnectDaemon::unlockConnectProcess();
             }
             break;
 
+        case _map_cycle_server_state_in_progress:
+            checkGameRules();
+            break;
+
     } // ** switch
 }
 
@@ -303,7 +588,6 @@
     PlayerInterface::lockPlayerStats();
 
     map_cycle_fsm_server_state = _map_cycle_server_state_display_endgame_views;
-    GameControlRulesDaemon::game_state = _game_state_completed;
 }
 
 void GameControlRulesDaemon::onFraglimitGameCompleted()
@@ -311,7 +595,6 @@
     PlayerInterface::lockPlayerStats();
 
     map_cycle_fsm_server_state = _map_cycle_server_state_display_endgame_views;
-    GameControlRulesDaemon::game_state = _game_state_completed;
 }
 
 void GameControlRulesDaemon::onObjectiveGameCompleted()
@@ -319,7 +602,6 @@
     PlayerInterface::lockPlayerStats();
 
     map_cycle_fsm_server_state = _map_cycle_server_state_display_endgame_views;
-    GameControlRulesDaemon::game_state = _game_state_completed;
 }
 
 void GameControlRulesDaemon::forceMapChange(std::string _nextmap)
@@ -329,55 +611,48 @@
     PlayerInterface::lockPlayerStats();
 
     map_cycle_fsm_server_state = _map_cycle_server_state_display_endgame_views;
-    GameControlRulesDaemon::game_state = _game_state_completed;
 }
 
 void GameControlRulesDaemon::checkGameRules()
 {
     PlayerState *player_state;
 
-    if ( (GameControlRulesDaemon::game_state == _game_state_in_progress) &amp;&amp;
-            (NetworkState::status == _network_state_server)
-       )
+    unsigned char game_type;
+    game_type = gameconfig-&gt;gametype;
+
+    switch( game_type )
     {
-        unsigned char game_type;
-        game_type = gameconfig-&gt;gametype;
-
-        switch( game_type )
+        case  _gametype_timelimit:
         {
-            case  _gametype_timelimit:
+            int game_minutes = global_engine_state-&gt;game_manager-&gt;getGameTime() / 60;
+            if( game_minutes &gt;= gameconfig-&gt;timelimit )
             {
-                int game_minutes = GameManager::getGameTime() / 60;
-                if( game_minutes &gt;= gameconfig-&gt;timelimit )
-                {
-                    onTimelimitGameCompleted();
-                }
-                break;
-            }   
-            case _gametype_fraglimit:
-                if ( PlayerInterface::testRuleScoreLimit( gameconfig-&gt;fraglimit, &amp;player_state ) == true )
-                {
-                    onFraglimitGameCompleted();
-                }
-                break;
+                onTimelimitGameCompleted();
+            }
+            break;
+        }
+        case _gametype_fraglimit:
+            if ( PlayerInterface::testRuleScoreLimit( gameconfig-&gt;fraglimit, &amp;player_state ) == true )
+            {
+                onFraglimitGameCompleted();
+            }
+            break;
 
-            case _gametype_objective:
+        case _gametype_objective:
+        {
+            float ratio = (float) gameconfig-&gt;objectiveoccupationpercentage / 100.0;
+            if (PlayerInterface::testRuleObjectiveRatio( ratio, &amp;player_state))
             {
-                float ratio = (float) gameconfig-&gt;objectiveoccupationpercentage / 100.0;
-                if (PlayerInterface::testRuleObjectiveRatio( ratio, &amp;player_state))
-                {
-                    onObjectiveGameCompleted( );
-                }
-                break;
+                onObjectiveGameCompleted( );
             }
-            default:
-                // nothing
-                ;
+            break;
         }
-
-        checkRespawn();
+        default:
+            // nothing
+            ;
     }
 
+    checkRespawn();
 }
 
 void
@@ -393,7 +668,7 @@
             for ( unsigned short player = 0; player &lt; PlayerInterface::getMaxPlayers(); player++ )
             {
                 if ( PlayerInterface::getPlayer(player)-&gt;getStatus() == _player_state_active
-                     &amp;&amp; UnitInterface::getUnitCount( player ) &gt; 0 )
+                     &amp;&amp; global_game_state-&gt;unit_manager-&gt;getUnitCount( player ) &gt; 0 )
                 {
                     players_alive++;
                 }
@@ -423,7 +698,7 @@
         for ( unsigned short player = 0; player &lt; PlayerInterface::getMaxPlayers(); player++ )
         {
             if ( PlayerInterface::getPlayer(player)-&gt;getStatus() == _player_state_active
-                 &amp;&amp; UnitInterface::getUnitCount( player ) == 0 )
+                 &amp;&amp; global_game_state-&gt;unit_manager-&gt;getUnitCount( player ) == 0 )
             {
                 GameManager::spawnPlayer(player);
             }
@@ -436,9 +711,9 @@
 void GameControlRulesDaemon::netMessageCycleMap(const NetMessage* message)
 {
     GameControlCycleMap *cycle_map_mesg;
+    cycle_map_mesg = (GameControlCycleMap *) message;
+    gameconfig-&gt;map = cycle_map_mesg-&gt;map_name;
 
-    cycle_map_mesg = (GameControlCycleMap *) message;
-    snprintf(map_cycle_fsm_client_map_name, 256, cycle_map_mesg-&gt;map_name);
     map_cycle_fsm_client_state = _map_cycle_client_start_map_load;
 }
 
@@ -473,8 +748,6 @@
     } else {
         mapCycleFsmClient();
     }
-
-    checkGameRules();
 }
 
 void GameControlRulesDaemon::mapLoadFailureResponse(int result_code, const char *map_name)

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameControlRulesDaemon.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -37,7 +37,6 @@
     static void mapCycleFsmServer();
 
     static int map_cycle_fsm_client_state;
-    static char map_cycle_fsm_client_map_name[256];
     static bool map_cycle_fsm_client_respawn_ack_flag;
     static void mapCycleFsmClient();
 
@@ -54,7 +53,9 @@
     static void netMessageCycleRespawnAck(const NetMessage* message);
 
 public:
-    static void setStateServerInProgress();
+    static void setStateServerLoadingMap();
+    static void setStateClientLoadingMap();
+    static void setStateClientConnectToServer(const std::string&amp;  server_name);
     static void setStateServerIdle();
     static void setDedicatedServer();
 
@@ -62,7 +63,7 @@
 
     static void processNetMessage(const NetMessage* message);
     static void updateGameControlFlow();
-    static unsigned char getGameState() { return game_state; }
+    static unsigned char getGameState() { return map_cycle_fsm_server_state; }
 };
 
 #endif // ** _GAME_CONTROL_RULES_DAEMON_HPP

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,7 @@
 */
 
 #include &quot;Interfaces/GameManager.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
 
 #include &lt;stdio.h&gt;
 #include &lt;fcntl.h&gt;
@@ -100,18 +101,11 @@
 
 #include &quot;Bot/Bot.hpp&quot;
 
+#include &quot;Classes/SpawnList.hpp&quot;
+
 #define _MAX_INITIALIZE_PROCS (10)
 #define _MAX_DEDICATED_INITIALIZE_PROCS (8)
 
-
-time_t GameManager::game_start_time = 0;
-time_t GameManager::game_elapsed_time_offset = 0;
-
-bool GameManager::display_frame_rate_flag = false;
-bool GameManager::display_network_info_flag;
-
-std::string GameManager::map_path;
-
 // ******************************************************************
 
 void GameManager::drawTextCenteredOnScreen(const char *string, IntColor color)
@@ -178,45 +172,6 @@
     Palette::setColors();
 }
 
-// ******************************************************************
-void GameManager::initializeGameLogic()
-{
-    PlayerInterface::initialize(gameconfig-&gt;maxplayers);
-    UnitBlackBoard::initializeBlackBoard();
-    UnitInterface::initialize( gameconfig-&gt;GetUnitsPerPlayer() );
-    PathScheduler::initialize();
-    PowerUpInterface::resetLogic();
-}
-
-// ******************************************************************
-void GameManager::reinitializeGameLogic()
-{
-    shutdownGameLogic();
-    initializeGameLogic();
-}
-
-// ******************************************************************
-bool GameManager::resetGameLogic()
-{
-    PlayerInterface::reset();
-    UnitInterface::reset();
-    UnitBlackBoard::initializeBlackBoard();
-    PathScheduler::initialize();
-    PowerUpInterface::resetLogic();
-    ProjectileInterface::resetLogic();
-    startGameTimer();
-    return true;
-}
-
-// ******************************************************************
-void GameManager::shutdownGameLogic()
-{
-    PlayerInterface::cleanUp();
-    UnitInterface::cleanUp();
-    PathScheduler::cleanUp();
-    //ObjectiveInterface::cleanUp();
-}
-
 void GameManager::shutdownParticleSystems()
 {
     ParticleSystem2D::removeAll();
@@ -226,29 +181,19 @@
 // ******************************************************************
 void GameManager::loadGameMap(const char *map_file_path)
 {
-    map_path = &quot;maps/&quot;;
+    std::string map_path(&quot;maps/&quot;);
     map_path.append(map_file_path);
 
     if (!MapInterface::loadMap( map_path.c_str(), true ))
         throw Exception(&quot;map format error.&quot;);
 
-    finishGameMapLoad();
-}
+    map_path.append(&quot;.opt&quot;);
+    ObjectiveInterface::loadObjectiveList( map_path.c_str() );
 
-// ******************************************************************
-
-void GameManager::finishGameMapLoad()
-{
-    std::string temp_path = map_path;
-    temp_path.append(&quot;.opt&quot;);
-    LOGGER.warning(&quot;Loading objectives from %s&quot;, temp_path.c_str());
-    ObjectiveInterface::loadObjectiveList( temp_path.c_str() );
-
     ParticleInterface::initParticleSystems();
 
     ParticleInterface::addCloudParticle(gameconfig-&gt;cloudcoverage);
-    Physics::wind.setVelocity(gameconfig-&gt;windspeed, 107);
-}
+    Physics::wind.setVelocity(gameconfig-&gt;windspeed, 107);}
 
 // ******************************************************************
 
@@ -269,16 +214,14 @@
         &lt;&lt; &quot;Powerups: &quot; &lt;&lt; (gameconfig-&gt;powerups ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;AllowAllies: &quot; &lt;&lt; (gameconfig-&gt;allowallies ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;CloudCoverage: &quot; &lt;&lt; gameconfig-&gt;cloudcoverage &lt;&lt; &quot; (Windspeed &quot;
-           &lt;&lt; gameconfig-&gt;windspeed &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+                             &lt;&lt; gameconfig-&gt;windspeed &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
     
-    map_path = &quot;maps/&quot;;
+    std::string map_path(&quot;maps/&quot;);
     map_path.append(map_name);
 
     MapInterface::loadMap( map_path.c_str(), false );
 
     map_path.append(&quot;.opt&quot;);
-    LOGGER.warning(&quot;Loading objectives: %s&quot;, map_path.c_str());
-
     ObjectiveInterface::loadObjectiveList( map_path.c_str() );
 
     ParticleInterface::initParticleSystems();
@@ -288,10 +231,11 @@
 // ******************************************************************
 void GameManager::spawnPlayer( Uint16 player )
 {
-    sound-&gt;stopTankIdle();
+    global_engine_state-&gt;sound_manager-&gt;stopTankIdle();
 
     // ** Get a new spawn point and spawn the player **
-    iXY spawn_point = MapInterface::getFreeSpawnPoint();
+    iXY spawn_point = global_game_state-&gt;spawn_list-&gt;getFreeSpawnPoint();
+
     PlayerInterface::spawnPlayer( player, spawn_point );
 
     //** Change the location of the view camera to the spawn point **
@@ -307,7 +251,7 @@
         NetworkServer::sendMessage(player, &amp;set_view, sizeof(SystemSetPlayerView));
     }
 
-    sound-&gt;playTankIdle();
+    global_engine_state-&gt;sound_manager-&gt;playTankIdle();
 }
 
 void GameManager::respawnAllPlayers()
@@ -403,7 +347,7 @@
 
 void GameManager::netMessageResetGameLogic(const NetMessage* )
 {
-    resetGameLogic();
+    global_engine_state-&gt;game_manager-&gt;resetGameLogic();
 }
 
 // ******************************************************************
@@ -422,7 +366,7 @@
     game_setup-&gt;powerup_state = gameconfig-&gt;powerups;
     game_setup-&gt;setFragLimit(gameconfig-&gt;fraglimit);
     game_setup-&gt;setTimeLimit(gameconfig-&gt;timelimit);
-    game_setup-&gt;setElapsedTime(getGameTime());
+    game_setup-&gt;setElapsedTime(global_engine_state-&gt;game_manager-&gt;getGameTime());
 
     return game_setup;
 }
@@ -476,17 +420,17 @@
     gameconfig-&gt;fraglimit = game_setup-&gt;getFragLimit();
     gameconfig-&gt;timelimit = game_setup-&gt;getTimeLimit();
 
-    startGameTimer();
-    game_elapsed_time_offset = game_setup-&gt;getElapsedTime();
+    global_engine_state-&gt;game_manager-&gt;setElapsetTimeOffset(game_setup-&gt;getElapsedTime());
+    gameconfig-&gt;map = game_setup-&gt;map_name;
 
-    try {
-        loadGameMap(game_setup-&gt;map_name);
-    } catch(std::exception&amp; e) {
-        LOGGER.warning(&quot;XError while loading map '%s': %s&quot;,
-                game_setup-&gt;map_name, e.what());
-        *result_code = _mapload_result_no_map_file;
-        return false;
-    }
+//    try {
+//        loadGameMap(game_setup-&gt;map_name);
+//    } catch(std::exception&amp; e) {
+//        LOGGER.warning(&quot;XError while loading map '%s': %s&quot;,
+//                game_setup-&gt;map_name, e.what());
+//        *result_code = _mapload_result_no_map_file;
+//        return false;
+//    }
 
     *result_code = _mapload_result_success;
     return true;
@@ -496,7 +440,7 @@
 
 void GameManager::clientGameSetup( )
 {
-    reinitializeGameLogic();
+    global_engine_state-&gt;game_manager-&gt;reinitializeGameLogic();
 }
 
 // ******************************************************************
@@ -552,7 +496,7 @@
 {
     quitNetPanzerGame();
 
-    gamemanager-&gt;stopMainLoop();
+    global_engine_state-&gt;game_manager-&gt;stopMainLoop();
 }
 
 void GameManager::quitNetPanzerGame()
@@ -566,32 +510,16 @@
 
         // hacky...
         PlayerGameManager* playerGameManager 
-            = dynamic_cast&lt;PlayerGameManager*&gt;(gamemanager);
+            = dynamic_cast&lt;PlayerGameManager*&gt;(global_engine_state-&gt;game_manager);
         if(playerGameManager)
             playerGameManager-&gt;quitGame();
     }
 
     ParticleSystem2D::removeAll();
     Particle2D::removeAll();
-    sound-&gt;stopTankIdle();
-    UnitInterface::reset();
+    global_engine_state-&gt;sound_manager-&gt;stopTankIdle();
+//    UnitInterface::reset();
     PlayerInterface::reset();
     ObjectiveInterface::resetLogic();
     GameControlRulesDaemon::setStateServerIdle();
 }
-
-void GameManager::startGameTimer()
-{
-    game_elapsed_time_offset = 0;
-    time( &amp;game_start_time );
-}
-
-time_t GameManager::getGameTime()
-{
-    time_t current_time;
-
-    time( &amp;current_time );
-
-    return( (current_time - game_start_time) + game_elapsed_time_offset );
-}
-

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/GameManager.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -37,28 +37,6 @@
 
 class GameManager
 {
-private:
-    static std::string map_path;
-
-protected:
-    static time_t game_start_time;
-    static time_t game_elapsed_time_offset;
-
-    static bool display_frame_rate_flag;
-    static bool display_network_info_flag;
-
-protected:
-    static void finishGameMapLoad();
-
-    // ** Network Message Handlers
-    static void netMessageSetView(const NetMessage* message);
-    static void netMessageViewControl(const  NetMessage* message);
-    static void netMessageClientGameSetup(const NetMessage* message);
-    static void netMessagePingRequest(const NetMessage* message);
-    static void netMessagePingAcknowledge(const NetMessage* message);
-    static void netMessageConnectAlert(const NetMessage* message);
-    static void netMessageResetGameLogic(const NetMessage* message);
-
 public:
     static void dedicatedLoadGameMap(const char *map_file_path );
     static void loadGameMap(const char *map_file_path);
@@ -67,18 +45,12 @@
     static void spawnPlayer( Uint16 player );
     static void respawnAllPlayers();
 
-    static void initializeGameLogic();
-    static void reinitializeGameLogic();
-    static bool resetGameLogic();
-    static void shutdownGameLogic();
-
     static void shutdownParticleSystems();
 
     static bool startClientGameSetup(const NetMessage* message, int *result_code);
     static void clientGameSetup();
     static ConnectMesgServerGameSettings* getServerGameSetup();
 
-public:
     static void exitNetPanzer();
 
     static void quitNetPanzerGame();
@@ -93,8 +65,15 @@
 
     static void drawTextCenteredOnScreen(const char *string, IntColor color);
 
-    static void   startGameTimer();
-    static time_t getGameTime();
+protected:
+    // ** Network Message Handlers
+    static void netMessageSetView(const NetMessage* message);
+    static void netMessageViewControl(const  NetMessage* message);
+    static void netMessageClientGameSetup(const NetMessage* message);
+    static void netMessagePingRequest(const NetMessage* message);
+    static void netMessagePingAcknowledge(const NetMessage* message);
+    static void netMessageConnectAlert(const NetMessage* message);
+    static void netMessageResetGameLogic(const NetMessage* message);
 };
 
 #endif

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/InfoSocket.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/InfoSocket.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/InfoSocket.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,8 +16,9 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Interfaces/BaseGameManager.hpp&quot;
 
-
 #include &quot;InfoSocket.hpp&quot;
 #include &quot;Util/StringTokenizer.hpp&quot;
 
@@ -131,7 +132,7 @@
 
     s &lt;&lt; &quot;\\gamestyle\\&quot; &lt;&lt; gameconfig-&gt;getGameTypeString()
       &lt;&lt; &quot;\\units_per_player\\&quot; &lt;&lt; gameconfig-&gt;GetUnitsPerPlayer()
-      &lt;&lt; &quot;\\time\\&quot; &lt;&lt; GameManager::getGameTime()/60
+      &lt;&lt; &quot;\\time\\&quot; &lt;&lt; global_engine_state-&gt;game_manager-&gt;getGameTime()/60
       &lt;&lt; &quot;\\timelimit\\&quot; &lt;&lt; gameconfig-&gt;timelimit
       &lt;&lt; &quot;\\fraglimit\\&quot; &lt;&lt; gameconfig-&gt;fraglimit
       &lt;&lt; &quot;\\objectivelimit\\&quot; &lt;&lt; ObjectiveInterface::getObjectiveLimit();

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,16 +17,13 @@
 */
 
 #include &quot;Interfaces/MapInterface.hpp&quot;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
+#include &quot;Core/GlobalGameState.hpp&quot;
+#include &quot;Classes/SpawnList.hpp&quot;
+#include &lt;cstdlib&gt;
+#include &lt;cstring&gt;
+#include &lt;cstdio&gt;
 
-#include &quot;SDL_endian.h&quot;
 
-#include &quot;Port/MapData.hpp&quot;
-
-WorldMap MapInterface::main_map;
-SpawnList MapInterface::spawn_list;
 char MapInterface::map_path[256];
 MapInterface::MapListenerList MapInterface::listenerList;
 
@@ -39,20 +36,34 @@
 
     strcpy( path, file_path );
     strcat( path, &quot;.npm&quot; );
-    main_map.loadMapFile( path );
 
+    WorldMap * map = new WorldMap();
+    map-&gt;loadMapFile( path );
+    if ( global_game_state-&gt;world_map )
+    {
+        delete global_game_state-&gt;world_map;
+    }
+    global_game_state-&gt;world_map = map;
+
     strcpy( tile_set_path, &quot;tilesets/&quot; );
-    strcat( tile_set_path, main_map.getAssocTileSet() );
+    strcat( tile_set_path, global_game_state-&gt;world_map-&gt;getAssocTileSet() );
 
+    TileSet * ts = new TileSet();
     if ( load_tiles == true )
     {
-        tile_set.loadTileSet(tile_set_path);
+        ts-&gt;loadTileSet(tile_set_path);
     }
     else
     {
-        tile_set.loadTileSetInfo(tile_set_path);
+        ts-&gt;loadTileSetInfo(tile_set_path);
     }
 
+    if ( global_game_state-&gt;tile_set )
+    {
+        delete global_game_state-&gt;tile_set;
+    }
+    global_game_state-&gt;tile_set = ts;
+
     finishMapLoad();
     return true;
 }
@@ -61,17 +72,23 @@
 {
     char path[256];
 
+    strcpy( path, map_path );
+    strcat( path, &quot;.spn&quot; );
+
+    SpawnList * sl = new SpawnList();
+    sl-&gt;loadSpawnFile(path);
+    if ( global_game_state-&gt;spawn_list )
+    {
+        delete global_game_state-&gt;spawn_list;
+    }
+    global_game_state-&gt;spawn_list = sl;
+
     MapListenerList::iterator i = listenerList.begin();
     while ( i != listenerList.end() )
     {
         (*i)-&gt;onMapLoadedEvent();
         i++;
     }
-    
-    strcpy( path, map_path );
-
-    strcat( path, &quot;.spn&quot; );
-    spawn_list.loadSpawnFile( path );
 }
 
 unsigned char MapInterface::getMovementValue( iXY map_loc )
@@ -79,11 +96,11 @@
     unsigned short tile_val;
     char move_val;
 
-    if (      (map_loc.x &gt;= 0) &amp;&amp; ((size_t) map_loc.x &lt; main_map.getWidth() )
-              &amp;&amp; (map_loc.y &gt;= 0) &amp;&amp; ((size_t) map_loc.y &lt; main_map.getHeight() )
+    if (      (map_loc.x &gt;= 0) &amp;&amp; ((size_t) map_loc.x &lt; global_game_state-&gt;world_map-&gt;getWidth() )
+              &amp;&amp; (map_loc.y &gt;= 0) &amp;&amp; ((size_t) map_loc.y &lt; global_game_state-&gt;world_map-&gt;getHeight() )
        ) {
-        tile_val = main_map.getValue( (unsigned short) map_loc.x, (unsigned short) map_loc.y ) ;
-        move_val = tile_set.getTileMovementValue( tile_val );
+        tile_val = global_game_state-&gt;world_map-&gt;getValue( (unsigned short) map_loc.x, (unsigned short) map_loc.y ) ;
+        move_val = global_game_state-&gt;tile_set-&gt;getTileMovementValue( tile_val );
 
         switch( move_val ) {
         case 0 :
@@ -111,20 +128,3 @@
     }
 
 }
-
-const SDL_Color * MapInterface::getAverageColorPointXY( iXY &amp;point_loc )
-{
-    WorldMap::MapElementType map_value =
-        main_map.getValue(point_loc.x/32, point_loc.y/32);
-
-    return( tile_set.getAverageTileColor( map_value ) );
-}
-
-const SDL_Color * MapInterface::getAverageColorMapXY( iXY &amp;map_loc )
-{
-    unsigned short map_value;
-
-    map_value = main_map.getValue( map_loc.x, map_loc.y );
-
-    return( tile_set.getAverageTileColor( map_value ) );
-}

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/MapInterface.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -22,14 +22,14 @@
 
 #include &quot;TileInterface.hpp&quot;
 #include &quot;Classes/WorldMap.hpp&quot;
-#include &quot;Classes/SpawnList.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 struct SDL_Color;
 
 class MapEventListener
 {
 public:
-    virtual ~MapEventListener() {};
+    virtual ~MapEventListener() {}
 protected:
     virtual void onMapLoadedEvent() = 0;
 private:
@@ -39,18 +39,11 @@
 
 class MapInterface : protected TileInterface
 {
-private:
-    typedef std::list&lt;MapEventListener *&gt; MapListenerList;
-    static MapListenerList listenerList;
-    
-protected:
-    static WorldMap main_map;
-    static SpawnList spawn_list;
-    static char map_path[256];
-    static const int TILE_WIDTH = 32;
-    static const int TILE_HEIGHT = 32;
-
 public:
+    static bool loadMap(const char *file_path, bool load_tiles);
+
+    static unsigned char getMovementValue( iXY map_loc );
+
     static void addMapEventListener(MapEventListener *lis)
     {
         listenerList.push_back(lis);
@@ -63,173 +56,71 @@
     
     static void getMapPointSize(iXY *map_size)
     {
-        map_size-&gt;x = main_map.getWidth() * tile_set.getTileXsize();
-        map_size-&gt;y = main_map.getHeight() * tile_set.getTileYsize();
+        map_size-&gt;x = global_game_state-&gt;world_map-&gt;getWidth() * global_game_state-&gt;tile_set-&gt;getTileXsize();
+        map_size-&gt;y = global_game_state-&gt;world_map-&gt;getHeight() * global_game_state-&gt;tile_set-&gt;getTileYsize();
     }
 
     static iXY getSize()
     {
-        return iXY(main_map.getWidth(), main_map.getHeight());
+        return iXY(global_game_state-&gt;world_map-&gt;getWidth(), global_game_state-&gt;world_map-&gt;getHeight());
     }
 
-    static size_t getWidth()
-    {
-        return main_map.getWidth();
-    }
-
-    static size_t getHeight()
-    {
-        return main_map.getHeight();
-    }
-
     static WorldMap::MapElementType MapValue(size_t x, size_t y)
     {
-        return main_map.getValue(x, y);
+        return global_game_state-&gt;world_map-&gt;getValue(x, y);
     }
 
-    static WorldMap::MapElementType MapValue(size_t offset)
-    {
-        return main_map.getValue(offset);
-    }
-
-    static void offsetToPointXY(size_t offset, size_t* point_x, size_t *point_y )
-    {
-        *point_y = ( offset  /  main_map.getWidth() );
-
-        *point_x = ( offset - ( (*point_y) * main_map.getWidth() ) ) * TILE_WIDTH
-                   + (TILE_WIDTH / 2);
-
-        *point_y = (*point_y) * TILE_HEIGHT + (TILE_HEIGHT / 2);
-    }
-
-    static void offsetToMapXY(size_t offset, size_t&amp; x, size_t&amp; y)
-    {
-        y = offset / main_map.getWidth();
-        x = offset - y * main_map.getWidth();
-    }
-
-    static void offsetToMapXY(size_t offset, iXY *map_loc)
-    {
-        size_t map_x, map_y;
-        offsetToMapXY(offset, map_x, map_y);
-        map_loc-&gt;x = map_x;
-        map_loc-&gt;y = map_y;
-    }
-
     static void mapXYtoPointXY(unsigned short map_x, unsigned short map_y,
                                size_t *point_x, size_t *point_y )
     {
-        iXY loc = mapXYtoPointXY(iXY(map_x, map_y));
-        *point_x = loc.x;
-        *point_y = loc.y;
+        *point_x = (map_x * TILE_WIDTH) + (TILE_WIDTH / 2);
+        *point_y = (map_y * TILE_HEIGHT) + (TILE_HEIGHT / 2);
     }
 
-    static void mapXYtoPointXY(iXY map_loc, iXY *loc)
+    static void mapXYtoPointXY(const iXY&amp; map_loc, iXY *loc)
     {
-        *loc = mapXYtoPointXY(map_loc);
+        loc-&gt;x = (map_loc.x * TILE_WIDTH) + (TILE_WIDTH / 2);
+        loc-&gt;y = (map_loc.y * TILE_HEIGHT) + (TILE_HEIGHT / 2);
     }
 
-    static iXY mapXYtoPointXY(iXY map_loc)
-    {
-#ifdef DEBUG
-        assert(inside(map_loc));
-#endif
-        return iXY((map_loc.x * TILE_WIDTH) + (TILE_WIDTH / 2),
-                (map_loc.y * TILE_HEIGHT) + (TILE_HEIGHT / 2));
-    }
-
     static void pointXYtoMapXY(size_t point_x, size_t point_y,
             unsigned short *map_x, unsigned short *map_y )
     {
-        iXY mapxy = pointXYtoMapXY(iXY(point_x, point_y));
-        *map_x = mapxy.x;
-        *map_y = mapxy.y;
+        *map_x = point_x / TILE_WIDTH;
+        *map_y = point_y / TILE_HEIGHT;
     }
 
     static void pointXYtoMapXY(const iXY&amp; point, iXY *map_loc)
     {
-        *map_loc = pointXYtoMapXY(point);
+        map_loc-&gt;x = point.x / TILE_WIDTH;
+        map_loc-&gt;y = point.y / TILE_HEIGHT;
     }
 
-    static iXY pointXYtoMapXY(const iXY&amp; point)
-    {
-#ifdef DEBUG
-        assert(point.x &gt;= 0 &amp;&amp; point.x &gt;= 0 
-                &amp;&amp; point.x &lt; (int) (getWidth() * TILE_WIDTH)
-                &amp;&amp; point.y &lt; (int) (getHeight() * TILE_HEIGHT));
-#endif
-        return iXY(point.x / TILE_WIDTH, point.y / TILE_HEIGHT);
-    }
-
     static size_t mapXYtoOffset(size_t map_x, size_t map_y)
     {
-        return mapXYtoOffset(iXY(map_x, map_y));
+        return (map_y * global_game_state-&gt;world_map-&gt;getWidth()) + map_x;
     }
 
     static size_t mapXYtoOffset(const iXY&amp; map_loc)
     {
-        return map_loc.y * main_map.getWidth() + map_loc.x;
+        return mapXYtoOffset(map_loc.x, map_loc.y);
     }
 
-    static void markLocHack(const iXY&amp; loc)
+    static void offsetToMapXY(size_t offset, iXY *map_loc)
     {
-        main_map.setMapValue(loc.x, loc.y, 27);
+        map_loc-&gt;y = offset/global_game_state-&gt;world_map-&gt;getWidth();
+        map_loc-&gt;x = offset - (map_loc-&gt;y * global_game_state-&gt;world_map-&gt;getWidth());
     }
 
-    static void unmarkLocHack(const iXY&amp; loc)
-    {
-        main_map.setMapValue(loc.x, loc.y, 28);
-    }
-
-    static void normalizePointXY(size_t point_x, size_t point_y, size_t *norm_x, size_t *norm_y)
-    {
-        unsigned short map_x, map_y;
-
-        pointXYtoMapXY( point_x, point_y, &amp;map_x, &amp;map_y );
-        mapXYtoPointXY( map_x, map_y, norm_x, norm_y );
-    }
-
-    static WorldMap* getMap()
-    {
-        return( &amp;main_map );
-    }
-
-    static bool inside(const iXY&amp; map_loc)
-    {
-        if(map_loc.x &lt; 0 || map_loc.y &lt; 0
-                || map_loc.x &gt;= (int) getWidth() 
-                || map_loc.y &gt;= (int) getHeight())
-            return false;
-
-        return true;
-    }
-
 protected:
-    static void finishMapLoad();
+    typedef std::list&lt;MapEventListener *&gt; MapListenerList;
+    static MapListenerList listenerList;
 
-public:
-    static bool loadMap(const char *file_path, bool load_tiles);
+    static char map_path[256];
+    static const int TILE_WIDTH = 32;
+    static const int TILE_HEIGHT = 32;
 
-    static bool isMapLoaded()
-    {
-        return( main_map.isMapLoaded() );
-    }
-
-    static unsigned char getMovementValue( iXY map_loc );
-
-    static const SDL_Color * getAverageColorPointXY( iXY &amp;point_loc );
-
-    static const SDL_Color * getAverageColorMapXY( iXY &amp;map_loc );
-
-    static iXY getFreeSpawnPoint()
-    {
-        return spawn_list.getFreeSpawnPoint();
-    }
-
-    static SpawnList* getSpawnList()
-    {
-        return &amp;spawn_list;
-    }
+    static void finishMapLoad();
 };
 
 #endif

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PathScheduler.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -23,6 +23,7 @@
 #include &quot;Util/Log.hpp&quot;
 #include &quot;PathScheduler.hpp&quot;
 #include &quot;Classes/AI/PathingState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 void PathCache::initialize( void )
 {
@@ -373,11 +374,11 @@
 
 void PathScheduler::initialize()
 {
-    if( MapInterface::isMapLoaded() == true ) {
+    if( global_game_state-&gt;world_map ) {
         unsigned long resources;
         size_t path_list_size;
-        float map_x_size = MapInterface::getWidth();
-        float map_y_size = MapInterface::getHeight();
+        float map_x_size = global_game_state-&gt;world_map-&gt;getWidth();
+        float map_y_size = global_game_state-&gt;world_map-&gt;getHeight();
         float map_size = (map_x_size * map_y_size);
 
         resources = (unsigned long) ( (map_size * 0.019018) + 4018.0 );

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -18,6 +18,7 @@
 
 
 #include &lt;exception&gt;
+#include &quot;Core/GlobalEngineState.hpp&quot;
 
 #include &quot;Interfaces/PlayerGameManager.hpp&quot;
 #include &quot;Interfaces/BaseGameManager.hpp&quot;
@@ -42,7 +43,6 @@
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
 
 #include &quot;Classes/ScreenSurface.hpp&quot;
-#include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Classes/WorldInputCmdProcessor.hpp&quot;
 #include &quot;Classes/SpriteSorter.hpp&quot;
 #include &quot;Classes/Network/ClientConnectDaemon.hpp&quot;
@@ -129,29 +129,37 @@
     Screen = 0;
 }
 //-----------------------------------------------------------------
-void PlayerGameManager::initializeSoundSubSystem()
+Sound * PlayerGameManager::initializeSoundSubSystem()
 {
-    delete sound;
-    sound = 0;
+    Sound * s = 0;
     
     LOGGER.info(&quot;Initializing sound system.&quot;);
-    try {
-        if(gameconfig-&gt;enablesound)
-            sound = new SDLSound();
-    } catch(std::exception&amp; e) {
+    try
+    {
+        if ( gameconfig-&gt;enablesound )
+        {
+            s = new SDLSound();
+        }
+    }
+    catch(std::exception&amp; e)
+    {
         LOGGER.warning(&quot;Couldn't initialize sound: %s&quot;, e.what());
     }
 
-    if(sound == 0)
-        sound = new DummySound();
+    if ( s == 0 )
+    {
+        s = new DummySound();
+    }
 
-    sound-&gt;setSoundVolume(gameconfig-&gt;effectsvolume);
+    s-&gt;setSoundVolume(gameconfig-&gt;effectsvolume);
 
     // start some music
-    if(gameconfig-&gt;enablemusic) {
-        sound-&gt;playMusic(&quot;sound/music/&quot;);
-        sound-&gt;setMusicVolume(gameconfig-&gt;musicvolume);
+    if ( gameconfig-&gt;enablemusic )
+    {
+        s-&gt;setMusicVolume(gameconfig-&gt;musicvolume);
+        s-&gt;playMusic(&quot;sound/music/&quot;);
     }
+    return s;
 }
 //-----------------------------------------------------------------
 void PlayerGameManager::initializeInputDevices()
@@ -161,13 +169,13 @@
 //-----------------------------------------------------------------
 void PlayerGameManager::initializeWindowSubSystem()
 {
-    Palette::setColors();
-    Desktop::add(new GameView());
-    Desktop::add(new RankView());
-    Desktop::add(new VehicleSelectionView());
-    Desktop::add(new MiniMapView() );
-    Desktop::add(new CodeStatsView());
-    Desktop::add(new LibView());
+    Desktop::add(new GameView(), false); // all of this should be loaded when game starts
+    Desktop::add(new RankView(), false);
+    Desktop::add(new VehicleSelectionView(), false); // depends on unit profiles loaded
+    Desktop::add(new MiniMapView(), false); // depends on map manager
+    Desktop::add(new CodeStatsView(), false);
+    Desktop::add(new LibView(), false);
+
     Desktop::add(new HelpScrollView());
 
     Desktop::add(new LoadingView());
@@ -199,10 +207,6 @@
 
     Desktop::checkResolution(iXY(640,480), iXY(screen-&gt;getWidth(),screen-&gt;getHeight()));
     Desktop::checkViewPositions(iXY(screen-&gt;getWidth(),screen-&gt;getHeight()));
-
-
-    //Test for new UI
-    //testpanel = new Panels::TestPanel(iXY(30, 60), &amp;fontManager);
 }
 //-----------------------------------------------------------------
 void PlayerGameManager::inputLoop()
@@ -259,7 +263,6 @@
 //-----------------------------------------------------------------
 void PlayerGameManager::hostMultiPlayerGame()
 {
-    PlayerState *player_state;
     Timer wait;
 
     LoadingView::show();
@@ -276,12 +279,15 @@
         {
             try
             {
-                if ( infosocket ) {
+                if ( infosocket )
+                {
                     delete infosocket;
                     infosocket = 0;
                 }
                 infosocket = new InfoSocket(gameconfig-&gt;serverport);
-                if ( heartbeat ) {
+
+                if ( heartbeat )
+                {
                     delete heartbeat;
                     heartbeat = 0;
                 }
@@ -290,11 +296,13 @@
             catch(std::exception&amp; e)
             {
                 LOGGER.warning(&quot;heartbeats disabled: %s&quot;, e.what());
-                if ( infosocket ) {
+                if ( infosocket )
+                {
                     delete infosocket;
                     infosocket = 0;
                 }
-                if ( heartbeat ) {
+                if ( heartbeat )
+                {
                     delete heartbeat;
                     heartbeat = 0;
                 }
@@ -316,78 +324,10 @@
     LoadingView::update( &quot;Launching Server ... (100%) &quot; );
     graphicsLoop();
 
-    GameControlRulesDaemon::setStateServerInProgress();
+//    GameControlRulesDaemon::setStateServerInProgress();
+    GameControlRulesDaemon::setStateServerLoadingMap();
     NetworkState::setNetworkStatus( _network_state_server );
 
-    LoadingView::append( &quot;Loading Game Data ...&quot; );
-    graphicsLoop();
-    
-    gameconfig-&gt;map = MapsManager::getNextMap(&quot;&quot;);
-    const char* mapname = gameconfig-&gt;map.c_str();
-
-    ObjectiveInterface::resetLogic();
-
-    try {
-        GameManager::loadGameMap(mapname);
-    } catch(std::exception&amp; e) {
-        LOGGER.warning(&quot;YError while loading map '%s':&quot;, mapname);
-        LOGGER.warning(e.what());
-        LoadingView::loadError();
-        return;
-    }
-
-    int percent_complete;
-    char strbuf[256];
-
-
-//    while( GameManager::gameMapLoad( &amp;percent_complete ) == true ) {
-//        sprintf( strbuf, &quot;Loading Game Data ... (%d%%)&quot;, percent_complete);
-//        LoadingView::update( strbuf );
-//        graphicsLoop();
-//    }
-
-    sprintf( strbuf, &quot;Loading Game Data ... (%d%%)&quot;, percent_complete);
-    LoadingView::update( strbuf );
-    graphicsLoop();
-
-
-    LoadingView::append( &quot;Initializing Game Logic ...&quot; );
-    graphicsLoop();
-    GameManager::reinitializeGameLogic();
-    LoadingView::update( &quot;Initializing Game Logic ... (100%) &quot; );
-    graphicsLoop();
-    
-    LoadingView::append( &quot;Spawning Player ...&quot; );
-    graphicsLoop();
-    
-    player_state = PlayerInterface::allocateLoopBackPlayer();
-    const char* playername = gameconfig-&gt;playername.c_str();
-    player_state-&gt;setName(playername);
-    ResourceManager::loadDefaultFlags();
-    Uint8 flagdata[20*14]; // XXX shouldn't use fixed values
-    ResourceManager::getFlagData(gameconfig-&gt;playerflag.c_str(), (Uint8 *)&amp;flagdata);
-    player_state-&gt;setFlag(ResourceManager::registerFlagFromData(flagdata));
-    
-    //GameManager::spawnPlayer( PlayerInterface::getLocalPlayerIndex() );
-    
-    LoadingView::update( &quot;Spawning Player ... (100%)&quot; );
-    
-    graphicsLoop();
-
-    wait.changePeriod( 3 );
-    //while( !wait.count() );
-
-    GameManager::startGameTimer();
-
-    LoadingView::hide();
-
-    GameManager::setNetPanzerGameOptions();
-
-    // Need to open at beginning of game until we are saving status of things.
-    // when last played.
-    Desktop::setVisibility(&quot;MiniMapView&quot;, true);
-    Desktop::setVisibility(&quot;GameView&quot;, true);
-    Desktop::setActiveView(&quot;GameView&quot;);
 }
 
 void PlayerGameManager::quitGame()
@@ -406,15 +346,16 @@
 void PlayerGameManager::joinMultiPlayerGame()
 {
     GameManager::setNetPanzerGameOptions();
-    //reinitializeGameLogic();
+    //global_engine_state-&gt;game_manager-&gt;reinitializeGameLogic();
     NetworkState::setNetworkStatus( _network_state_client );
 
-    MessageRouter::initialize(false);
-    NetworkClient::joinServer(gameconfig-&gt;serverConnect);
-    LoadingView::show();
+//    MessageRouter::initialize(false);
+//    NetworkClient::joinServer(gameconfig-&gt;serverConnect);
+//    LoadingView::show();
 
-    ClientConnectDaemon::startConnectionProcess();
-    sound-&gt;playTankIdle();
+//    ClientConnectDaemon::startConnectionProcess();
+    GameControlRulesDaemon::setStateClientConnectToServer(gameconfig-&gt;serverConnect);
+    global_engine_state-&gt;sound_manager-&gt;playTankIdle();
 }
 
 bool PlayerGameManager::mainLoop()
@@ -461,19 +402,18 @@
         Desktop::toggleVisibility( &quot;DesktopView&quot; );
     }
 
-
-    if (Desktop::getView(&quot;GameView&quot;)-&gt;getVisible())
+    if ( Desktop::getVisible(&quot;GameView&quot;) )
     {
         if (KeyboardInterface::getKeyPressed(SDLK_m))
         {
             Desktop::toggleVisibility( &quot;MiniMapView&quot; );
         }
-        
+
         if (KeyboardInterface::getKeyPressed(SDLK_TAB) )
         {
             Desktop::toggleVisibility( &quot;RankView&quot; );
         }
-                
+
         if (KeyboardInterface::getKeyPressed(SDLK_F4))
         {
             Desktop::toggleVisibility( &quot;CodeStatsView&quot; );
@@ -484,7 +424,7 @@
             //  DEBUG VIEW
             Desktop::toggleVisibility( &quot;LibView&quot; );
         }
-   
+
         if (KeyboardInterface::getKeyPressed(SDLK_F1))
         {
             Desktop::toggleVisibility( &quot;HelpScrollView&quot; );
@@ -492,15 +432,15 @@
 
         if (KeyboardInterface::getKeyPressed(SDLK_ESCAPE))
         {
-            if (Desktop::getView(&quot;GameView&quot;)-&gt;getVisible())
+            if ( Desktop::getVisible(&quot;GameView&quot;) )
             {
-                if (!Desktop::getView(&quot;OptionsView&quot;)-&gt;getVisible() &amp;&amp;
-                        !Desktop::getView(&quot;SoundView&quot;)-&gt;getVisible() &amp;&amp;
-                        !Desktop::getView(&quot;ControlsView&quot;)-&gt;getVisible() &amp;&amp;
-                        !Desktop::getView(&quot;InterfaceView&quot;)-&gt;getVisible() &amp;&amp;
-                        !Desktop::getView(&quot;VisualsView&quot;)-&gt;getVisible())
+                if (   !Desktop::getVisible(&quot;OptionsView&quot;)
+                    &amp;&amp; !Desktop::getVisible(&quot;SoundView&quot;)
+                    &amp;&amp; !Desktop::getVisible(&quot;ControlsView&quot;)
+                    &amp;&amp; !Desktop::getVisible(&quot;InterfaceView&quot;)
+                    &amp;&amp; !Desktop::getVisible(&quot;VisualsView&quot;) )
                 {
-                    
+
                     View *v = Desktop::getView(&quot;OptionsView&quot;);
                     assert(v != 0);
                     ((OptionsTemplateView *)v)-&gt;initButtons();

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerGameManager.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -37,7 +37,7 @@
     virtual void initializeVideoSubSystem();
     virtual void shutdownVideoSubSystem();
 
-    virtual void initializeSoundSubSystem();
+    virtual Sound * initializeSoundSubSystem();
 
     virtual void shutdownNetworkSubSystem();
 

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/PlayerInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,7 @@
 */
 
 #include &lt;stdexcept&gt;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
@@ -260,7 +261,7 @@
         SDL_mutexP(mutex);
         if ( player_lists[player_index].getStatus() != _player_state_free )
         {
-            UnitInterface::spawnPlayerUnits( location,
+            global_game_state-&gt;unit_manager-&gt;spawnPlayerUnits( location,
                                              player_index,
                                              player_lists[ player_index ].unit_config
                                            );
@@ -389,7 +390,7 @@
             || score_update-&gt;getKillOnPlayerIndex() 
             &gt;= PlayerInterface::getMaxPlayers())
     {
-        LOGGER.warning(&quot;Malformed scrore update packet.&quot;);
+        LOGGER.warning(&quot;Malformed score update packet.&quot;);
         return;
     }
 
@@ -400,10 +401,10 @@
 
 void PlayerInterface::netMessageAllianceRequest(const NetMessage *message)
 {
-	if ( gameconfig-&gt;allowallies == false )
-	{
-		return;
-	}
+    if ( gameconfig-&gt;allowallies == false )
+    {
+        return;
+    }
 	
     PlayerState *player_state;
 
@@ -411,83 +412,92 @@
         = (const PlayerAllianceRequest *) message;
 
     if(allie_request-&gt;getAllieByPlayerIndex() &gt;= max_players
-       || allie_request-&gt;getAllieWithPlayerIndex() &gt;= max_players) {
+       || allie_request-&gt;getAllieWithPlayerIndex() &gt;= max_players)
+    {
         LOGGER.warning(&quot;Invalid alliance request message&quot;);
         return;                                                       
     }
 
     SDL_mutexP(mutex);
     if ( allie_request-&gt;alliance_request_type == _player_make_alliance )
-	{
-		setAlliance(  allie_request-&gt;getAllieByPlayerIndex(),
-					  allie_request-&gt;getAllieWithPlayerIndex());
+    {
+        setAlliance(allie_request-&gt;getAllieByPlayerIndex(),
+                    allie_request-&gt;getAllieWithPlayerIndex());
 
         if ( allie_request-&gt;getAllieByPlayerIndex() == local_player_index )
-		{
-            player_state = getPlayer( allie_request-&gt;getAllieWithPlayerIndex() );
-			if ( isSingleAllied( player_state-&gt;getID(), local_player_index) )
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;You accepted %s alliance request.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
-			else
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;You request alliance with %s.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
+        {
+            player_state = getPlayer(allie_request-&gt;getAllieWithPlayerIndex());
+            if ( isSingleAllied( player_state-&gt;getID(), local_player_index) )
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;You accepted %s alliance request.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
+            else
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;You request alliance with %s.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
         }
-		else if ( allie_request-&gt;getAllieWithPlayerIndex() == local_player_index )
-		{
-			player_state = getPlayer( allie_request-&gt;getAllieByPlayerIndex() );
-			if ( isSingleAllied( local_player_index, player_state-&gt;getID()) )
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;%s accepted your alliance request.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
-			else
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;%s request to ally with you.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
+        else if ( allie_request-&gt;getAllieWithPlayerIndex() == local_player_index )
+        {
+            player_state = getPlayer( allie_request-&gt;getAllieByPlayerIndex() );
+            if ( isSingleAllied( local_player_index, player_state-&gt;getID()) )
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                           &quot;%s accepted your alliance request.&quot;,
+                                           player_state-&gt;getName().c_str());
+            }
+            else
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;%s request to ally with you.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
         }
     }
-	else
-	{
-		// break alliance cancels both alliances
+    else
+    {
+        // break alliance cancels both alliances
         clearAlliance( allie_request-&gt;getAllieByPlayerIndex(),
                        allie_request-&gt;getAllieWithPlayerIndex());
 
         if ( allie_request-&gt;getAllieByPlayerIndex() == local_player_index )
-		{
+        {
             player_state = getPlayer( allie_request-&gt;getAllieWithPlayerIndex() );
-			if ( isSingleAllied( player_state-&gt;getID(), local_player_index) )
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;You broke the alliance with %s.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
-			else
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;You cancel your alliance request with %s.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
+            if ( isSingleAllied( player_state-&gt;getID(), local_player_index) )
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;You broke the alliance with %s.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
+            else
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;You cancel your alliance request with %s.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
         }
-		else if ( allie_request-&gt;getAllieWithPlayerIndex() == local_player_index )
-		{
-			player_state = getPlayer( allie_request-&gt;getAllieByPlayerIndex() );
-			if ( isSingleAllied( local_player_index, player_state-&gt;getID()) )
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;%s broke the alliance with you.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
-			else
-			{
-				ConsoleInterface::postMessage( Color::yellow, false, 0, &quot;%s cancelled the alliance request with you.&quot;,
-												player_state-&gt;getName().c_str() );
-			}
-		}
-		
-		clearAlliance( allie_request-&gt;getAllieWithPlayerIndex(),
-						allie_request-&gt;getAllieByPlayerIndex());
+        else if ( allie_request-&gt;getAllieWithPlayerIndex() == local_player_index )
+        {
+            player_state = getPlayer( allie_request-&gt;getAllieByPlayerIndex() );
+            if ( isSingleAllied( local_player_index, player_state-&gt;getID()) )
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;%s broke the alliance with you.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
+            else
+            {
+                ConsoleInterface::postMessage(Color::yellow, false, 0,
+                                              &quot;%s cancelled the alliance request with you.&quot;,
+                                              player_state-&gt;getName().c_str());
+            }
+        }
+
+        clearAlliance(allie_request-&gt;getAllieWithPlayerIndex(),
+                      allie_request-&gt;getAllieByPlayerIndex());
     }
     SDL_mutexV(mutex);
 
@@ -496,14 +506,16 @@
                      allie_request-&gt;getAllieWithPlayerIndex(),
                      allie_request-&gt;alliance_request_type);
     //NetworkServer::broadcastMessage(&amp;allie_update, sizeof(PlayerAllianceUpdate));
-	if ( allie_request-&gt;getAllieByPlayerIndex() != local_player_index )
-	{
-		NetworkServer::sendMessage( allie_request-&gt;getAllieByPlayerIndex(), &amp;allie_update, sizeof(PlayerAllianceUpdate) );
-	}
-	if ( allie_request-&gt;getAllieWithPlayerIndex() != local_player_index )
-	{
-		NetworkServer::sendMessage( allie_request-&gt;getAllieWithPlayerIndex(), &amp;allie_update, sizeof(PlayerAllianceUpdate) );
-	}
+    if ( allie_request-&gt;getAllieByPlayerIndex() != local_player_index )
+    {
+        NetworkServer::sendMessage(allie_request-&gt;getAllieByPlayerIndex(),
+                                   &amp;allie_update, sizeof(PlayerAllianceUpdate));
+    }
+    if ( allie_request-&gt;getAllieWithPlayerIndex() != local_player_index )
+    {
+        NetworkServer::sendMessage(allie_request-&gt;getAllieWithPlayerIndex(),
+                                   &amp;allie_update, sizeof(PlayerAllianceUpdate));
+    }
 }
 
 void PlayerInterface::netMessageAllianceUpdate(const NetMessage* message)

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -20,47 +20,18 @@
 #include &quot;Interfaces/MapInterface.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
 
-TileSet TileInterface::tile_set;
-
-void TileInterface::loadTileSet( const char *file_path )
-{
-    tile_set.loadTileSet( file_path );
-}
-
 iXY TileInterface::getTileSize( void )
 {
-    return( iXY( tile_set.getTileXsize(), tile_set.getTileYsize() ) );
+    return( iXY( global_game_state-&gt;tile_set-&gt;getTileXsize(), global_game_state-&gt;tile_set-&gt;getTileYsize() ) );
 }
 
-IntColor TileInterface::getWorldPixColor(int worldX, int worldY)
-{
-    int tileX = worldX / tile_set.getTileXsize();
-    int tileY = worldY / tile_set.getTileYsize();
-
-    int subPixX = worldX % tile_set.getTileXsize();
-    int subPixY = worldY % tile_set.getTileYsize();
-
-    if(tileX &gt;= (int) MapInterface::getWidth()
-            || tileY &gt;= (int) MapInterface::getHeight()
-            || tileX &lt; 0 || tileY &lt; 0 ) 
-    {
-        LOGGER.warning(&quot;query for worldpixcolor outside map (%d,%d)&quot;,
-                worldX, worldY);
-        return 0;
-    }
-
-    int tileValue = MapInterface::MapValue(tileX, tileY);
-
-    return tile_set.getTilePixel(tileValue, subPixX, subPixY);
-}
-
 long TileInterface::getWorldPixMovementValue(int worldX, int worldY)
 {
-    int tileX = worldX / tile_set.getTileXsize();
-    int tileY = worldY / tile_set.getTileYsize();
+    int tileX = worldX / global_game_state-&gt;tile_set-&gt;getTileXsize();
+    int tileY = worldY / global_game_state-&gt;tile_set-&gt;getTileYsize();
 
-    if(tileX &gt;= (int) MapInterface::getWidth()
-            || tileY &gt;= (int) MapInterface::getHeight()
+    if(tileX &gt;= (int) global_game_state-&gt;world_map-&gt;getWidth()
+            || tileY &gt;= (int) global_game_state-&gt;world_map-&gt;getHeight()
             || tileX &lt; 0 || tileY &lt; 0 ) 
     {
         LOGGER.warning(&quot;query for worldpixmovement outside map (%d,%d)&quot;,
@@ -69,5 +40,5 @@
     }                                                                               
     int tileValue = MapInterface::MapValue(tileX, tileY);
 
-    return tile_set.getTileMovementValue(tileValue);
+    return global_game_state-&gt;tile_set-&gt;getTileMovementValue(tileValue);
 }

Modified: trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Interfaces/TileInterface.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -25,20 +25,9 @@
 
 class TileInterface
 {
-protected:
-    static TileSet tile_set;
-
 public:
-    static void loadTileSet( const char *file_path );
-
-    static inline TileSet * getTileSet( void )
-    {
-        return ( &amp;tile_set );
-    }
-
     static iXY getTileSize( void );
 
-    static IntColor getWorldPixColor(int worldX, int worldY);
     static long getWorldPixMovementValue(int worldX, int worldY);
 };
 

Modified: trunk/netpanzer/src/NetPanzer/Network/ClientSocket.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Network/ClientSocket.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Network/ClientSocket.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -32,8 +32,8 @@
 class ClientSocketObserver
 {
 public:
-    ClientSocketObserver(){};
-    virtual ~ClientSocketObserver(){};
+    ClientSocketObserver(){}
+    virtual ~ClientSocketObserver(){}
 protected:
     friend class ClientSocket;
     virtual void onClientConnected(ClientSocket *cso) = 0;
@@ -51,7 +51,7 @@
     void sendRemaining();
     ProxyServer proxy;
 
-    int getId() { return id; };
+    int getId() { return id; }
     std::string getIPAddress();
     
     int getPlayerIndex()

Modified: trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Network/MessageRouter.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -21,8 +21,8 @@
 #include &lt;queue&gt;
 
 #include &quot;Resources/ResourceManager.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
-
 #include &quot;Interfaces/PlayerInterface.hpp&quot;
 
 
@@ -92,7 +92,7 @@
         switch ( p-&gt;getNetMessage()-&gt;message_id )
         {
             case _net_message_id_term_unit_cmd:
-                UnitInterface::processNetPacket(p);
+                global_game_state-&gt;unit_manager-&gt;processNetPacket(p);
                 break;
             case _net_message_id_term_unit_gen:
             case _net_message_id_term_output_loc:
@@ -110,7 +110,7 @@
 private:
     void (*func)(const NetMessage *);
 public:
-    ToMessageHandler(void (*f)(const NetMessage *)) : func(f) {};
+    ToMessageHandler(void (*f)(const NetMessage *)) : func(f) {}
     void handlePacket(const NetPacket *p)
     {
         func(p-&gt;getNetMessage());
@@ -122,19 +122,29 @@
 private:
     void (*func)(const NetPacket *);
 public:
-    ToPacketHandler(void (*f)(const NetPacket *)) : func(f) {};
+    ToPacketHandler(void (*f)(const NetPacket *)) : func(f) {}
     void handlePacket(const NetPacket *p)
     {
         func(p);
     }
 };
 
+class ToUnitHandler : public MessageClassHandler
+{
+public:
+    ToUnitHandler() {}
+    void handlePacket(const NetPacket *p)
+    {
+        global_game_state-&gt;unit_manager-&gt;processNetMessage(p-&gt;getNetMessage());
+    }
+};
+
 static ToMessageHandler systemhandler(&amp;GameManager::processSystemMessage);
 static ToPacketHandler serverconnecthandler(&amp;ServerConnectDaemon::processNetPacket);
 static ToMessageHandler clientconnecthandler(&amp;ClientConnectDaemon::processNetMessage);
 static ToMessageHandler resourcehandler(&amp;ResourceManager::processResourceMessage);
 static ToMessageHandler playerhandler(&amp;PlayerInterface::processNetMessage);
-static ToMessageHandler unithandler(&amp;UnitInterface::processNetMessage);
+static ToUnitHandler unithandler;
 static ToMessageHandler objectivehandler(&amp;ObjectiveInterface::processNetMessages);
 static ToMessageHandler gamecontrolhandler(GameControlRulesDaemon::processNetMessage);
 static ToMessageHandler poweruphandler(&amp;PowerUpInterface::processNetMessages);
@@ -203,7 +213,6 @@
     receive_queue.push( TEMP_PACKET );
 }
 
-
 void
 MessageRouter::routePackets()
 {
@@ -220,3 +229,21 @@
         handlers[np.getNetMessage()-&gt;message_class]-&gt;handlePacket(&amp;np);
     }
 }
+
+void
+MessageRouter::routePacket(const NetPacket&amp; np)
+{
+    handlers[np.getNetMessage()-&gt;message_class]-&gt;handlePacket(&amp;np);
+}
+
+bool
+MessageRouter::getNextPacket(NetPacket&amp; np)
+{
+    if ( ! receive_queue.empty() )
+    {
+        np = receive_queue.front();
+        receive_queue.pop();
+        return true;
+    }
+    return false;
+}

Modified: trunk/netpanzer/src/NetPanzer/Network/MessageRouter.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Network/MessageRouter.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Network/MessageRouter.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -25,12 +25,15 @@
 
 class MessageClassHandler;
 class ClientSocket;
+class NetPacket;
 
 class MessageRouter
 {
 public:
     static void initialize(bool isServer);
     static void routePackets();
+    static void routePacket(const NetPacket&amp; np);
+    static bool getNextPacket(NetPacket&amp; np);
     static void enqueueIncomingPacket( const void *data, Uint16 size,
                                    Uint16 fromPlayer, ClientSocket *fromClient);
     static void setMessageClassHandler(MsgClassID c, MessageClassHandler * h);

Modified: trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Objectives/ObjectiveInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -146,11 +146,11 @@
             std::stringstream ss(location);
             ss &gt;&gt; loc_x &gt;&gt; loc_y;
             
-            LOGGER.warning(&quot;\t%s in %d,%d&quot;, name.c_str(), loc_x, loc_y);
+            LOGGER.warning(&quot;\t%s in %lu,%lu&quot;, name.c_str(), (unsigned long)loc_x, (unsigned long)loc_y);
 
             MapInterface::mapXYtoPointXY( loc_x, loc_y, &amp;world_x, &amp;world_y );
 
-            LOGGER.warning(&quot;\t\tin world %d,%d&quot;, world_x, world_y);
+            LOGGER.warning(&quot;\t\tin world %lu,%lu&quot;, (unsigned long)world_x, (unsigned long)world_y);
 
             objective_obj = new Outpost(objective_index, iXY(world_x, world_y),
                     BoundBox( -48, -32, 48, 32 )

Modified: trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Objectives/Outpost.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,7 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;Classes/PlayerState.hpp&quot;
 #include &quot;Outpost.hpp&quot;
 
@@ -128,7 +128,7 @@
         if ( objective_state.occupation_status == _occupation_status_occupied )
         {
             std::vector&lt;UnitID&gt; playerunits;
-            UnitInterface::queryPlayerUnitsInWorldRect(playerunits,
+            global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryPlayerUnitsInWorldRect(playerunits,
                                     bounding_area,
                                     objective_state.occupying_player-&gt;getID() );
 
@@ -137,17 +137,19 @@
                 return;
             }
 
-            UnitInterface::queryNonPlayerUnitsInWorldRect(unitsInArea,
+            global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryNonPlayerUnitsInWorldRect(unitsInArea,
                                     bounding_area,
                                     objective_state.occupying_player-&gt;getID() );
 
         }
         else
         {
-            UnitInterface::queryUnitsInWorldRect( unitsInArea, bounding_area );  
+            if ( global_game_state-&gt;unit_manager )
+            {
+                global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitsInWorldRect( unitsInArea, bounding_area );
+            }
         }
 
-
         if ( ! unitsInArea.empty() )
         {
             std::vector&lt;Unit*&gt;::iterator i = unitsInArea.begin();
@@ -184,7 +186,7 @@
                 iXY gen_loc;
                 gen_loc = outpost_map_loc + unit_generation_loc;
 
-                unit = UnitInterface::createUnit(unit_generation_type,
+                unit = global_game_state-&gt;unit_manager-&gt;createUnit(unit_generation_type,
                         gen_loc, objective_state.occupying_player-&gt;getID());
 
                 if ( unit != 0 )
@@ -205,7 +207,7 @@
 
                     ai_command.setHeader( unit-&gt;id);
                     ai_command.setMoveToLoc( loc );
-                    UnitInterface::sendMessage( &amp;ai_command );
+                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;ai_command );
                 }
             } // ** if
         } // ** if
@@ -255,7 +257,7 @@
     unit_generation_type = unit_gen_mesg-&gt;unit_type;
     unit_generation_on_flag = unit_gen_mesg-&gt;unit_gen_on;
 
-    profile = UnitProfileInterface::getUnitProfile( unit_generation_type );
+    profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile( unit_generation_type );
     unit_generation_timer.changePeriod( (float) profile-&gt;regen_time );
 }
 
@@ -282,7 +284,7 @@
 
             unit_generation_type = 0;
             UnitProfile *profile
-                = UnitProfileInterface::getUnitProfile( unit_generation_type );
+                = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile( unit_generation_type );
             unit_generation_timer.changePeriod( (float) profile-&gt;regen_time );
             unit_generation_on_flag = false;
         }
@@ -298,7 +300,7 @@
     status.unit_generation_on_off = unit_generation_on_flag;
     status.unit_collection_loc = unit_collection_loc;
 
-    profile = UnitProfileInterface::getUnitProfile( unit_generation_type );
+    profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile( unit_generation_type );
     if ( profile )
         status.unit_generation_time = (float) profile-&gt;regen_time;
     else
@@ -330,7 +332,7 @@
     unit_generation_on_flag = occupation_update-&gt;unit_gen_on;
     unit_generation_type = occupation_update-&gt;unit_type;
     
-    UnitProfile* profile = UnitProfileInterface::getUnitProfile( unit_generation_type );
+    UnitProfile* profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile( unit_generation_type );
     
     unit_generation_timer.changePeriod((float)profile-&gt;regen_time);
     unit_generation_timer.setTimeLeft(

Modified: trunk/netpanzer/src/NetPanzer/Particles/ChunkTrajectoryParticle2D.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Particles/ChunkTrajectoryParticle2D.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Particles/ChunkTrajectoryParticle2D.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -61,8 +61,6 @@
 
     ChunkTrajectoryParticle2D::particleType = particleType;
 
-    //TileInterface::getWorldPixColor(int worldX, int worldY)
-
     // int randChunk = rand() % staticPackedGroundChunks.getFrameCount();
 
     packedSurface.setData(staticPackedGroundChunks);
@@ -74,7 +72,7 @@
         index = 253;
 
     } else {
-        index = TileInterface::getWorldPixColor((int) pos.x, (int) pos.z);
+        index = rand() % staticPackedGroundChunks.getNumFrames();
     }
 
     //int randFrame = rand() % staticPackedChunks[randChunk].getFrameCount();

Modified: trunk/netpanzer/src/NetPanzer/Particles/ParticleInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Particles/ParticleInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Particles/ParticleInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,8 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;Particles/ParticleInterface.hpp&quot;
 #include &quot;PuffParticle2D.hpp&quot;
 #include &quot;FlameParticle2D.hpp&quot;
@@ -121,7 +122,7 @@
         groupTime0 = 0.0f;
 
         //SFX
-        sound-&gt;playSound(&quot;expl&quot;);
+        global_engine_state-&gt;sound_manager-&gt;playSound(&quot;expl&quot;);
 
         iRect gameViewRect;
         WorldViewInterface::getViewWindow(&amp;gameViewRect);
@@ -132,7 +133,7 @@
         unitState.location.y = gameViewRect.min.y + 100 + (rand() % (gameViewRect.getSizeY() - 200));
 
         // Hack until all the units are actually used.
-        unitState.unit_type = rand() % UnitProfileInterface::getNumUnitTypes();
+        unitState.unit_type = rand() % global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes();
         //unitState.unit_type = rand() % 7;
 
         addHit(unitState);
@@ -142,7 +143,7 @@
         groupTime1 = 0.0f;
 
         //SFX
-        sound-&gt;playSound(&quot;expl&quot;);
+        global_engine_state-&gt;sound_manager-&gt;playSound(&quot;expl&quot;);
 
         iRect gameViewRect;
         WorldViewInterface::getViewWindow(&amp;gameViewRect);
@@ -152,7 +153,7 @@
         location.x = gameViewRect.min.x + 100 + (rand() % (gameViewRect.getSizeX() - 200));
         location.y = gameViewRect.min.y + 100 + (rand() % (gameViewRect.getSizeY() - 200));
 
-        addMiss(location, rand() % UnitProfileInterface::getNumUnitTypes());
+        addMiss(location, rand() % global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes());
     }
 }
 
@@ -192,7 +193,7 @@
 
     float hitPointScale = 1.0f;
 
-    UnitProfile *p = UnitProfileInterface::getUnitProfile(unitState.unit_type);
+    UnitProfile *p = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unitState.unit_type);
     if (p != 0) {
         hitPointScale = float(unitHitPointTable[unitState.unit_type]) / 18.0f;
     } else {
@@ -328,11 +329,11 @@
 
 void ParticleInterface::buildUnitTables()
 {
-    unitHitPointTable.resize(UnitProfileInterface::getNumUnitTypes());
-    unitAttackFactorTable.resize(UnitProfileInterface::getNumUnitTypes());
+    unitHitPointTable.resize(global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes());
+    unitAttackFactorTable.resize(global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes());
     
-    for (int i = 0; i &lt; UnitProfileInterface::getNumUnitTypes(); i++) {
-        UnitProfile *p = UnitProfileInterface::getUnitProfile(i);
+    for (int i = 0; i &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); i++) {
+        UnitProfile *p = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(i);
 
         unitHitPointTable[i]     = int(sqrt(p-&gt;hit_points));
         unitAttackFactorTable[i] = int(sqrt(p-&gt;attack_factor * 2));
@@ -512,21 +513,12 @@
 //--------------------------------------------------------------------------
 void ParticleInterface::getUnitParticleInfo()
 {
-    // Create the correct number of unit information slots.
-    unitParticleInfo.resize(UnitProfileInterface::getNumUnitTypes());
-    LOGGER.warning(&quot;Going to do the unit things for %d units\n&quot;, UnitProfileInterface::getNumUnitTypes());
-    for ( int i=0; i&lt; UnitProfileInterface::getNumUnitTypes(); i++ )
+    unitParticleInfo.resize(global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes());
+    for ( int i=0; i&lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); i++ )
     {
-        UnitProfile * uprofile = UnitProfileInterface::getUnitProfile(i);
+        UnitProfile * uprofile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(i);
         getMuzzleTips(uprofile-&gt;turretSprite, unitParticleInfo[i].muzzleTip);
         getMinBounds(uprofile-&gt;bodySprite, unitParticleInfo[i].minBounds);
-        LOGGER.warning(&quot;min bounds for unit %d: %d,%d to %d,%d&quot;,
-                       i,
-                       unitParticleInfo[i].minBounds.min.x,
-                       unitParticleInfo[i].minBounds.min.y,
-                       unitParticleInfo[i].minBounds.max.x,
-                       unitParticleInfo[i].minBounds.max.y);
-
     }
 }
 

Modified: trunk/netpanzer/src/NetPanzer/Particles/Physics.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Particles/Physics.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Particles/Physics.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -31,21 +31,16 @@
 //--------------------------------------------------------------------------
 void Physics::init()
 {
-    // Clear out the velocity table.
-    memset(&amp;directionTable, 0, sizeof(fXYZ));
-
     gravity = 32 * 12;
 
     float radians;
 
-    for (int degree = 0; degree &lt; DIRECTION_TABLE_COUNT; degree++) {
+    for (int degree = 0; degree &lt; DIRECTION_TABLE_COUNT; degree++)
+    {
         radians = Math::deg2Rad(degree);
 
         fXY direction;
         direction.x = float(cos(radians));
-        //direction.y = float(Math::deg2Rad((rand() % 20) + 70)); // Radians
-        //const int min = 80;
-        //direction.y = (rand() % (90 - min)) + min; // Degrees
         direction.y = float(sin(radians));
 
         directionTable[degree] = direction;

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/BonusUnitPowerUp.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,8 @@
 */
 
 #include &quot;BonusUnitPowerUp.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &lt;stdlib.h&gt;
 #include &quot;Units/UnitTypes.hpp&quot;
@@ -36,7 +38,7 @@
 BonusUnitPowerUp::BonusUnitPowerUp(iXY map_loc, int type)
         : PowerUp( map_loc, type )
 {
-    bonus_unit_type = rand() % UnitProfileInterface::getNumUnitTypes();
+    bonus_unit_type = rand() % global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes();
 }
 
 
@@ -45,7 +47,7 @@
     PlacementMatrix placement_matrix;
     iXY map_pos;
 
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
 
     MapInterface::pointXYtoMapXY( unit-&gt;unit_state.location, &amp;map_pos );
 
@@ -59,7 +61,7 @@
 
         placement_matrix.getNextEmptyLoc( &amp;spawn_loc );
 
-        new_unit = UnitInterface::createUnit(bonus_unit_type,
+        new_unit = global_game_state-&gt;unit_manager-&gt;createUnit(bonus_unit_type,
                                              spawn_loc,
                                              unit-&gt;player-&gt;getID() );
 
@@ -86,7 +88,7 @@
 
 void BonusUnitPowerUp::onHitMessage( PowerUpHitMesg *message  )
 {
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
     life_cycle_state = _power_up_lifecycle_state_inactive;
 
     if( PlayerInterface::getLocalPlayerIndex() == message-&gt;getPlayerID() )

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/EnemyRadarPowerUp.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,7 @@
 */
 
 #include &quot;EnemyRadarPowerUp.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
 
 #include &lt;stdlib.h&gt;
 #include &quot;Units/UnitTypes.hpp&quot;
@@ -62,7 +63,7 @@
 void
 EnemyRadarPowerUp::onHit( Unit * unit )
 {
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
 
     if(unit-&gt;player == PlayerInterface::getLocalPlayer())
     {
@@ -79,7 +80,7 @@
 void
 EnemyRadarPowerUp::onHitMessage( PowerUpHitMesg *message  )
 {
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
 
     if( PlayerInterface::getLocalPlayerIndex() == message-&gt;getPlayerID() )
     {

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/PowerUp.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,7 @@
 */
 
 #include &quot;PowerUps/PowerUp.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &quot;Units/UnitBlackBoard.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
@@ -82,9 +83,9 @@
     if ( NetworkState::status == _network_state_server
          &amp;&amp; life_cycle_state == _power_up_lifecycle_state_active )
     {
-        if( UnitBlackBoard::unitOccupiesLoc(map_loc) )
+        if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc(map_loc) )
         {
-            Unit * unit = UnitInterface::queryUnitAtMapLoc(map_loc);
+            Unit * unit = global_game_state-&gt;unit_manager-&gt;unit_bucket_array.queryUnitAtMapLoc(map_loc);
             if ( unit )
             {
                 onHit( unit );

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/PowerUpInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/PowerUpInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/PowerUpInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -89,8 +89,8 @@
 
     if( (powerup_list.size() &lt; (size_t) power_up_limit) )
     {
-        map_size_x = MapInterface::getWidth();
-        map_size_y = MapInterface::getHeight();
+        map_size_x = global_game_state-&gt;world_map-&gt;getWidth();
+        map_size_y = global_game_state-&gt;world_map-&gt;getHeight();
 
         do
         {
@@ -169,8 +169,8 @@
     // here memory leak, should delete the pointer to powerups in the list
     powerup_list.clear();
 
-    map_size_x = MapInterface::getWidth();
-    map_size_y = MapInterface::getHeight();
+    map_size_x = global_game_state-&gt;world_map-&gt;getWidth();
+    map_size_y = global_game_state-&gt;world_map-&gt;getHeight();
 
     setPowerUpLimits( map_size_x, map_size_y );
 

Modified: trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/PowerUps/UnitPowerUp.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,8 @@
 */
 
 #include &quot;UnitPowerUp.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &lt;stdlib.h&gt;
 #include &quot;Units/UnitTypes.hpp&quot;
@@ -115,13 +117,13 @@
 {
     UMesgSelfDestruct self_destruct;
     self_destruct.setHeader( unit_id );
-    UnitInterface::sendMessage( &amp;self_destruct );
+    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;self_destruct );
 }
 
 
 void UnitPowerUp::onHit( Unit * unit )
 {
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
 
     switch( unit_powerup_type )
     {
@@ -196,7 +198,7 @@
 
 void UnitPowerUp::onHitMessage( PowerUpHitMesg *message  )
 {
-    sound-&gt;playPowerUpSound();
+    global_engine_state-&gt;sound_manager-&gt;playPowerUpSound();
     life_cycle_state = _power_up_lifecycle_state_inactive;
 
     if( PlayerInterface::getLocalPlayerIndex() == message-&gt;getPlayerID() )

Modified: trunk/netpanzer/src/NetPanzer/Resources/ResourceManager.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Resources/ResourceManager.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Resources/ResourceManager.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -69,7 +69,7 @@
     {
         if ( RMan.flagList[n] == &amp;noimage)
         {
-            RMan.flagList[n] = new Surface(20,14,1);
+            RMan.flagList[n] = new Surface(20, 14, 1, 8);
         }
         RMan.flagList[n]-&gt;fill(0);
         RMan.usedList[n] = false;

Modified: trunk/netpanzer/src/NetPanzer/System/Sound.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/System/Sound.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/System/Sound.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,8 +19,6 @@
 
 #include &quot;Sound.hpp&quot;
 
-Sound* sound = 0;
-
 //-----------------------------------------------------------------
 Sound::Sound()
 {

Modified: trunk/netpanzer/src/NetPanzer/System/Sound.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/System/Sound.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/System/Sound.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -55,7 +55,5 @@
     int m_battleCount;
 };
 
-extern Sound* sound;
-
 #endif
 

Modified: trunk/netpanzer/src/NetPanzer/Units/Unit.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Unit.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -42,6 +42,9 @@
 #include &quot;Particles/ParticleInterface.hpp&quot;
 #include &quot;Interfaces/WorldViewInterface.hpp&quot;
 
+#include &quot;Core/GlobalGameState.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+
 #define MOVEWAIT_TIME 0.8f
 
 #define UNIT_LAYER 3
@@ -119,18 +122,23 @@
     _rotate_stop_move
 };
 
-Unit::Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc)
+Unit::Unit(PlayerState* ownplayer, UnitInterface * unit_manager, unsigned char utype, UnitID uid, iXY initial_loc)
     : player(ownplayer), id(uid)
 {
+    my_manager = unit_manager;
     smolderWait    = 0.0f;
     smolderWaitMin = 0.0f;
 
-    if(!MapInterface::inside(initial_loc))
+    if ( (unsigned int)initial_loc.x &gt;= global_game_state-&gt;world_map-&gt;getWidth()
+       ||(unsigned int)initial_loc.y &gt;= global_game_state-&gt;world_map-&gt;getHeight())
+    {
         throw std::runtime_error(&quot;Invalid position&quot;);
+    }
+    iXY loc;
+    MapInterface::mapXYtoPointXY(initial_loc, &amp;loc);
 
-    iXY loc = MapInterface::mapXYtoPointXY(initial_loc);
     unit_state.location = loc;
-    UnitBlackBoard::markUnitLoc( initial_loc );
+    global_game_state-&gt;unit_manager-&gt;markUnitLoc( initial_loc );
     fsm_timer.changeRate( 10 );
     unit_state_timer.changeRate( 10 );
     setAiFsmDefendHold();
@@ -194,7 +202,7 @@
 {
     UnitProfile *profile;
     
-    profile = UnitProfileInterface::getUnitProfile( utype );
+    profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile( utype );
     
     unit_state.hit_points = profile-&gt;hit_points;
     unit_state.max_hit_points = profile-&gt;hit_points;
@@ -258,7 +266,7 @@
 
             DestructUnitOpcode destruct_opcode;
             destruct_opcode.setUnitID(id);
-            UnitInterface::sendOpcode(&amp;destruct_opcode);
+            my_manager-&gt;sendOpcode(&amp;destruct_opcode);
         }
         else
         {
@@ -549,7 +557,7 @@
         move_opcode.loc_y_offset = (signed char) loc_offset.y;
         if ( move_opcode_sent == true )
         {
-            UnitInterface::sendOpcode(&amp;move_opcode);
+            my_manager-&gt;sendOpcode(&amp;move_opcode);
         }
     }
 
@@ -564,7 +572,7 @@
     {
         if ( opcode_move_timer.count() )
         {
-            UnitInterface::sendOpcode(&amp;move_opcode);
+            my_manager-&gt;sendOpcode(&amp;move_opcode);
             move_opcode_sent = true;
         }
     }
@@ -582,7 +590,7 @@
 
                     if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                     {
-                        UnitInterface::sendOpcode(&amp;move_opcode);
+                        my_manager-&gt;sendOpcode(&amp;move_opcode);
                         move_opcode_sent = true;
                     }
                     
@@ -602,7 +610,7 @@
 
                 if ( move_opcode_sent == false &amp;&amp; NetworkState::status == _network_state_server )
                 {
-                    UnitInterface::sendOpcode(&amp;move_opcode);
+                    my_manager-&gt;sendOpcode(&amp;move_opcode);
                     move_opcode_sent = true;
                 }
 
@@ -632,7 +640,7 @@
     {
         TurretTrackPointOpcode track_point_opcode(id, 0, true);
         track_point_opcode.setTarget(target);
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
     }
 
 }
@@ -646,7 +654,7 @@
     if ( NetworkState::status == _network_state_server )
     {
         TurretTrackPointOpcode track_point_opcode(id, 0, false);
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
     }
 }
 
@@ -656,7 +664,7 @@
     {
         TurretTrackPointOpcode track_point_opcode(id, _unit_opcode_flag_sync, true);
         track_point_opcode.setTarget(fsmTurretTrackPoint_target);
-        UnitInterface::sendOpcode( &amp;track_point_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_point_opcode );
     }
 }
 
@@ -690,7 +698,7 @@
     {
         TurretTrackTargetOpcode track_target_opcode(id, 0, true);
         track_target_opcode.setTargetUnitID(target_id);
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -702,7 +710,7 @@
     if ( NetworkState::status == _network_state_server )
     {
         TurretTrackTargetOpcode track_target_opcode(id, 0, false);
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -713,7 +721,7 @@
     {
         TurretTrackTargetOpcode track_target_opcode(id, _unit_opcode_flag_sync, true);
         track_target_opcode.setTargetUnitID(fsmTurretTrackTarget_target_id);
-        UnitInterface::sendOpcode( &amp;track_target_opcode );
+        my_manager-&gt;sendOpcode( &amp;track_target_opcode );
     }
 
 }
@@ -727,7 +735,7 @@
     Unit *target_unit_ptr;
     iXY direction_vector;
 
-    target_unit_ptr = UnitInterface::getUnit( fsmTurretTrackTarget_target_id );
+    target_unit_ptr = my_manager-&gt;getUnit( fsmTurretTrackTarget_target_id );
 
     if ( target_unit_ptr != 0 )
     {
@@ -815,7 +823,7 @@
     UnitState *target_unit_state;
     iXY range_vector;
 
-    target_unit_ptr = UnitInterface::getUnit( fsmGunneryTarget_target_id );
+    target_unit_ptr = my_manager-&gt;getUnit( fsmGunneryTarget_target_id );
     if ( target_unit_ptr == 0 )
     {
         clearFsmGunneryTarget();
@@ -870,7 +878,7 @@
 void Unit::aiFsmMoveToLoc()
 {
     bool end_cycle = false;
-
+//LOGGER.warning(&quot;Unit %d move&quot;, id);
     do
     {
         switch ( aiFsmMoveToLoc_state )
@@ -879,6 +887,7 @@
             // *************************************************************
             case _aiFsmMoveToLoc_path_generate :
             {
+//LOGGER.warning(&quot;path_generate&quot;);
                 // QueryPath: Has a path been generated for unit ?
                 path_generated = PathScheduler::queryPath(id);
 
@@ -891,7 +900,7 @@
 
                     iXY current_map_loc;
                     MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
 
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
@@ -908,7 +917,7 @@
                 else if ( path_generated == true )
                 {
                     // Rule QueryPath: is true move to next state
-                    //LOG( (&quot;Path Successfully Generated&quot;) );
+                    LOG( (&quot;Path Successfully Generated&quot;) );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
                 }
                 else
@@ -922,14 +931,16 @@
 
             case _aiFsmMoveToLoc_check_goal :
             {
+//LOGGER.warning(&quot;check_goal&quot;);
                 //  GoalReached: Has the goal been reached ?
                 if ( ruleMoveToLoc_GoalReached() == true )
                 {
+//LOGGER.warning(&quot;check_goal -&gt; goal_reached&quot;);
                     // Rule GoalReached : is true
                     // Action : Exit fsm
                     aiFsmMoveToLoc_prev_loc = unit_state.location;
                     MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_prev_loc );
 
                     aiFsmMoveToLoc_OnExitCleanUp();
                     setAiFsmDefendHold();
@@ -940,6 +951,7 @@
                 {
                     if ( aiFsmMoveToLoc_path_not_finished == false )
                     {
+//LOGGER.warning(&quot;check_goal -&gt; path_not_finished&quot;);
                         //  Rule: GoalReached is false AND Unit is at the end of path
                         //  Action : Request path generation to goal
                         iXY start;
@@ -954,6 +966,7 @@
                     }
                     else
                     {
+//LOGGER.warning(&quot;check_goal -&gt; path_finished&quot;);
                         // Rule GoalReached: is false
                         // Action: Get next move;
                         aiFsmMoveToLoc_state = _aiFsmMoveToLoc_next_move;
@@ -966,23 +979,27 @@
 
             case _aiFsmMoveToLoc_next_move :
             {
+//LOGGER.warning(&quot;next_move&quot;);
                 // CurrentPathComplete: is Unit at the end of the current path
                 aiFsmMoveToLoc_path_not_finished = path.popFirst( &amp;aiFsmMoveToLoc_next_square );
                 MapInterface::offsetToMapXY( aiFsmMoveToLoc_next_square, &amp;aiFsmMoveToLoc_next_loc );
+//LOGGER.warning(&quot;Unit:moving to %d,%d&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
 
                 if ( !aiFsmMoveToLoc_path_not_finished )
                 {
+//LOGGER.warning(&quot;next_move -&gt; path_finished&quot;);
                     // Rule: CurrentPathComplete is true
                     // Action : check if unit is at the goal
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_goal;
                 }
                 else
                 {
+//LOGGER.warning(&quot;next_move -&gt; path_not_finished&quot;);
                     // Rule: CurrentPathComplete is false
                     // Action: Check if next location is empty
                     aiFsmMoveToLoc_prev_loc = unit_state.location;
                     MapInterface::pointXYtoMapXY( aiFsmMoveToLoc_prev_loc, &amp;aiFsmMoveToLoc_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_prev_loc );
 
                     //aiFsmMoveToLoc_wait_timer.changePeriod( MOVEWAIT_TIME );
                     aiFsmMoveToLoc_wait_timer.reset();
@@ -995,13 +1012,14 @@
 
             case _aiFsmMoveToLoc_wait_clear_loc :
             {
+//LOGGER.warning(&quot;wait_clear_loc&quot;);
 
                 if ( external_ai_event == _external_event_pending_unit_destruct  )
                 {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1014,8 +1032,10 @@
                     aiFsmMoveToLoc_OnExitCleanUp();
                     end_cycle = true;
                 } // NextSquareOccupied: does the next square contain a abstruction
-                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
+                else if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmMoveToLoc_next_loc ) == true )
                 {
+//LOGGER.warning(&quot;wait_clear_loc -&gt; unit occupy loc %d,%d&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
+
                     // Rule: NextSquareOccupied is true
                     // Action: Check Wait Timer
 
@@ -1025,9 +1045,10 @@
                         // Action: Preform path update
                         if ( aiFsmMoveToLoc_next_loc == aiFsmMoveToLoc_goal )
                         {
+//LOGGER.warning(&quot;wait_clear_loc -&gt; unit occupy loc do repath&quot;);
 
-                            UnitInterface::unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
-                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
+                            my_manager-&gt;unit_placement_matrix.reset( aiFsmMoveToLoc_goal );
+                            my_manager-&gt;unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmMoveToLoc_goal );
 
                             PathRequest path_request;
                             path_request.set(id, aiFsmMoveToLoc_prev_loc, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
@@ -1036,7 +1057,7 @@
                         }
                         else
                         {
-//                            LOGGER.warning(&quot;Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
+//LOGGER.warning(&quot;wait_clear_loc -&gt; Requesting updated path for unit %d from %d,%d to %d,%d&quot;, id,
 //                                           aiFsmMoveToLoc_prev_loc.x, aiFsmMoveToLoc_prev_loc.y,
 //                                           aiFsmMoveToLoc_goal.x,aiFsmMoveToLoc_goal.y);
                             PathRequest path_request;
@@ -1053,10 +1074,12 @@
                 }
                 else
                 {
+//LOGGER.warning(&quot;wait_clear_loc -&gt; is empty&quot;);
                     // Rule: NextSquareOccupied is false
                     // Action: Begin move to next square
-                    UnitBlackBoard::markUnitLoc( aiFsmMoveToLoc_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmMoveToLoc_next_loc );
                     setFsmMoveMapSquare( aiFsmMoveToLoc_next_square );
+//LOGGER.warning(&quot;Unit:moving to %d,%d moved&quot;, aiFsmMoveToLoc_next_loc.x, aiFsmMoveToLoc_next_loc.y);
 
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_move_wait;
                     aiFsmMoveToLoc_wait_timer.changePeriod( 0.8f );
@@ -1069,12 +1092,14 @@
 
             case _aiFsmMoveToLoc_move_wait :
             {
+//LOGGER.warning(&quot;move_wait&quot;);
                 // MoveFinished : has the low level fsm finshed
                 if ( fsm_active_list[ _control_move_map_square ] == false )
                 {
+//LOGGER.warning(&quot;move_wait -&gt; finished&quot;);
                     // Rule: MoveFinished is true
                     // Action: Check for a pending transition
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_prev_loc );
                     aiFsmMoveToLoc_state = _aiFsmMoveToLoc_check_fsm_transition;
                     end_cycle = true;
                 }
@@ -1090,12 +1115,13 @@
 
             case _aiFsmMoveToLoc_check_fsm_transition :
             {
+//LOGGER.warning(&quot;check_fsm_transition&quot;);
                 if ( external_ai_event == _external_event_pending_unit_destruct )
                 {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmMoveToLoc_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmMoveToLoc_next_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1135,7 +1161,7 @@
     iXY range_vector;
 
     Unit* target_unit_ptr
-        = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
+        = my_manager-&gt;getUnit( aiFsmAttackUnit_target_ID );
     if ( target_unit_ptr == 0 )
     {
         aiFsmAttackUnit_target_destroyed = true;
@@ -1182,7 +1208,7 @@
 
                     iXY current_map_loc;
                     MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-                    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
 
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
@@ -1221,7 +1247,7 @@
                     // Action: Remain in position
                     aiFsmAttackUnit_prev_loc = unit_state.location;
                     MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_idle;
                     end_cycle = true;
                 }
@@ -1259,7 +1285,7 @@
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1307,7 +1333,7 @@
                     // Action: Check if next location is empty
                     aiFsmAttackUnit_prev_loc = unit_state.location;
                     MapInterface::pointXYtoMapXY( aiFsmAttackUnit_prev_loc, &amp;aiFsmAttackUnit_prev_loc );
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_wait_timer.changePeriod( 0.8f );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_wait_clear_loc;
                 }
@@ -1323,7 +1349,7 @@
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1336,14 +1362,14 @@
                     aiFsmAttackUnit_OnExitCleanUp();
                     end_cycle = true;
                 }
-                else if ( UnitBlackBoard::unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
+                else if ( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmAttackUnit_next_loc ) == true )
                 {
                     if ( aiFsmAttackUnit_wait_timer.count() )
                     {
                         if ( aiFsmAttackUnit_next_loc == aiFsmAttackUnit_target_goal_loc )
                         {
-                            UnitInterface::unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
-                            UnitInterface::unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
+                            my_manager-&gt;unit_placement_matrix.reset( aiFsmAttackUnit_target_goal_loc );
+                            my_manager-&gt;unit_placement_matrix.getNextEmptyLoc( &amp;aiFsmAttackUnit_target_goal_loc );
 
                             PathRequest path_request;
                             path_request.set( id, aiFsmAttackUnit_prev_loc, aiFsmAttackUnit_target_goal_loc, 0, &amp;path, _path_request_full );
@@ -1364,7 +1390,7 @@
                 }
                 else
                 {
-                    UnitBlackBoard::markUnitLoc( aiFsmAttackUnit_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmAttackUnit_next_loc );
                     setFsmMoveMapSquare( aiFsmAttackUnit_next_square );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_move_wait;
                 }
@@ -1377,7 +1403,7 @@
             {
                 if ( fsm_active_list[ _control_move_map_square ] == false )
                 {
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_prev_loc );
                     aiFsmAttackUnit_state = _aiFsmAttackUnit_check_fsm_transition;
                 }
                 end_cycle = true;
@@ -1393,7 +1419,7 @@
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
                     aiFsmAttackUnit_OnExitCleanUp();
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmAttackUnit_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmAttackUnit_next_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1496,8 +1522,8 @@
                 }
                 else if ( aiFsmDefendHold_search_timer.count() )
                 {
-                    if (UnitInterface::queryClosestEnemyUnit(
-                                &amp;target_unit_ptr, unit_state.location,
+                    if (my_manager-&gt;unit_bucket_array.queryClosestEnemyUnitInRange(
+                                &amp;target_unit_ptr, unit_state.location, unit_state.weapon_range,
                                 player-&gt;getID() ) )
                     {
                         target_unit_state = &amp;(target_unit_ptr-&gt;unit_state);
@@ -1548,7 +1574,7 @@
                 }
                 else
                 {
-                    target_unit_ptr = UnitInterface::getUnit( aiFsmDefendHold_target_ID );
+                    target_unit_ptr = my_manager-&gt;getUnit( aiFsmDefendHold_target_ID );
                     if ( target_unit_ptr == 0 )
                     {
                         clearFsmGunneryTarget();
@@ -1612,14 +1638,14 @@
                     setAiFsmDefendHold();
                     end_cycle = true;
                 }
-                else if( UnitBlackBoard::unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
+                else if( global_game_state-&gt;unit_manager-&gt;unitOccupiesLoc( aiFsmManualMove_next_loc ) == true )
                 {
                     setAiFsmDefendHold();
                     end_cycle = true;
                 }
                 else
                 {
-                    UnitBlackBoard::markUnitLoc( aiFsmManualMove_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;markUnitLoc( aiFsmManualMove_next_loc );
                     setFsmMoveMapSquare( next_square );
                     aiFsmManualMove_state = _aiFsmManualMove_move_wait;
                 }
@@ -1632,7 +1658,7 @@
             {
                 if ( fsm_active_list[ _control_move_map_square ] == false )
                 {
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_prev_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmManualMove_prev_loc );
                     aiFsmManualMove_state = _aiFsmManualMove_check_fsm_transition;
                     end_cycle = true;
                 }
@@ -1651,7 +1677,7 @@
                 {
                     // External Event: This unit is about to be deleted
                     // Action : Exit fsm gracefully
-                    UnitBlackBoard::unmarkUnitLoc( aiFsmManualMove_next_loc );
+                    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( aiFsmManualMove_next_loc );
                     external_ai_event = _external_event_null;
                     ai_command_state = _ai_command_idle;
                     end_cycle = true;
@@ -1687,14 +1713,14 @@
     if ( NetworkState::status == _network_state_server ) {
         FireWeaponOpcode fire_opcode(id);
         fire_opcode.setTarget(target_loc);
-        UnitInterface::sendOpcode(&amp;fire_opcode);
+        my_manager-&gt;sendOpcode(&amp;fire_opcode);
     }
 }
 
 //-----------------------------------------------------------------
 void Unit::soundSelected()
 {
-        sound-&gt;playSound( soundSelect.size()?soundSelect.c_str():&quot;yessir&quot;);
+    global_engine_state-&gt;sound_manager-&gt;playSound( soundSelect.size()?soundSelect.c_str():&quot;yessir&quot;);
 }
 
 void Unit::accessThreatLevels()
@@ -1713,8 +1739,8 @@
 unsigned short Unit::launchProjectile()
 {
     long distance = WorldViewInterface::getCameraDistance(unit_state.location);
-    sound-&gt;playAmbientSound(fireSound.c_str(), distance );
-    sound-&gt;playBattle();
+    global_engine_state-&gt;sound_manager-&gt;playAmbientSound(fireSound.c_str(), distance );
+    global_engine_state-&gt;sound_manager-&gt;playBattle();
     
     return weaponType;
 }
@@ -1828,9 +1854,8 @@
 
     MapInterface::pointXYtoMapXY( unit_state.location, &amp;start );
 
-    //LOG( (&quot;UnitID %d, %d : Start %d, %d : Goal %d, %d&quot;, id.getPlayer(), id.getIndex(),
-    //                                                    start.x, start.y,
-    //                                                    aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
+//    LOG( (&quot;Unit %d : Start %d, %d : Goal %d, %d&quot;, id, start.x, start.y,
+//            aiFsmMoveToLoc_goal.x, aiFsmMoveToLoc_goal.y ) );
 
     PathRequest path_request;
     path_request.set( id, start, aiFsmMoveToLoc_goal, 0, &amp;path, _path_request_full );
@@ -1849,7 +1874,7 @@
 
     aiFsmAttackUnit_target_ID = message-&gt;getTargetUnitID();
 
-    target_unit_ptr = UnitInterface::getUnit( aiFsmAttackUnit_target_ID );
+    target_unit_ptr = my_manager-&gt;getUnit( aiFsmAttackUnit_target_ID );
     if ( target_unit_ptr == 0 )
     {
         return;
@@ -1917,7 +1942,7 @@
 
     update_state_opcode.setUnitID(id);
     update_state_opcode.setHitPoints(unit_state.hit_points);
-    UnitInterface::sendOpcode( &amp;update_state_opcode );
+    my_manager-&gt;sendOpcode( &amp;update_state_opcode );
 
     if ( unit_state.hit_points &lt;= 0 )
     {
@@ -1927,12 +1952,12 @@
         UMesgEndLifeCycleUpdate lifecycle_update;
         lifecycle_update.set(id, weapon_hit-&gt;getOwnerUnitID(),
                 unit_state.unit_type);
-        UnitInterface::sendMessage(&amp;lifecycle_update);
+        my_manager-&gt;sendMessage(&amp;lifecycle_update);
 
         // ** Note: Temp
         iXY current_map_loc;
         MapInterface::pointXYtoMapXY(unit_state.location, &amp;current_map_loc);
-        UnitBlackBoard::unmarkUnitLoc(current_map_loc);
+        global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc(current_map_loc);
     }
 }
 
@@ -1972,7 +1997,7 @@
     // ** Note: Temp
     iXY current_map_loc;
     MapInterface::pointXYtoMapXY( unit_state.location, &amp;current_map_loc );
-    UnitBlackBoard::unmarkUnitLoc( current_map_loc );
+    global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( current_map_loc );
 }
 
 void Unit::processMessage(const UnitMessage* message)
@@ -2116,7 +2141,7 @@
 
     SyncUnitOpcode sync_opcode(id);
 
-    UnitInterface::sendOpcode( &amp;sync_opcode );
+    my_manager-&gt;sendOpcode( &amp;sync_opcode );
 }
 
 

Modified: trunk/netpanzer/src/NetPanzer/Units/Unit.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/Unit.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -31,6 +31,7 @@
 #include &quot;Classes/SpriteSorter.hpp&quot;
 
 class PlayerState;
+class UnitInterface;
 
 class Unit
 {
@@ -40,7 +41,7 @@
     UnitState    unit_state;
     bool         in_sync_flag;
 
-    Unit(PlayerState* ownplayer, unsigned char utype, UnitID uid, iXY initial_loc);
+    Unit(PlayerState* ownplayer, UnitInterface * unit_manager, unsigned char utype, UnitID uid, iXY initial_loc);
 
     void soundSelected();
 
@@ -228,6 +229,7 @@
 
 private:
     friend class UnitInterface;
+    UnitInterface * my_manager;
 
     void setID(UnitID id)
     {

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -18,35 +18,13 @@
 
 #include &quot;Units/UnitBlackBoard.hpp&quot;
 
-#include &quot;Interfaces/MapInterface.hpp&quot;
-
-BitArray UnitBlackBoard::unit_loc_map;
-
-void UnitBlackBoard::initializeBlackBoard( void )
+void UnitBlackBoard::initialize(unsigned long mapWidth, unsigned long mapHeight)
 {
-    unit_loc_map.initialize( MapInterface::getWidth(),
-                             MapInterface::getHeight() );
-
+    unit_loc_map.initialize(mapWidth, mapHeight);
     unit_loc_map.clear();
 }
 
-void UnitBlackBoard::resetBlackBoard()
+void UnitBlackBoard::cleanUp()
 {
     unit_loc_map.clear();
 }
-
-
-void UnitBlackBoard::updateUnitLocs( void )
-{
-    unsigned long i,k,x_limit,y_limit;
-
-    x_limit = unit_loc_map.x_size;
-    y_limit = unit_loc_map.y_size;
-
-    for( i = 0; i &lt; y_limit; i++ )
-        for ( k = 0; k &lt; x_limit; k++ ) {
-            if ( unit_loc_map.getBit( k, i ) == true )
-                MapInterface::markLocHack( iXY( k, i ) );
-        }
-
-}

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBlackBoard.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -23,35 +23,28 @@
 
 class UnitBlackBoard
 {
-protected:
-    friend class Unit;
-    friend class UnitInterface; // for unmark unit hack
-    
-    static BitArray unit_loc_map;
+public:
+    void initialize(unsigned long mapWidth, unsigned long mapHeight);
 
-    static inline void markUnitLoc( iXY &amp;unit_map_loc )
+    void cleanUp();
+
+    bool unitOccupiesLoc( iXY &amp;unit_map_loc )
     {
-        unit_loc_map.setBit( unit_map_loc.x, unit_map_loc.y );
+        return( unit_loc_map.getBit( unit_map_loc.x, unit_map_loc.y ) );
     }
 
-    static inline void unmarkUnitLoc( iXY &amp;unit_map_loc )
+    void markUnitLoc( iXY &amp;unit_map_loc )
     {
-        unit_loc_map.clearBit( unit_map_loc.x, unit_map_loc.y );
+        unit_loc_map.setBit( unit_map_loc.x, unit_map_loc.y );
     }
 
-public:
-    static void initializeBlackBoard( void );
-
-    static void resetBlackBoard();
-
-    static void updateUnitLocs( void );
-
-    static inline bool unitOccupiesLoc( iXY &amp;unit_map_loc )
+    void unmarkUnitLoc( iXY &amp;unit_map_loc )
     {
-        return( unit_loc_map.getBit( unit_map_loc.x, unit_map_loc.y ) );
+        unit_loc_map.clearBit( unit_map_loc.x, unit_map_loc.y );
     }
 
-
+private:
+    BitArray unit_loc_map;
 };
 
 #endif // ** _UNITBLACKBOARD_HPP

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -21,8 +21,10 @@
 #include &lt;list&gt;
 #include &lt;algorithm&gt;
 
-#include &quot;2D/Palette.hpp&quot;
 #include &quot;Units/UnitBucketArray.hpp&quot;
+#include &quot;Classes/PlayerState.hpp&quot;
+#include &quot;Interfaces/PlayerInterface.hpp&quot;
+#include &quot;Interfaces/MapInterface.hpp&quot;
 
 void
 UnitBucketArray::initialize( const iXY &amp; map_size, const iXY &amp; tile_size,
@@ -86,3 +88,200 @@
         }
     }
 }
+
+void
+UnitBucketArray::queryPlayerUnitsAt(std::vector&lt;UnitID&gt;&amp; working_list,
+                                    const iXY&amp; point,
+                                    const Uint16 player_id)
+{
+    UnitList &amp; ubl = getBucketAssocWorldLoc(point);
+    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
+    {
+        Unit* unit = *i;
+        if( (*i)-&gt;unit_state.bounds(point)
+            &amp;&amp; (*i)-&gt;player-&gt;getID() == player_id )
+        {
+            working_list.push_back(unit-&gt;id);
+        }
+    }
+}
+
+void
+UnitBucketArray::queryUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+                                       const iRect&amp; rect)
+{
+    UnitList::iterator iter;
+    iRect bucket_rect;
+    worldRectToBucketRect( rect, bucket_rect);
+
+    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
+    {
+        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
+        {
+            UnitList &amp; bucket_list = getBucket(row, col);
+
+            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
+            {
+                if( rect.contains((*iter)-&gt;unit_state.location) )
+                {
+                    working_list.push_back(*iter);
+                }
+            }
+        }
+    }
+}
+
+void
+UnitBucketArray::queryPlayerUnitsInWorldRect(std::vector&lt;UnitID&gt;&amp; working_list,
+                                             const iRect&amp; rect,
+                                             const Uint16 player_id)
+{
+    UnitList::iterator iter;
+    iRect bucket_rect;
+    worldRectToBucketRect( rect, bucket_rect);
+
+    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
+    {
+        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
+        {
+            UnitList &amp; bucket_list = getBucket(row, col);
+
+            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
+            {
+                if(    rect.contains((*iter)-&gt;unit_state.location)
+                    &amp;&amp; (*iter)-&gt;player-&gt;getID() == player_id )
+                {
+                    working_list.push_back((*iter)-&gt;id);
+                }
+
+            }
+        }
+    }
+}
+
+void
+UnitBucketArray::queryNonPlayerUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+                                                const iRect&amp; rect,
+                                                const Uint16 player_id)
+{
+    UnitList::iterator iter;
+    iRect bucket_rect;
+    worldRectToBucketRect( rect, bucket_rect);
+
+    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
+    {
+        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
+        {
+            UnitList &amp; bucket_list = getBucket(row, col);
+
+            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
+            {
+                if(    rect.contains((*iter)-&gt;unit_state.location)
+                    &amp;&amp; (*iter)-&gt;player-&gt;getID() != player_id )
+                {
+                    working_list.push_back(*iter);
+                }
+
+            }
+        }
+    }
+}
+
+bool
+UnitBucketArray::queryClosestEnemyUnitInRange(Unit **closest_unit_ptr,
+                                              const iXY &amp;loc,
+                                              unsigned long range,
+                                              const Uint16 player_id)
+{
+    Unit *closest_unit = 0;
+    long closest_magnitude = 0;
+    iRect bucket_rect;
+    UnitList::iterator bucket_iter;
+
+    unitRangeToBucketRect( loc, range, bucket_rect );
+
+    for( long row_index = bucket_rect.min.y; row_index &lt;= bucket_rect.max.y; row_index++ )
+    {
+        for( long column_index = bucket_rect.min.x; column_index &lt;= bucket_rect.max.x; column_index++ )
+        {
+            UnitList &amp;bucket_list = getBucket( row_index, column_index );
+
+            for ( bucket_iter = bucket_list.begin();
+                    bucket_iter != bucket_list.end(); ++bucket_iter)
+            {
+                iXY delta;
+                long temp_mag;
+
+                Uint16 unitPlayerID = (*bucket_iter)-&gt;player-&gt;getID();
+
+                if (   unitPlayerID == player_id
+                    || PlayerInterface::isAllied(player_id, unitPlayerID) )
+                {
+                    continue;
+                }
+
+                if ( closest_unit == 0 )
+                {
+                    closest_unit = *bucket_iter;
+                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
+                    closest_magnitude = long(delta.mag2());
+                }
+                else
+                {
+                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
+                    temp_mag = long(delta.mag2());
+
+                    if ( closest_magnitude &gt; temp_mag )
+                    {
+                        closest_unit = *bucket_iter;
+                        closest_magnitude = temp_mag;
+                    }
+                }
+            }
+        }
+    }
+
+    if( closest_unit != 0 )
+    {
+        *closest_unit_ptr = closest_unit;
+        return true;
+    }
+
+    *closest_unit_ptr = 0;
+    return false;
+}
+
+Unit *
+UnitBucketArray::queryUnitAtMapLoc(const iXY &amp; map_loc)
+{
+    iXY world_loc;
+    MapInterface::mapXYtoPointXY(map_loc, &amp;world_loc);
+
+    UnitList &amp; ubl = getBucketAssocMapLoc(map_loc);
+    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
+    {
+        if ( (*i)-&gt;unit_state.bounds(world_loc) )
+        {
+            return *i;
+        }
+    }
+
+    return 0;
+}
+
+Unit *
+UnitBucketArray::queryNonPlayerUnitAtWorld(const iXY &amp; world_loc,
+                                           const Uint16 player_id)
+{
+    UnitList &amp; ubl = getBucketAssocWorldLoc(world_loc);
+    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
+    {
+        if ( (*i)-&gt;unit_state.bounds(world_loc)
+              &amp;&amp; (*i)-&gt;player-&gt;getID() != player_id )
+        {
+            return *i;
+        }
+    }
+
+    return 0;
+}

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitBucketArray.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -22,26 +22,44 @@
 #include &lt;list&gt;
 #include &lt;algorithm&gt;
 #include &quot;Units/Unit.hpp&quot;
+#include &quot;Types/iRect.hpp&quot;
 
 typedef std::vector&lt;Unit *&gt; UnitList;
 typedef std::vector&lt;UnitList&gt; BucketList;
 
-class UnitBucketArray // : public UnitBucketArrayTemplate
+class UnitBucketArray
 {
-protected:
-    BucketList buckets;
-    long map_x_sample_factor;
-    long map_y_sample_factor;
-    long pixel_x_sample_factor;
-    long pixel_y_sample_factor;
-    size_t row_size;
-    size_t column_size;
-
 public:
+    void queryPlayerUnitsAt(std::vector&lt;UnitID&gt;&amp; working_list,
+                            const iXY&amp; point,
+                            const Uint16 player_id);
 
-    UnitBucketArray( ) {};
-    ~UnitBucketArray( ) {};
+    void queryUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+                               const iRect&amp; rect);
 
+    void queryPlayerUnitsInWorldRect(std::vector&lt;UnitID&gt;&amp; working_list,
+                                     const iRect&amp; rect,
+                                     const Uint16 player_id);
+
+    void queryNonPlayerUnitsInWorldRect(std::vector&lt;Unit *&gt;&amp; working_list,
+                                        const iRect&amp; rect,
+                                        const Uint16 player_id);
+
+    Unit * queryUnitAtMapLoc(const iXY&amp; map_loc);
+
+    Unit * queryNonPlayerUnitAtWorld(const iXY &amp; world_loc,
+                                     const Uint16 player_id);
+
+    bool queryClosestEnemyUnitInRange(Unit **closest_unit_ptr,
+                                      const iXY &amp;loc,
+                                      unsigned long range,
+                                      const Uint16 player_id);
+
+private:
+    friend class UnitInterface;
+    UnitBucketArray( ) {}
+    ~UnitBucketArray( ) {}
+
     void sort();
 
     void initialize( const iXY &amp; map_size, const iXY &amp; tile_size,
@@ -130,6 +148,29 @@
         worldLocToBucketLoc(world_rect.max, bucket_rect.max);
     }
 
+    void unitRangeToBucketRect( const iXY&amp; world_loc, unsigned long range, iRect &amp;bucket_rect ) const
+    {
+        worldLocToBucketLoc(world_loc, bucket_rect.min);
+        worldLocToBucketLoc(world_loc, bucket_rect.max);
+        // add range
+        unsigned long range_buckets = range / ( (pixel_x_sample_factor*pixel_x_sample_factor)
+                                              + (pixel_y_sample_factor*pixel_y_sample_factor));
+        bucket_rect.min.x -= range_buckets;
+        bucket_rect.min.y -= range_buckets;
+        bucket_rect.max.x += range_buckets;
+        bucket_rect.max.y += range_buckets;
+
+        if ( (size_t)bucket_rect.max.x &gt;= column_size )
+        {
+            bucket_rect.max.x = column_size-1;
+        }
+
+        if ( (size_t)bucket_rect.max.y &gt;= row_size )
+        {
+            bucket_rect.max.y = row_size-1;
+        }
+    }
+
     void mapLocToBucketLoc( const iXY &amp; map_loc, iXY &amp; bucket_loc) const
     {
         bucket_loc.x = map_loc.x / map_x_sample_factor;
@@ -151,8 +192,15 @@
     {
         return getBucket(mapLocToBucketIndex(map_loc));
     }
-    
-private:
+
+    BucketList buckets;
+    long map_x_sample_factor;
+    long map_y_sample_factor;
+    long pixel_x_sample_factor;
+    long pixel_y_sample_factor;
+    size_t row_size;
+    size_t column_size;
+
     struct FindUnit
     {
         const UnitID toFind;

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -20,6 +20,9 @@
 #include &lt;iostream&gt;
 #include &lt;algorithm&gt;
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
+
 #include &quot;UnitInterface.hpp&quot;
 #include &quot;UnitProfileInterface.hpp&quot;
 #include &quot;UnitBucketArray.hpp&quot;
@@ -48,37 +51,25 @@
 #include &quot;Util/Log.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
 
+UnitInterface::UnitInterface()
+{
+    // nothing
+}
 
-//UnitList * UnitInterface::unit_lists;
-UnitInterface::Units UnitInterface::units;
-UnitInterface::PlayerUnitList UnitInterface::playerUnitLists;
-UnitBucketArray UnitInterface::unit_bucket_array;
+UnitInterface::~UnitInterface()
+{
+    // nothing
+}
 
-PlacementMatrix UnitInterface::unit_placement_matrix;
-
-UnitID UnitInterface::lastUnitID;
-
-UnitOpcodeEncoder UnitInterface::opcode_encoder;
-
-Timer UnitInterface::message_timer;
-Timer UnitInterface::no_guarantee_message_timer;
-
-unsigned long   UnitInterface::sync_units_iterator;
-bool	        UnitInterface::sync_units_complete_flag;
-unsigned short  UnitInterface::sync_units_list_index;
-unsigned long   UnitInterface::sync_units_total_units;
-unsigned long   UnitInterface::sync_units_in_sync_count;
-unsigned long   UnitInterface::sync_units_in_sync_partial_count;
-unsigned int    UnitInterface::units_per_player;
-Timer		UnitInterface::sync_units_packet_timer;
-
-// ******************************************************************
-
 void
 UnitInterface::initialize( const unsigned int max_units )
 {
-    unit_bucket_array.initialize(MapInterface::getSize(), TileInterface::getTileSize() );
+    unit_black_board.initialize(global_game_state-&gt;world_map-&gt;getWidth(),
+                                global_game_state-&gt;world_map-&gt;getHeight());
 
+    unit_bucket_array.initialize(MapInterface::getSize(),
+                                 TileInterface::getTileSize());
+
     playerUnitLists.resize(PlayerInterface::getMaxPlayers());
 
     lastUnitID = 0;
@@ -93,6 +84,8 @@
 
 void UnitInterface::cleanUp()
 {
+    unit_black_board.cleanUp();
+
     unit_bucket_array.cleanUp();
 
     playerUnitLists.clear();
@@ -109,16 +102,8 @@
 void
 UnitInterface::reset()
 {
-    playerUnitLists.clear();
-    playerUnitLists.resize(PlayerInterface::getMaxPlayers());
-
-    unit_bucket_array.initialize( MapInterface::getSize(), TileInterface::getTileSize() );
-
-    for( Units::iterator i = units.begin();i != units.end(); ++i )
-    {
-        delete i-&gt;second;
-    }
-    units.clear();
+    cleanUp();
+    initialize(units_per_player);
 }
 
 // ******************************************************************
@@ -260,7 +245,7 @@
 
     unit_placement_matrix.reset( location );
 
-    for ( utype = 0; utype &lt; UnitProfileInterface::getNumUnitTypes(); ++utype )
+    for ( utype = 0; utype &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); ++utype )
     {
         numunits = unit_config.getSpawnUnitCount( utype );
         while ( numunits )
@@ -326,9 +311,9 @@
     PlayerState* player = PlayerInterface::getPlayer( player_index );
     unit_flag = player-&gt;getFlag();
 
-    if ( unit_type &lt; UnitProfileInterface::getNumUnitTypes() )
+    if ( unit_type &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes() )
     {
-        unit = new Unit(player, unit_type, id, location);
+        unit = new Unit(player, this, unit_type, id, location);
     }
     else
     {   // XXX change for a error window
@@ -359,7 +344,7 @@
     ParticleInterface::addHit(unit-&gt;unit_state);
 
     // unit explosion sound
-    sound-&gt;playAmbientSound(&quot;expl&quot;,
+    global_engine_state-&gt;sound_manager-&gt;playAmbientSound(&quot;expl&quot;,
             WorldViewInterface::getCameraDistance( unit-&gt;unit_state.location ));
 
     unit_bucket_array.removeUnit(unit);
@@ -373,346 +358,16 @@
 
 // ******************************************************************
 
-void
-UnitInterface::queryPlayerUnitsAt( std::vector&lt;UnitID&gt;&amp; working_list,
-                                   const iXY&amp; point,
-                                   const Uint16 player_id )
-{
-    UnitList &amp; ubl = unit_bucket_array.getBucketAssocWorldLoc(point);
-    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
-    {
-        Unit* unit = *i;
-        if( (*i)-&gt;unit_state.bounds(point)
-            &amp;&amp; (*i)-&gt;player-&gt;getID() == player_id )
-        {
-            working_list.push_back(unit-&gt;id);
-        }
-    }
-}
 
-// ******************************************************************
 
-void
-UnitInterface::queryUnitsInWorldRect( std::vector&lt;Unit *&gt;&amp; working_list,
-                                      const iRect&amp; rect )
-{
-    UnitList::iterator iter;
-    iRect bucket_rect;
-    unit_bucket_array.worldRectToBucketRect( rect, bucket_rect);
-
-    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
-    {
-        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
-        {
-            UnitList &amp; bucket_list = unit_bucket_array.getBucket(row, col);
-
-            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
-            {
-                if( rect.contains((*iter)-&gt;unit_state.location) )
-                {
-                    working_list.push_back(*iter);
-                }
-
-            }
-        }
-    }
-}
-
 // ******************************************************************
 
-void
-UnitInterface::queryPlayerUnitsInWorldRect( std::vector&lt;UnitID&gt;&amp; working_list,
-                                            const iRect&amp; rect,
-                                            const Uint16 player_id )
-{
-    UnitList::iterator iter;
-    iRect bucket_rect;
-    unit_bucket_array.worldRectToBucketRect( rect, bucket_rect);
 
-    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
-    {
-        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
-        {
-            UnitList &amp; bucket_list = unit_bucket_array.getBucket(row, col);
 
-            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
-            {
-                if(    rect.contains((*iter)-&gt;unit_state.location)
-                    &amp;&amp; (*iter)-&gt;player-&gt;getID() == player_id )
-                {
-                    working_list.push_back((*iter)-&gt;id);
-                }
-
-            }
-        }
-    }
-}
-
 // ******************************************************************
 
-void
-UnitInterface::queryNonPlayerUnitsInWorldRect( std::vector&lt;Unit *&gt;&amp; working_list,
-                                               const iRect&amp; rect,
-                                               const Uint16 player_id )
-{
-    UnitList::iterator iter;
-    iRect bucket_rect;
-    unit_bucket_array.worldRectToBucketRect( rect, bucket_rect);
-
-    for( int row = bucket_rect.min.y; row &lt;= bucket_rect.max.y; ++row )
-    {
-        for( int col = bucket_rect.min.x; col &lt;= bucket_rect.max.x; ++col )
-        {
-            UnitList &amp; bucket_list = unit_bucket_array.getBucket(row, col);
-
-            for( iter = bucket_list.begin(); iter != bucket_list.end(); ++iter )
-            {
-                if(    rect.contains((*iter)-&gt;unit_state.location)
-                    &amp;&amp; (*iter)-&gt;player-&gt;getID() != player_id )
-                {
-                    working_list.push_back(*iter);
-                }
-
-            }
-        }
-    }
-}
-
 // ******************************************************************
 
-bool
-UnitInterface::queryClosestUnit( Unit **closest_unit_ptr,
-                                 const iXY &amp;loc,
-                                 const Uint16 player_id,
-                                 unsigned char search_flags )
-{
-    long closest_magnitude = 0;
-    Unit* closest_unit = 0;
-
-    for(Units::iterator i = units.begin(); i != units.end(); ++i)
-    {
-        Unit* unit = i-&gt;second;
-
-        if(search_flags == _search_exclude_player
-                &amp;&amp; unit-&gt;player-&gt;getID() == player_id)
-            continue;
-
-        if(search_flags == _search_player
-                &amp;&amp; unit-&gt;player-&gt;getID() != player_id)
-            continue;
-
-        iXY delta;
-        long temp_mag;
-
-        if ( closest_unit == 0 )
-        {
-            closest_unit = unit;
-            delta  = loc - unit-&gt;unit_state.location;
-            closest_magnitude = long(delta.mag2());
-        }
-        else
-        {
-            delta  = loc - unit-&gt;unit_state.location;
-            temp_mag = long(delta.mag2());
-
-            if ( closest_magnitude &gt; temp_mag )
-            {
-                closest_unit = unit;
-                closest_magnitude = temp_mag;
-            }
-        }
-    }
-
-    if(closest_unit != 0)
-    {
-        *closest_unit_ptr = closest_unit;
-        return true;
-    }
-
-    *closest_unit_ptr = 0;
-    return false;
-}
-
-// ******************************************************************
-
-bool
-UnitInterface::queryClosestUnit( Unit **closest_unit_ptr,
-                                 const iRect &amp;bounding_rect,
-                                 const iXY &amp;loc )
-{
-    Unit *closest_unit = 0;
-    long closest_magnitude = 0;
-    iRect bucket_rect;
-    UnitList::iterator bucket_iter;
-
-    unit_bucket_array.worldRectToBucketRect( bounding_rect, bucket_rect );
-
-    for( long row_index = bucket_rect.min.y; row_index &lt;= bucket_rect.max.y; row_index++ )
-    {
-        for( long column_index = bucket_rect.min.x; column_index &lt;= bucket_rect.max.x; column_index++ )
-        {
-            UnitList &amp;bucket_list = unit_bucket_array.getBucket( row_index, column_index );
-
-            for ( bucket_iter = bucket_list.begin();
-                    bucket_iter != bucket_list.end(); ++bucket_iter)
-            {
-                iXY delta;
-                long temp_mag;
-
-                if ( closest_unit == 0 )
-                {
-                    closest_unit = *bucket_iter;
-                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
-                    closest_magnitude = long(delta.mag2());
-                }
-                else
-                {
-                    delta  = loc - (*bucket_iter)-&gt;unit_state.location;
-                    temp_mag = long(delta.mag2());
-
-                    if ( closest_magnitude &gt; temp_mag )
-                    {
-                        closest_unit = *bucket_iter;
-                        closest_magnitude = temp_mag;
-                    }
-                }
-            }
-        }
-    }
-
-    if( closest_unit != 0 )
-    {
-        *closest_unit_ptr = closest_unit;
-        return true;
-    }
-
-    *closest_unit_ptr = 0;
-    return false;
-}
-
-// ******************************************************************
-
-bool
-UnitInterface::queryClosestEnemyUnit( Unit **closest_unit_ptr,
-                                      const iXY &amp;loc,
-                                      const Uint16 player_index )
-{
-    Unit *closest_unit = 0;
-    long closest_magnitude = 0;
-
-    for(Units::iterator i = units.begin(); i != units.end(); ++i)
-    {
-        Unit* unit = i-&gt;second;
-        Uint16 unitPlayerID = unit-&gt;player-&gt;getID();
-
-        if(unitPlayerID == player_index
-                || PlayerInterface::isAllied(player_index, unitPlayerID))
-        {
-            continue;
-        }
-
-        iXY delta;
-        long temp_mag;
-
-        if ( closest_unit == 0 )
-        {
-            closest_unit = unit;
-            delta  = loc - unit-&gt;unit_state.location;
-            closest_magnitude = long(delta.mag2());
-        }
-        else
-        {
-            delta  = loc - unit-&gt;unit_state.location;
-            temp_mag = long(delta.mag2());
-
-            if ( closest_magnitude &gt; temp_mag )
-            {
-                closest_unit = unit;
-                closest_magnitude = temp_mag;
-            }
-        }
-    }
-
-    if( closest_unit != 0 )
-    {
-        *closest_unit_ptr = closest_unit;
-        return true;
-    }
-
-    *closest_unit_ptr = 0;
-    return false;
-}
-
-// ******************************************************************
-
-Unit *
-UnitInterface::queryUnitAtMapLoc( const iXY &amp; map_loc )
-{
-    iXY world_loc;
-    MapInterface::mapXYtoPointXY(map_loc, &amp;world_loc);
-
-    UnitList &amp; ubl = unit_bucket_array.getBucketAssocMapLoc(map_loc);
-    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
-    {
-        if ( (*i)-&gt;unit_state.bounds(world_loc) )
-        {
-            return *i;
-        }
-    }
-
-    return 0;
-}
-
-// ******************************************************************
-
-Unit *
-UnitInterface::queryNonPlayerUnitAtWorld( const iXY &amp; world_loc,
-                                          const Uint16 player_id )
-{
-    UnitList &amp; ubl = unit_bucket_array.getBucketAssocWorldLoc(world_loc);
-    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
-    {
-        if ( (*i)-&gt;unit_state.bounds(world_loc)
-              &amp;&amp; (*i)-&gt;player-&gt;getID() != player_id )
-        {
-            return *i;
-        }
-    }
-
-    return 0;
-}
-
-// ******************************************************************
-
-unsigned char
-UnitInterface::queryUnitLocationStatus( const iXY &amp; loc )
-{
-    Uint16 player_id = PlayerInterface::getLocalPlayerIndex();
-
-    UnitList &amp; ubl = unit_bucket_array.getBucketAssocWorldLoc(loc);
-    for(UnitList::iterator i = ubl.begin(); i != ubl.end(); ++i)
-    {
-        if ( (*i)-&gt;unit_state.bounds(loc) )
-        {
-            if ( (*i)-&gt;player-&gt;getID() == player_id )
-            {
-                return _unit_player;
-            }
-
-            if( PlayerInterface::isAllied(player_id, (*i)-&gt;player-&gt;getID()) )
-            {
-                return _unit_allied;
-            }
-
-            return _unit_enemy;
-        }
-    }
-
-    return _no_unit_found;
-}
-
-// ******************************************************************
-
 void
 UnitInterface::processNetPacket( const NetPacket* packet )
 {
@@ -834,10 +489,12 @@
 
     int unittype1 = unit1-&gt;unit_state.unit_type;
     const std::string&amp; unitname1 =
-        UnitProfileInterface::getUnitProfile(unittype1)-&gt;unitname;
+        global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unittype1)-&gt;unitname;
+
     int unittype2 = unit2-&gt;unit_state.unit_type;
     const std::string&amp; unitname2 =
-        UnitProfileInterface::getUnitProfile(unittype2)-&gt;unitname;
+        global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unittype2)-&gt;unitname;
+
     if(Console::server)
     {
         *Console::server &lt;&lt; &quot;'&quot; &lt;&lt; player1-&gt;getName() &lt;&lt; &quot;' killed a '&quot;
@@ -882,7 +539,7 @@
                                  player_index, create_mesg-&gt;getUnitID());
         addUnit(unit);
         // remove unit from blackboard in client (we are client here)
-        UnitBlackBoard::unmarkUnitLoc( unitpos );
+        global_game_state-&gt;unit_manager-&gt;unmarkUnitLoc( unitpos );
     }
     catch(std::exception&amp; e)
     {

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitInterface.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -29,6 +29,7 @@
 
 #include &quot;Classes/PlacementMatrix.hpp&quot;
 #include &quot;Classes/PlayerUnitConfig.hpp&quot;
+#include &quot;Units/UnitBlackBoard.hpp&quot;
 
 enum
 {
@@ -45,154 +46,136 @@
 class UnitInterface
 {
 public:
+    UnitBucketArray unit_bucket_array;
+
+    UnitInterface();
+    ~UnitInterface();
+
     // type definitions
     typedef std::map&lt;UnitID, Unit*&gt; Units;
     typedef std::vector&lt;UnitList&gt; PlayerUnitList;
 
     // initialization/cleanup
-    static void initialize( const unsigned int max_units );
-    static void cleanUp();
-    static void reset();
+    void initialize( const unsigned int max_units );
+    void cleanUp();
+    void reset();
 
     // unit getters
-    static Unit * getUnit( UnitID id )
+    Unit * getUnit( UnitID id )
     {
         Units::iterator i = units.find(id);
         return (i!=units.end())?i-&gt;second:0;
     }
 
-    static const Units&amp; getUnits()
+    const Units&amp; getUnits()
     {
         return units;
     }
 
-    static const UnitList&amp; getPlayerUnits( const Uint16 player_id )
+    const UnitList&amp; getPlayerUnits( const Uint16 player_id )
     {
         assert(player_id &lt; playerUnitLists.size());
         return playerUnitLists[player_id];
     }
 
-    static size_t getUnitCount( const Uint16 player_index )
+    size_t getUnitCount( const Uint16 player_index )
     {
         return getPlayerUnits(player_index).size();
     }
 
-    static size_t getTotalUnitCount()
+    size_t getTotalUnitCount()
     {
         return units.size();
     }
 
     // main loop methods
-    static void updateUnitStatus();
+    void updateUnitStatus();
 
     // graphic methods
-    static void offloadGraphics( SpriteSorter &amp;sorter );
+    void offloadGraphics( SpriteSorter &amp;sorter );
 
     // unit creation
-    static Unit* createUnit( const unsigned short unit_type,
+    Unit* createUnit( const unsigned short unit_type,
                              const iXY &amp;location,
                              const Uint16 player_id);
 
-    static void spawnPlayerUnits( const iXY &amp; location,
+    void spawnPlayerUnits( const iXY &amp; location,
                                   const Uint16 player_id,
                                   const PlayerUnitConfig &amp; unit_config );
 
-    static void destroyPlayerUnits( const Uint16 player_id );
+    void destroyPlayerUnits( const Uint16 player_id );
 
+    // message methods
+    void processNetPacket( const NetPacket* packet );
+    void sendMessage( const UnitMessage* message,
+                             const PlayerState* player = 0 );
 
-    // unit querying
-    static void queryPlayerUnitsAt( std::vector&lt;UnitID&gt;&amp; working_list,
-                                    const iXY&amp; point,
-                                    const Uint16 player_id );
+    void processNetMessage( const NetMessage *net_message );
 
-    static void queryUnitsInWorldRect( std::vector&lt;Unit *&gt;&amp; working_list,
-                                       const iRect&amp; rect );
+    bool unitOccupiesLoc( iXY &amp;unit_map_loc )
+    {
+        return unit_black_board.unitOccupiesLoc(unit_map_loc);
+    }
 
-    static void queryPlayerUnitsInWorldRect( std::vector&lt;UnitID&gt;&amp; working_list,
-                                             const iRect&amp; rect,
-                                             const Uint16 player_id );
+    void markUnitLoc( iXY &amp;unit_map_loc )
+    {
+        unit_black_board.markUnitLoc(unit_map_loc);
+    }
 
-    static void queryNonPlayerUnitsInWorldRect( std::vector&lt;Unit *&gt;&amp; working_list,
-                                                const iRect&amp; rect,
-                                                const Uint16 player_id );
+    void unmarkUnitLoc( iXY &amp;unit_map_loc )
+    {
+        unit_black_board.unmarkUnitLoc(unit_map_loc);
+    }
 
-    static bool queryClosestUnit( Unit **closest_unit_ptr,
-                                  const iXY &amp;loc,
-                                  const Uint16 player_id,
-                                  const unsigned char search_flags );
-
-    static bool queryClosestUnit( Unit **closest_unit_ptr,
-                                  const iRect &amp;bounding_rect,
-                                  const iXY &amp;loc );
-
-    static bool queryClosestEnemyUnit( Unit **closest_unit_ptr,
-                                       const iXY &amp;loc,
-                                       const Uint16 player_index );
-
-    static Unit * queryUnitAtMapLoc( const iXY &amp; map_loc );
-
-    static Unit * queryNonPlayerUnitAtWorld( const iXY &amp; world_loc,
-                                         const Uint16 player_id );
-
-    static unsigned char queryUnitLocationStatus( const iXY &amp; loc );
-
-    // message methods
-    static void processNetPacket( const NetPacket* packet );
-    static void sendMessage( const UnitMessage* message,
-                             const PlayerState* player = 0 );
-
-    static void processNetMessage( const NetMessage *net_message );
-
 private:
     friend class Unit;
 
+    UnitBlackBoard unit_black_board;
     // Unit Message Handler Methods
-    static void unitManagerMesgEndLifecycle( const UnitMessage *message );
+    void unitManagerMesgEndLifecycle( const UnitMessage *message );
 
     // Network Message Handler Variables
-    static Timer message_timer;
-    static Timer no_guarantee_message_timer;
-    static UnitOpcodeEncoder opcode_encoder;
+    Timer message_timer;
+    Timer no_guarantee_message_timer;
+    UnitOpcodeEncoder opcode_encoder;
 
     // Network Message Handler Methods
-    static void sendOpcode( const UnitOpcode* opcode )
+    void sendOpcode( const UnitOpcode* opcode )
     {
         opcode_encoder.encode(opcode);
     }
 
-    static void unitCreateMessage( const NetMessage *net_message );
-    static void unitDestroyMessage( const NetMessage *net_message );
-    static void unitSyncMessage( const NetMessage *net_message );
-    static void unitOpcodeMessage( const NetMessage *net_message );
-    static void unitSyncIntegrityCheckMessage( const NetMessage *net_message );
+    void unitCreateMessage( const NetMessage *net_message );
+    void unitDestroyMessage( const NetMessage *net_message );
+    void unitSyncMessage( const NetMessage *net_message );
+    void unitOpcodeMessage( const NetMessage *net_message );
+    void unitSyncIntegrityCheckMessage( const NetMessage *net_message );
 
-    static unsigned long  sync_units_iterator;
-    static bool           sync_units_complete_flag;
-    static unsigned short sync_units_list_index;
-    static Timer	  sync_units_packet_timer;
-    static unsigned long  sync_units_in_sync_count;
-    static unsigned long  sync_units_in_sync_partial_count;
-    static unsigned long  sync_units_total_units;
+    unsigned long  sync_units_iterator;
+    bool           sync_units_complete_flag;
+    unsigned short sync_units_list_index;
+    Timer	  sync_units_packet_timer;
+    unsigned long  sync_units_in_sync_count;
+    unsigned long  sync_units_in_sync_partial_count;
+    unsigned long  sync_units_total_units;
 
-    static Units units;
-    static PlayerUnitList playerUnitLists;
+    Units units;
+    PlayerUnitList playerUnitLists;
         
-    static UnitBucketArray unit_bucket_array;
-    static unsigned int units_per_player;
-    static PlacementMatrix unit_placement_matrix;
+    unsigned int units_per_player;
+    PlacementMatrix unit_placement_matrix;
 
-    static Uint16 lastUnitID;
-    static UnitID newUnitID();
+    Uint16 lastUnitID;
+    UnitID newUnitID();
 
-    static Unit* newUnit( const unsigned short unit_type,
+    Unit* newUnit( const unsigned short unit_type,
                           const iXY &amp;location,
                           const unsigned short player_index,
                           const UnitID id );
 
-    static void addUnit( Unit *unit );
+    void addUnit( Unit *unit );
     
-    static void removeUnit( Units::iterator i );
-
+    void removeUnit( Units::iterator i );
 };
 
 #endif // ** _UNITINTERFACE_HPP

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -360,8 +360,6 @@
     }
 } // function
 
-vector&lt;UnitProfile *&gt; UnitProfileInterface::profiles;
-
 void
 UnitProfileInterface::clearProfiles()
 {

Modified: trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.hpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.hpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Units/UnitProfileInterface.hpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -65,14 +65,14 @@
 class UnitProfileInterface
 {
 protected:
-    static vector&lt;UnitProfile *&gt; profiles;
-    static void clearProfiles();
+    vector&lt;UnitProfile *&gt; profiles;
+    void clearProfiles();
     
 public:
-    static void loadUnitProfiles( void );
-    static UnitProfile * getUnitProfile( unsigned short unit_type );
-    static UnitProfile * getProfileByName( const std::string &amp;name );
-    static unsigned short getNumUnitTypes()
+    void loadUnitProfiles( void );
+    UnitProfile * getUnitProfile( unsigned short unit_type );
+    UnitProfile * getProfileByName( const std::string &amp;name );
+    unsigned short getNumUnitTypes()
     {
         return profiles.size();
     }

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/InfoBar.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -18,6 +18,10 @@
  * Created on September 17, 2008, 8:50 PM
  */
 
+#include &quot;Core/GlobalGameState.hpp&quot;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Interfaces/BaseGameManager.hpp&quot;
+
 #include &quot;Views/Components/InfoBar.hpp&quot;
 #include &quot;2D/Palette.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
@@ -43,7 +47,7 @@
              &quot;game %s | units %3d/%-3d | frags %4d/%-4d | objs. %3d/%-3d | time %02d:%02d/%02d:%02d | FPS %.2f&quot;,
              gameconfig-&gt;getGameTypeString(),
              
-             int(UnitInterface::getUnitCount(PlayerInterface::getLocalPlayerIndex())),
+             int(global_game_state-&gt;unit_manager-&gt;getUnitCount(PlayerInterface::getLocalPlayerIndex())),
              gameconfig-&gt;maxunits / gameconfig-&gt;maxplayers,
              
              PlayerInterface::getLocalPlayer()-&gt;getTotal(),
@@ -52,8 +56,8 @@
              PlayerInterface::getLocalPlayer()-&gt;getObjectivesHeld(),
              (gameconfig-&gt;gametype == _gametype_objective)?ObjectiveInterface::getObjectiveLimit():0,
              
-             (int)GameManager::getGameTime() / 3600,
-             (int)(GameManager::getGameTime() / 60) % 60,
+             (int)global_engine_state-&gt;game_manager-&gt;getGameTime() / 3600,
+             (int)(global_engine_state-&gt;game_manager-&gt;getGameTime() / 60) % 60,
              (gameconfig-&gt;gametype == _gametype_timelimit)?gameconfig-&gt;timelimit / 60:0,
              (gameconfig-&gt;gametype == _gametype_timelimit)?gameconfig-&gt;timelimit % 60:0,
              

Modified: trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Components/MiniMap.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,14 +19,10 @@
  */
 
 #include &quot;Util/NTimer.hpp&quot;
-
-
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;Util/Log.hpp&quot;
 #include &quot;MiniMap.hpp&quot;
 
-
-// work in progres first has to change the input handling of game.
-
 #include &quot;Core/CoreTypes.hpp&quot;
 #include &quot;Views/Components/MiniMap.hpp&quot;
 #include &quot;2D/Surface.hpp&quot;
@@ -125,21 +121,22 @@
 {
     LOGGER.warning(&quot;Regenerating minimap....&quot;);
     
-    xratio = (float)MapInterface::getWidth() / surface.getWidth();    
-    yratio = (float)MapInterface::getHeight() / surface.getHeight();
+    WorldMap * map = global_game_state-&gt;world_map;
+    TileSet * tile_set = global_game_state-&gt;tile_set;
     float mapx;
     float mapy = 0.0f;
     const SDL_Color * oldColor;
+
+    xratio = (float)map-&gt;getWidth() / surface.getWidth();
+    yratio = (float)map-&gt;getHeight() / surface.getHeight();
     
     for ( int y=0; y&lt;(int)surface.getHeight(); y++)
     {
         mapx = 0.0f;
         for ( int x=0; x&lt;(int)surface.getWidth(); x++)
         {
-            // XXX float conversion
-            iXY pos((int)mapx,(int)mapy);
             // XXX Beware, no check for limits, could raise assert and quit the game.
-            oldColor = MapInterface::getAverageColorMapXY(pos);
+            oldColor = tile_set-&gt;getAverageTileColor(map-&gt;getValue((int)mapx, (int)mapy));
             surface.putPixel(x, y, oldColor-&gt;r, oldColor-&gt;g, oldColor-&gt;b);
             mapx += xratio;
         }
@@ -218,7 +215,7 @@
 void
 MiniMap::drawUnits(Surface &amp;dest)
 {
-    const UnitInterface::Units&amp; units = UnitInterface::getUnits();
+    const UnitInterface::Units&amp; units = global_game_state-&gt;unit_manager-&gt;getUnits();
     for(UnitInterface::Units::const_iterator i = units.begin();
             i != units.end(); ++i)
     {

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/CodeStatsView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,7 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;CodeStatsView.hpp&quot;
 #include &quot;Views/GameViewGlobals.hpp&quot;
 #include &quot;Classes/SpriteSorter.hpp&quot;
@@ -303,7 +303,7 @@
 
     for ( int i = 0; i &lt; max_players; i++ ) {
         unsigned long units;
-        units = UnitInterface::getUnitCount( i );
+        units = global_game_state-&gt;unit_manager-&gt;getUnitCount( i );
         total += units;
 
         sprintf(strBuf, &quot;Player %d : %lu  &quot;, i, units);

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/GameTemplateView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/GameTemplateView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/GameTemplateView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -88,6 +88,6 @@
 {
     View::doDeactivate();
 
-    Desktop::setActiveView(&quot;GameView&quot;);
+//    Desktop::setActiveView(&quot;GameView&quot;);
 
 } // end GameTemplateView::doDeactivate

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/GameView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -42,6 +42,8 @@
 #include &quot;Views/Components/InfoBar.hpp&quot;
 #include &quot;Views/Components/MiniMap.hpp&quot;
 
+#include &quot;Core/GlobalGameState.hpp&quot;
+
 int GameView::gDrawSolidBackground = 0;
 
 // GameView
@@ -113,7 +115,7 @@
     ParticleSystem2D::drawAll( SPRITE_SORTER );
     Particle2D::drawAll( SPRITE_SORTER );
 
-    UnitInterface::offloadGraphics( SPRITE_SORTER );
+    global_game_state-&gt;unit_manager-&gt;offloadGraphics( SPRITE_SORTER );
     ProjectileInterface::offloadGraphics( SPRITE_SORTER );
     ObjectiveInterface::offloadGraphics( SPRITE_SORTER );
     PowerUpInterface::offloadGraphics( SPRITE_SORTER );
@@ -169,7 +171,7 @@
 void
 GameView::drawMap(Surface &amp;window)
 {
-    TileSet * ts = TileInterface::getTileSet();
+    TileSet * ts = global_game_state-&gt;tile_set;
     unsigned long world_x;
     unsigned long world_y;
     unsigned short map_x;
@@ -197,7 +199,7 @@
     
     unsigned int tile = 0;
     
-    WorldMap * map = MapInterface::getMap();
+    WorldMap * map = global_game_state-&gt;world_map;
     
     unsigned short tmx;
     Surface * tile_surf = 0;
@@ -208,7 +210,7 @@
         for ( int x = start_x; x &lt; (int)window.getWidth(); x += tile_size )
         {
             tile = map-&gt;getValue(tmx++, map_y);
-            tile_surf = TileInterface::getTileSet()-&gt;getTile(tile);
+            tile_surf = ts-&gt;getTile(tile);
             if ( tile_surf )
             {
             	tile_surf-&gt;blt(window, x, y);

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/LoadingView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/LoadingView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/LoadingView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -9,6 +9,8 @@
 
 #include &quot;LoadingView.hpp&quot;
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+
 #include &quot;Interfaces/GameConfig.hpp&quot;
 #include &quot;System/Sound.hpp&quot;
 #include &quot;2D/Palette.hpp&quot;
@@ -103,7 +105,7 @@
             GameManager::exitNetPanzer();
             return;
         }
-        sound-&gt;stopTankIdle();
+        global_engine_state-&gt;sound_manager-&gt;stopTankIdle();
         Desktop::setVisibilityAllWindows(false);
         Desktop::setVisibility(&quot;MainView&quot;, true);
     }

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/RankView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -74,12 +74,13 @@
     add( new Label( xOffset, yOffset, &quot;Objective&quot;, Color::red, Color::gray64, true) );
     xOffset += MAX_POINTS_CHARS*CHAR_XPIX;
 
-        allyImage.loadPNG(&quot;pics/default/ally.png&quot;);
-        allyRequestImage.loadPNG(&quot;pics/default/allyRequest.png&quot;);
-        allyOtherImage.loadPNG(&quot;pics/default/allyOther.png&quot;);
-        noAllyImage.loadPNG(&quot;pics/default/noAlly.png&quot;);
-	
-	states.clear();
+    // shall be in resource manager
+    allyImage.loadPNG(&quot;pics/default/ally.png&quot;);
+    allyRequestImage.loadPNG(&quot;pics/default/allyRequest.png&quot;);
+    allyOtherImage.loadPNG(&quot;pics/default/allyOther.png&quot;);
+    noAllyImage.loadPNG(&quot;pics/default/noAlly.png&quot;);
+
+    states.clear();
 } // end RankView::RankView
 
 // doDraw

Modified: trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/Game/VehicleSelectionView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -17,6 +17,7 @@
 */
 
 
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;Util/Exception.hpp&quot;
 #include &quot;VehicleSelectionView.hpp&quot;
 #include &quot;Units/UnitTypes.hpp&quot;
@@ -232,11 +233,11 @@
     
     UnitSelectionButton *usb;
     UnitProfile *uprofile;
-    unitImages.create(48, 48, UnitProfileInterface::getNumUnitTypes());
+    unitImages.create(48, 48, global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes());
     // XXX order by something?
-    for ( int ut=0; ut &lt; UnitProfileInterface::getNumUnitTypes(); ut++)
+    for ( int ut=0; ut &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); ut++)
     {
-        uprofile = UnitProfileInterface::getUnitProfile(ut);
+        uprofile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(ut);
         
         tempSurface.loadPNG(uprofile-&gt;imagefile.c_str());
         unitImages.setFrame(ut);
@@ -405,7 +406,7 @@
     }
 
     int unitPerPlayer = gameconfig-&gt;maxunits / gameconfig-&gt;maxplayers;
-    sprintf(strBuf, &quot;%d/%d&quot;, int(UnitInterface::getUnitCount(PlayerInterface::getLocalPlayerIndex())), unitPerPlayer);
+    sprintf(strBuf, &quot;%d/%d&quot;, int(global_game_state-&gt;unit_manager-&gt;getUnitCount(PlayerInterface::getLocalPlayerIndex())), unitPerPlayer);
     drawString(unitsBuiltPos.x, unitsBuiltPos.y, strBuf, color);
 
     drawUnitProfileInfo( iXY(0, unitProfileDataY), highlightedUnitType);
@@ -430,7 +431,7 @@
 //---------------------------------------------------------------------------
 const char *VehicleSelectionView::getUnitName(int unitType)
 {
-    UnitProfile *p = UnitProfileInterface::getUnitProfile(unitType);
+    UnitProfile *p = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unitType);
     if ( p )
     {
         return p-&gt;unitname.c_str();
@@ -472,7 +473,7 @@
 //---------------------------------------------------------------------------
 int VehicleSelectionView::getUnitRegenTime(unsigned short unitType)
 {
-    UnitProfile *profile = UnitProfileInterface::getUnitProfile(unitType);
+    UnitProfile *profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unitType);
     if ( profile )
         return (int) profile-&gt;regen_time;
 
@@ -697,8 +698,8 @@
 //---------------------------------------------------------------------------
 void VehicleSelectionView::getProfileData()
 {
-    for (int i = 0; i &lt; UnitProfileInterface::getNumUnitTypes(); i++) {
-        const UnitProfile *p = UnitProfileInterface::getUnitProfile(i);
+    for (int i = 0; i &lt; global_game_state-&gt;unit_profile_interface-&gt;getNumUnitTypes(); i++) {
+        const UnitProfile *p = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(i);
 
         checkMaxValues(*p);
     }
@@ -739,7 +740,7 @@
         return;
     }
 
-    const UnitProfile *profile = UnitProfileInterface::getUnitProfile(unitType);
+    const UnitProfile *profile = global_game_state-&gt;unit_profile_interface-&gt;getUnitProfile(unitType);
 
     iXY       loc       = pos;
     const int gapSpace  = 10;

Modified: trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/HostJoinTemplateView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/HostJoinTemplateView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/MainMenu/Multi/HostJoinTemplateView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -37,6 +37,8 @@
 #include &quot;Classes/Network/NetworkClient.hpp&quot;
 #include &quot;Classes/Network/NetworkServer.hpp&quot;
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+
 char HostJoinTemplateView::gameTypeBuf[256];
 
 Surface playerColor;
@@ -135,7 +137,7 @@
 
             MenuTemplateView::freeBackgroundSurface();
 
-            ((PlayerGameManager*)gamemanager)-&gt;launchMultiPlayerGame();
+            ((PlayerGameManager*)global_engine_state-&gt;game_manager)-&gt;launchMultiPlayerGame();
             break;
 
         default:

Modified: trunk/netpanzer/src/NetPanzer/Views/MainMenu/Options/SoundView.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Views/MainMenu/Options/SoundView.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Views/MainMenu/Options/SoundView.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -19,6 +19,8 @@
 
 #include &quot;Views/Components/Button.hpp&quot;
 
+#include &quot;Core/GlobalEngineState.hpp&quot;
+
 #include &quot;SoundView.hpp&quot;
 #include &quot;Interfaces/GameConfig.hpp&quot;
 #include &quot;Views/GameViewGlobals.hpp&quot;
@@ -184,31 +186,50 @@
 
 void SoundView::stateChanged(Component* source)
 {
-    if (source == checkBoxSoundEnabled) {
+    if (source == checkBoxSoundEnabled)
+    {
         gameconfig-&gt;enablesound = checkBoxSoundEnabled-&gt;getState();
         
-        delete sound;
+        delete global_engine_state-&gt;sound_manager;
+        global_engine_state-&gt;sound_manager = 0;
 
-        if ( checkBoxSoundEnabled-&gt;getState() ) {
-            sound = new SDLSound();
+        if ( checkBoxSoundEnabled-&gt;getState() )
+        {
+            global_engine_state-&gt;sound_manager = new SDLSound();
             checkBoxSoundEnabled-&gt;setLabel(&quot;Enabled&quot;);
-            if ( GameControlRulesDaemon::getGameState() ) {
-                sound-&gt;playTankIdle();
+            if ( !global_engine_state-&gt;sound_manager )
+            {
+                global_engine_state-&gt;sound_manager = new DummySound();
             }
+
+            if ( GameControlRulesDaemon::getGameState() )
+            {
+                global_engine_state-&gt;sound_manager-&gt;playTankIdle();
+            }
+
             if ( checkBoxMusicEnabled-&gt;getState() )
-                sound-&gt;playMusic(&quot;sound/music/&quot;);
-        } else {
-            sound = new DummySound();
+            {
+                global_engine_state-&gt;sound_manager-&gt;playMusic(&quot;sound/music/&quot;);
+            }
+        }
+        else
+        {
+            global_engine_state-&gt;sound_manager = new DummySound();
             checkBoxSoundEnabled-&gt;setLabel(&quot;Disabled&quot;);
         }
-    } else if (source == checkBoxMusicEnabled) {
+    }
+    else if (source == checkBoxMusicEnabled)
+    {
         gameconfig-&gt;enablemusic = checkBoxMusicEnabled-&gt;getState();
         
-        if ( checkBoxMusicEnabled-&gt;getState() ) {
-            sound-&gt;playMusic(&quot;sound/music/&quot;);
+        if ( checkBoxMusicEnabled-&gt;getState() )
+        {
+            global_engine_state-&gt;sound_manager-&gt;playMusic(&quot;sound/music/&quot;);
             checkBoxMusicEnabled-&gt;setLabel(&quot;Enabled&quot;);
-        } else {
-            sound-&gt;stopMusic();
+        }
+        else
+        {
+            global_engine_state-&gt;sound_manager-&gt;stopMusic();
             checkBoxMusicEnabled-&gt;setLabel(&quot;Disabled&quot;);
         }
     }
@@ -226,7 +247,7 @@
             {
                 --v;
                 gameconfig-&gt;effectsvolume = v;
-                sound-&gt;setSoundVolume(v);
+                global_engine_state-&gt;sound_manager-&gt;setSoundVolume(v);
             }
             break;
 
@@ -236,7 +257,7 @@
             {
                 ++v;
                 gameconfig-&gt;effectsvolume = v;
-                sound-&gt;setSoundVolume(v);
+                global_engine_state-&gt;sound_manager-&gt;setSoundVolume(v);
             }
             break;
 
@@ -246,7 +267,7 @@
             {
                 --v;
                 gameconfig-&gt;musicvolume = v;
-                sound-&gt;setMusicVolume(v);
+                global_engine_state-&gt;sound_manager-&gt;setMusicVolume(v);
             }
             break;
 
@@ -256,7 +277,7 @@
             {
                 ++v;
                 gameconfig-&gt;musicvolume = v;
-                sound-&gt;setMusicVolume(v);
+                global_engine_state-&gt;sound_manager-&gt;setMusicVolume(v);
             }
             break;
 

Modified: trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Weapons/BulletWeapon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,8 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;BulletWeapon.hpp&quot;
 #include &quot;Classes/UnitMessageTypes.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
@@ -64,14 +65,14 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    UnitInterface::sendMessage( &amp;weapon_hit );
+                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;
                 lifecycle_status = _lifecycle_weapon_in_active;
 
                 //SFX
-                sound-&gt;playAmbientSound(&quot;hit&quot;,
+                global_engine_state-&gt;sound_manager-&gt;playAmbientSound(&quot;hit&quot;,
                         WorldViewInterface::getCameraDistance(location) );
 
                 end_cycle = true;

Modified: trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Weapons/MissleWeapon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,8 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;MissleWeapon.hpp&quot;
 #include &quot;Classes/UnitMessageTypes.hpp&quot;
 #include &quot;Classes/Network/NetworkState.hpp&quot;
@@ -113,14 +114,14 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    UnitInterface::sendMessage( &amp;weapon_hit );
+                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;
                 lifecycle_status = _lifecycle_weapon_in_active;
 
                 //SFX
-                sound-&gt;playAmbientSound(&quot;hit&quot;,
+                global_engine_state-&gt;sound_manager-&gt;playAmbientSound(&quot;hit&quot;,
                                         WorldViewInterface::getCameraDistance( location ) );
 
                 // **  Particle Shit

Modified: trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Weapons/ShellWeapon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -16,7 +16,8 @@
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
-
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 #include &quot;ShellWeapon.hpp&quot;
 #include &quot;Classes/UnitMessageTypes.hpp&quot;
 #include &quot;Units/UnitInterface.hpp&quot;
@@ -88,14 +89,14 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    UnitInterface::sendMessage( &amp;weapon_hit );
+                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;
                 lifecycle_status = _lifecycle_weapon_in_active;
 
                 //SFX
-                sound-&gt;playAmbientSound(&quot;hit&quot;,
+                global_engine_state-&gt;sound_manager-&gt;playAmbientSound(&quot;hit&quot;,
                                         WorldViewInterface::getCameraDistance( location ) );
 
                 // **  Particle Shit

Modified: trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp
===================================================================
--- trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp	2009-10-26 12:16:00 UTC (rev 1147)
+++ trunk/netpanzer/src/NetPanzer/Weapons/Weapon.cpp	2009-11-04 16:27:37 UTC (rev 1148)
@@ -18,6 +18,8 @@
 
 
 #include &lt;math.h&gt;
+#include &quot;Core/GlobalEngineState.hpp&quot;
+#include &quot;Core/GlobalGameState.hpp&quot;
 
 #include &quot;Weapons/Weapon.hpp&quot;
 
@@ -114,14 +116,14 @@
                     weapon_hit.setOwnerUnitID(owner_id);
                     weapon_hit.setHitLocation(location);
                     weapon_hit.setDamageFactor(damage_factor);
-                    UnitInterface::sendMessage( &amp;weapon_hit );
+                    global_game_state-&gt;unit_manager-&gt;sendMessage( &amp;weapon_hit );
                 }
 
                 fsmFlight_state = _fsmFlight_idle;
                 lifecycle_status = _lifecycle_weapon_in_active;
 
                 //SFX
-                sound-&gt;playSound(&quot;hit_target&quot;);
+                global_engine_state-&gt;sound_manager-&gt;playSound(&quot;hit_target&quot;);
 
                 // **  Particle Shit
                 iXY loc = iXY( location.x, location.y );


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000177.html">[Netpanzer-cvs] r1149 - in trunk/netpanzer: docs src/Lib/Util	src/NetPanzer/Core src/NetPanzer/Interfaces	src/NetPanzer/System src/NetPanzer/Views/Components	src/NetPanzer/Views/MainMenu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#176">[ date ]</a>
              <a href="thread.html#176">[ thread ]</a>
              <a href="subject.html#176">[ subject ]</a>
              <a href="author.html#176">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/netpanzer-cvs">More information about the Netpanzer-cvs
mailing list</a><br>
</body></html>
